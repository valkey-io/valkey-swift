//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2023 Apple Inc. and the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import RESP
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension RESPCommand {
    public enum GEOADDCondition: RESPRenderable {
        case nx
        case xx

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .nx: "NX".writeToRESPBuffer(&buffer)
            case .xx: "XX".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEOADDData: RESPRenderable {
        @usableFromInline let longitude: Double
        @usableFromInline let latitude: Double
        @usableFromInline let member: String

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += longitude.writeToRESPBuffer(&buffer)
            count += latitude.writeToRESPBuffer(&buffer)
            count += member.writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Adds one or more members to a geospatial index. The key is created if it doesn't exist.
    ///
    /// - Documentation: [GEOADD](https:/redis.io/docs/latest/commands/geoadd)
    /// - Version: 3.2.0
    /// - Complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
    /// - Categories: @write, @geo, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): When used without optional arguments, the number of elements added to the sorted set (excluding score updates).  If the CH option is specified, the number of elements that were changed (added or updated).
    @inlinable
    public static func geoadd(key: RedisKey, condition: GEOADDCondition? = nil, change: Bool = false, data: GEOADDData) -> RESPCommand {
        RESPCommand("GEOADD", key, condition, RedisPureToken("CH", change), data)
    }

    /// Adds one or more members to a geospatial index. The key is created if it doesn't exist.
    ///
    /// - Documentation: [GEOADD](https:/redis.io/docs/latest/commands/geoadd)
    /// - Version: 3.2.0
    /// - Complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
    /// - Categories: @write, @geo, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): When used without optional arguments, the number of elements added to the sorted set (excluding score updates).  If the CH option is specified, the number of elements that were changed (added or updated).
    @inlinable
    public static func geoadd(key: RedisKey, condition: GEOADDCondition? = nil, change: Bool = false, datas: [GEOADDData]) -> RESPCommand {
        RESPCommand("GEOADD", key, condition, RedisPureToken("CH", change), datas)
    }

    public enum GEODISTUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .m: "M".writeToRESPBuffer(&buffer)
            case .km: "KM".writeToRESPBuffer(&buffer)
            case .ft: "FT".writeToRESPBuffer(&buffer)
            case .mi: "MI".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Returns the distance between two members of a geospatial index.
    ///
    /// - Documentation: [GEODIST](https:/redis.io/docs/latest/commands/geodist)
    /// - Version: 3.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @geo, @slow
    /// - Response: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): one or both of the elements are missing.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): distance as a double (represented as a string) in the specified units.
    @inlinable
    public static func geodist(key: RedisKey, member1: String, member2: String, unit: GEODISTUnit? = nil) -> RESPCommand {
        RESPCommand("GEODIST", key, member1, member2, unit)
    }

    /// Returns members from a geospatial index as geohash strings.
    ///
    /// - Documentation: [GEOHASH](https:/redis.io/docs/latest/commands/geohash)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): An array where each element is the Geohash corresponding to each member name passed as an argument to the command.
    @inlinable
    public static func geohash(key: RedisKey, member: String? = nil) -> RESPCommand {
        RESPCommand("GEOHASH", key, member)
    }

    /// Returns members from a geospatial index as geohash strings.
    ///
    /// - Documentation: [GEOHASH](https:/redis.io/docs/latest/commands/geohash)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): An array where each element is the Geohash corresponding to each member name passed as an argument to the command.
    @inlinable
    public static func geohash(key: RedisKey, members: [String]) -> RESPCommand {
        RESPCommand("GEOHASH", key, members)
    }

    /// Returns the longitude and latitude of members from a geospatial index.
    ///
    /// - Documentation: [GEOPOS](https:/redis.io/docs/latest/commands/geopos)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): An array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command. Non-existing elements are reported as [Null](https:/redis.io/docs/reference/protocol-spec#nulls) elements of the array.
    @inlinable
    public static func geopos(key: RedisKey, member: String? = nil) -> RESPCommand {
        RESPCommand("GEOPOS", key, member)
    }

    /// Returns the longitude and latitude of members from a geospatial index.
    ///
    /// - Documentation: [GEOPOS](https:/redis.io/docs/latest/commands/geopos)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): An array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command. Non-existing elements are reported as [Null](https:/redis.io/docs/reference/protocol-spec#nulls) elements of the array.
    @inlinable
    public static func geopos(key: RedisKey, members: [String]) -> RESPCommand {
        RESPCommand("GEOPOS", key, members)
    }

    public enum GEORADIUSUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .m: "M".writeToRESPBuffer(&buffer)
            case .km: "KM".writeToRESPBuffer(&buffer)
            case .ft: "FT".writeToRESPBuffer(&buffer)
            case .mi: "MI".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEORADIUSCountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).writeToRESPBuffer(&buffer)
            if self.any { count += "ANY".writeToRESPBuffer(&buffer) }
            return count
        }
    }
    public enum GEORADIUSOrder: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .asc: "ASC".writeToRESPBuffer(&buffer)
            case .desc: "DESC".writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum GEORADIUSStore: RESPRenderable {
        case storekey(RedisKey)
        case storedistkey(RedisKey)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).writeToRESPBuffer(&buffer)
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Queries a geospatial index for members within a distance from a coordinate, optionally stores the result.
    ///
    /// - Documentation: [GEORADIUS](https:/redis.io/docs/latest/commands/georadius)
    /// - Version: 3.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @write, @geo, @slow
    /// - Response: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         1. The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         1. The Geohash integer.
    ///         1. The coordinates as a two items x,y array (longitude,latitude).
    ///     
    ///     For example, the command `GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST` will return each item in the following way:
    ///     
    ///     `["Palermo","190.4424",["13.361389338970184","38.115556395496299"]]`
    @inlinable
    public static func georadius(key: RedisKey, longitude: Double, latitude: Double, radius: Double, unit: GEORADIUSUnit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUSCountBlock? = nil, order: GEORADIUSOrder? = nil, store: GEORADIUSStore? = nil) -> RESPCommand {
        RESPCommand("GEORADIUS", key, longitude, latitude, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order, store)
    }

    public enum GEORADIUSBYMEMBERUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .m: "M".writeToRESPBuffer(&buffer)
            case .km: "KM".writeToRESPBuffer(&buffer)
            case .ft: "FT".writeToRESPBuffer(&buffer)
            case .mi: "MI".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEORADIUSBYMEMBERCountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).writeToRESPBuffer(&buffer)
            if self.any { count += "ANY".writeToRESPBuffer(&buffer) }
            return count
        }
    }
    public enum GEORADIUSBYMEMBEROrder: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .asc: "ASC".writeToRESPBuffer(&buffer)
            case .desc: "DESC".writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum GEORADIUSBYMEMBERStore: RESPRenderable {
        case storekey(RedisKey)
        case storedistkey(RedisKey)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).writeToRESPBuffer(&buffer)
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Queries a geospatial index for members within a distance from a member, optionally stores the result.
    ///
    /// - Documentation: [GEORADIUSBYMEMBER](https:/redis.io/docs/latest/commands/georadiusbymember)
    /// - Version: 3.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @write, @geo, @slow
    /// - Response: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public static func georadiusbymember(key: RedisKey, member: String, radius: Double, unit: GEORADIUSBYMEMBERUnit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUSBYMEMBERCountBlock? = nil, order: GEORADIUSBYMEMBEROrder? = nil, store: GEORADIUSBYMEMBERStore? = nil) -> RESPCommand {
        RESPCommand("GEORADIUSBYMEMBER", key, member, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order, store)
    }

    public enum GEORADIUSBYMEMBERROUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .m: "M".writeToRESPBuffer(&buffer)
            case .km: "KM".writeToRESPBuffer(&buffer)
            case .ft: "FT".writeToRESPBuffer(&buffer)
            case .mi: "MI".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEORADIUSBYMEMBERROCountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).writeToRESPBuffer(&buffer)
            if self.any { count += "ANY".writeToRESPBuffer(&buffer) }
            return count
        }
    }
    public enum GEORADIUSBYMEMBERROOrder: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .asc: "ASC".writeToRESPBuffer(&buffer)
            case .desc: "DESC".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Returns members from a geospatial index that are within a distance from a member.
    ///
    /// - Documentation: [GEORADIUSBYMEMBER_RO](https:/redis.io/docs/latest/commands/georadiusbymember_ro)
    /// - Version: 3.2.10
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @read, @geo, @slow
    /// - Response: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public static func georadiusbymemberRo(key: RedisKey, member: String, radius: Double, unit: GEORADIUSBYMEMBERROUnit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUSBYMEMBERROCountBlock? = nil, order: GEORADIUSBYMEMBERROOrder? = nil) -> RESPCommand {
        RESPCommand("GEORADIUSBYMEMBER_RO", key, member, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order)
    }

    public enum GEORADIUSROUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .m: "M".writeToRESPBuffer(&buffer)
            case .km: "KM".writeToRESPBuffer(&buffer)
            case .ft: "FT".writeToRESPBuffer(&buffer)
            case .mi: "MI".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEORADIUSROCountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).writeToRESPBuffer(&buffer)
            if self.any { count += "ANY".writeToRESPBuffer(&buffer) }
            return count
        }
    }
    public enum GEORADIUSROOrder: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .asc: "ASC".writeToRESPBuffer(&buffer)
            case .desc: "DESC".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Returns members from a geospatial index that are within a distance from a coordinate.
    ///
    /// - Documentation: [GEORADIUS_RO](https:/redis.io/docs/latest/commands/georadius_ro)
    /// - Version: 3.2.10
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @read, @geo, @slow
    /// - Response: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public static func georadiusRo(key: RedisKey, longitude: Double, latitude: Double, radius: Double, unit: GEORADIUSROUnit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUSROCountBlock? = nil, order: GEORADIUSROOrder? = nil) -> RESPCommand {
        RESPCommand("GEORADIUS_RO", key, longitude, latitude, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order)
    }

    public struct GEOSEARCHFromFromlonlat: RESPRenderable {
        @usableFromInline let longitude: Double
        @usableFromInline let latitude: Double

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += longitude.writeToRESPBuffer(&buffer)
            count += latitude.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum GEOSEARCHFrom: RESPRenderable {
        case member(String)
        case fromlonlat(GEOSEARCHFromFromlonlat)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).writeToRESPBuffer(&buffer)
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum GEOSEARCHByCircleUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .m: "M".writeToRESPBuffer(&buffer)
            case .km: "KM".writeToRESPBuffer(&buffer)
            case .ft: "FT".writeToRESPBuffer(&buffer)
            case .mi: "MI".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEOSEARCHByCircle: RESPRenderable {
        @usableFromInline let radius: Double
        @usableFromInline let unit: GEOSEARCHByCircleUnit

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("BYRADIUS", radius).writeToRESPBuffer(&buffer)
            count += unit.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum GEOSEARCHByBoxUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .m: "M".writeToRESPBuffer(&buffer)
            case .km: "KM".writeToRESPBuffer(&buffer)
            case .ft: "FT".writeToRESPBuffer(&buffer)
            case .mi: "MI".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEOSEARCHByBox: RESPRenderable {
        @usableFromInline let width: Double
        @usableFromInline let height: Double
        @usableFromInline let unit: GEOSEARCHByBoxUnit

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("BYBOX", width).writeToRESPBuffer(&buffer)
            count += height.writeToRESPBuffer(&buffer)
            count += unit.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum GEOSEARCHBy: RESPRenderable {
        case circle(GEOSEARCHByCircle)
        case box(GEOSEARCHByBox)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .circle(let circle): circle.writeToRESPBuffer(&buffer)
            case .box(let box): box.writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum GEOSEARCHOrder: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .asc: "ASC".writeToRESPBuffer(&buffer)
            case .desc: "DESC".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEOSEARCHCountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).writeToRESPBuffer(&buffer)
            if self.any { count += "ANY".writeToRESPBuffer(&buffer) }
            return count
        }
    }
    /// Queries a geospatial index for members inside an area of a box or a circle.
    ///
    /// - Documentation: [GEOSEARCH](https:/redis.io/docs/latest/commands/geosearch)
    /// - Version: 6.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
    /// - Categories: @read, @geo, @slow
    /// - Response: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public static func geosearch(key: RedisKey, from: GEOSEARCHFrom, by: GEOSEARCHBy, order: GEOSEARCHOrder? = nil, countBlock: GEOSEARCHCountBlock? = nil, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false) -> RESPCommand {
        RESPCommand("GEOSEARCH", key, from, by, order, countBlock, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash))
    }

    public struct GEOSEARCHSTOREFromFromlonlat: RESPRenderable {
        @usableFromInline let longitude: Double
        @usableFromInline let latitude: Double

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += longitude.writeToRESPBuffer(&buffer)
            count += latitude.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum GEOSEARCHSTOREFrom: RESPRenderable {
        case member(String)
        case fromlonlat(GEOSEARCHSTOREFromFromlonlat)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).writeToRESPBuffer(&buffer)
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum GEOSEARCHSTOREByCircleUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .m: "M".writeToRESPBuffer(&buffer)
            case .km: "KM".writeToRESPBuffer(&buffer)
            case .ft: "FT".writeToRESPBuffer(&buffer)
            case .mi: "MI".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEOSEARCHSTOREByCircle: RESPRenderable {
        @usableFromInline let radius: Double
        @usableFromInline let unit: GEOSEARCHSTOREByCircleUnit

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("BYRADIUS", radius).writeToRESPBuffer(&buffer)
            count += unit.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum GEOSEARCHSTOREByBoxUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .m: "M".writeToRESPBuffer(&buffer)
            case .km: "KM".writeToRESPBuffer(&buffer)
            case .ft: "FT".writeToRESPBuffer(&buffer)
            case .mi: "MI".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEOSEARCHSTOREByBox: RESPRenderable {
        @usableFromInline let width: Double
        @usableFromInline let height: Double
        @usableFromInline let unit: GEOSEARCHSTOREByBoxUnit

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("BYBOX", width).writeToRESPBuffer(&buffer)
            count += height.writeToRESPBuffer(&buffer)
            count += unit.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum GEOSEARCHSTOREBy: RESPRenderable {
        case circle(GEOSEARCHSTOREByCircle)
        case box(GEOSEARCHSTOREByBox)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .circle(let circle): circle.writeToRESPBuffer(&buffer)
            case .box(let box): box.writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum GEOSEARCHSTOREOrder: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .asc: "ASC".writeToRESPBuffer(&buffer)
            case .desc: "DESC".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct GEOSEARCHSTORECountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).writeToRESPBuffer(&buffer)
            if self.any { count += "ANY".writeToRESPBuffer(&buffer) }
            return count
        }
    }
    /// Queries a geospatial index for members inside an area of a box or a circle, optionally stores the result.
    ///
    /// - Documentation: [GEOSEARCHSTORE](https:/redis.io/docs/latest/commands/geosearchstore)
    /// - Version: 6.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
    /// - Categories: @write, @geo, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of elements in the resulting set
    @inlinable
    public static func geosearchstore(destination: RedisKey, source: RedisKey, from: GEOSEARCHSTOREFrom, by: GEOSEARCHSTOREBy, order: GEOSEARCHSTOREOrder? = nil, countBlock: GEOSEARCHSTORECountBlock? = nil, storedist: Bool = false) -> RESPCommand {
        RESPCommand("GEOSEARCHSTORE", destination, source, from, by, order, countBlock, RedisPureToken("STOREDIST", storedist))
    }

}

extension RedisClientConnection {
    /// Adds one or more members to a geospatial index. The key is created if it doesn't exist.
    ///
    /// - Documentation: [GEOADD](https:/redis.io/docs/latest/commands/geoadd)
    /// - Version: 3.2.0
    /// - Complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
    /// - Categories: @write, @geo, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): When used without optional arguments, the number of elements added to the sorted set (excluding score updates).  If the CH option is specified, the number of elements that were changed (added or updated).
    @inlinable
    public func geoadd(key: RedisKey, condition: RESPCommand.GEOADDCondition? = nil, change: Bool = false, data: RESPCommand.GEOADDData) async throws -> Int {
        try await send("GEOADD", key, condition, RedisPureToken("CH", change), data).converting()
    }

    /// Adds one or more members to a geospatial index. The key is created if it doesn't exist.
    ///
    /// - Documentation: [GEOADD](https:/redis.io/docs/latest/commands/geoadd)
    /// - Version: 3.2.0
    /// - Complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
    /// - Categories: @write, @geo, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): When used without optional arguments, the number of elements added to the sorted set (excluding score updates).  If the CH option is specified, the number of elements that were changed (added or updated).
    @inlinable
    public func geoadd(key: RedisKey, condition: RESPCommand.GEOADDCondition? = nil, change: Bool = false, datas: [RESPCommand.GEOADDData]) async throws -> Int {
        try await send("GEOADD", key, condition, RedisPureToken("CH", change), datas).converting()
    }

    /// Returns the distance between two members of a geospatial index.
    ///
    /// - Documentation: [GEODIST](https:/redis.io/docs/latest/commands/geodist)
    /// - Version: 3.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): one or both of the elements are missing.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): distance as a double (represented as a string) in the specified units.
    @inlinable
    public func geodist(key: RedisKey, member1: String, member2: String, unit: RESPCommand.GEODISTUnit? = nil) async throws -> String? {
        try await send("GEODIST", key, member1, member2, unit).converting()
    }

    /// Returns members from a geospatial index as geohash strings.
    ///
    /// - Documentation: [GEOHASH](https:/redis.io/docs/latest/commands/geohash)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): An array where each element is the Geohash corresponding to each member name passed as an argument to the command.
    @inlinable
    public func geohash(key: RedisKey, member: String? = nil) async throws -> [RESPToken] {
        try await send("GEOHASH", key, member).converting()
    }

    /// Returns members from a geospatial index as geohash strings.
    ///
    /// - Documentation: [GEOHASH](https:/redis.io/docs/latest/commands/geohash)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): An array where each element is the Geohash corresponding to each member name passed as an argument to the command.
    @inlinable
    public func geohash(key: RedisKey, members: [String]) async throws -> [RESPToken] {
        try await send("GEOHASH", key, members).converting()
    }

    /// Returns the longitude and latitude of members from a geospatial index.
    ///
    /// - Documentation: [GEOPOS](https:/redis.io/docs/latest/commands/geopos)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): An array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command. Non-existing elements are reported as [Null](https:/redis.io/docs/reference/protocol-spec#nulls) elements of the array.
    @inlinable
    public func geopos(key: RedisKey, member: String? = nil) async throws -> [RESPToken] {
        try await send("GEOPOS", key, member).converting()
    }

    /// Returns the longitude and latitude of members from a geospatial index.
    ///
    /// - Documentation: [GEOPOS](https:/redis.io/docs/latest/commands/geopos)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): An array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command. Non-existing elements are reported as [Null](https:/redis.io/docs/reference/protocol-spec#nulls) elements of the array.
    @inlinable
    public func geopos(key: RedisKey, members: [String]) async throws -> [RESPToken] {
        try await send("GEOPOS", key, members).converting()
    }

    /// Queries a geospatial index for members within a distance from a coordinate, optionally stores the result.
    ///
    /// - Documentation: [GEORADIUS](https:/redis.io/docs/latest/commands/georadius)
    /// - Version: 3.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @write, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         1. The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         1. The Geohash integer.
    ///         1. The coordinates as a two items x,y array (longitude,latitude).
    ///     
    ///     For example, the command `GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST` will return each item in the following way:
    ///     
    ///     `["Palermo","190.4424",["13.361389338970184","38.115556395496299"]]`
    @inlinable
    public func georadius(key: RedisKey, longitude: Double, latitude: Double, radius: Double, unit: RESPCommand.GEORADIUSUnit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: RESPCommand.GEORADIUSCountBlock? = nil, order: RESPCommand.GEORADIUSOrder? = nil, store: RESPCommand.GEORADIUSStore? = nil) async throws -> RESPToken {
        try await send("GEORADIUS", key, longitude, latitude, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order, store)
    }

    /// Queries a geospatial index for members within a distance from a member, optionally stores the result.
    ///
    /// - Documentation: [GEORADIUSBYMEMBER](https:/redis.io/docs/latest/commands/georadiusbymember)
    /// - Version: 3.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @write, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public func georadiusbymember(key: RedisKey, member: String, radius: Double, unit: RESPCommand.GEORADIUSBYMEMBERUnit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: RESPCommand.GEORADIUSBYMEMBERCountBlock? = nil, order: RESPCommand.GEORADIUSBYMEMBEROrder? = nil, store: RESPCommand.GEORADIUSBYMEMBERStore? = nil) async throws -> RESPToken {
        try await send("GEORADIUSBYMEMBER", key, member, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order, store)
    }

    /// Returns members from a geospatial index that are within a distance from a member.
    ///
    /// - Documentation: [GEORADIUSBYMEMBER_RO](https:/redis.io/docs/latest/commands/georadiusbymember_ro)
    /// - Version: 3.2.10
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public func georadiusbymemberRo(key: RedisKey, member: String, radius: Double, unit: RESPCommand.GEORADIUSBYMEMBERROUnit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: RESPCommand.GEORADIUSBYMEMBERROCountBlock? = nil, order: RESPCommand.GEORADIUSBYMEMBERROOrder? = nil) async throws -> RESPToken {
        try await send("GEORADIUSBYMEMBER_RO", key, member, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order)
    }

    /// Returns members from a geospatial index that are within a distance from a coordinate.
    ///
    /// - Documentation: [GEORADIUS_RO](https:/redis.io/docs/latest/commands/georadius_ro)
    /// - Version: 3.2.10
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public func georadiusRo(key: RedisKey, longitude: Double, latitude: Double, radius: Double, unit: RESPCommand.GEORADIUSROUnit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: RESPCommand.GEORADIUSROCountBlock? = nil, order: RESPCommand.GEORADIUSROOrder? = nil) async throws -> RESPToken {
        try await send("GEORADIUS_RO", key, longitude, latitude, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order)
    }

    /// Queries a geospatial index for members inside an area of a box or a circle.
    ///
    /// - Documentation: [GEOSEARCH](https:/redis.io/docs/latest/commands/geosearch)
    /// - Version: 6.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public func geosearch(key: RedisKey, from: RESPCommand.GEOSEARCHFrom, by: RESPCommand.GEOSEARCHBy, order: RESPCommand.GEOSEARCHOrder? = nil, countBlock: RESPCommand.GEOSEARCHCountBlock? = nil, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false) async throws -> RESPToken {
        try await send("GEOSEARCH", key, from, by, order, countBlock, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash))
    }

    /// Queries a geospatial index for members inside an area of a box or a circle, optionally stores the result.
    ///
    /// - Documentation: [GEOSEARCHSTORE](https:/redis.io/docs/latest/commands/geosearchstore)
    /// - Version: 6.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
    /// - Categories: @write, @geo, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of elements in the resulting set
    @inlinable
    public func geosearchstore(destination: RedisKey, source: RedisKey, from: RESPCommand.GEOSEARCHSTOREFrom, by: RESPCommand.GEOSEARCHSTOREBy, order: RESPCommand.GEOSEARCHSTOREOrder? = nil, countBlock: RESPCommand.GEOSEARCHSTORECountBlock? = nil, storedist: Bool = false) async throws -> Int {
        try await send("GEOSEARCHSTORE", destination, source, from, by, order, countBlock, RedisPureToken("STOREDIST", storedist)).converting()
    }

}
