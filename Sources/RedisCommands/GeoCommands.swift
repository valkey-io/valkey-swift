//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2025 Apple Inc. and the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// Adds one or more members to a geospatial index. The key is created if it doesn't exist.
public struct GEOADD: RedisCommand {
    public enum Condition: RESPRenderable {
        case nx
        case xx

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .nx: "NX".encode(into: &commandEncoder)
            case .xx: "XX".encode(into: &commandEncoder)
            }
        }
    }
    public struct Data: RESPRenderable {
        @usableFromInline let longitude: Double
        @usableFromInline let latitude: Double
        @usableFromInline let member: String

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += longitude.encode(into: &commandEncoder)
            count += latitude.encode(into: &commandEncoder)
            count += member.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = Int

    public var key: RedisKey
    public var condition: Condition? = nil
    public var change: Bool = false
    public var data: [Data]

    @inlinable public init(key: RedisKey, condition: Condition? = nil, change: Bool = false, data: [Data]) {
        self.key = key
        self.condition = condition
        self.change = change
        self.data = data
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("GEOADD", key, condition, RedisPureToken("CH", change), data)
    }
}

/// Returns the distance between two members of a geospatial index.
public struct GEODIST: RedisCommand {
    public enum Unit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = String?

    public var key: RedisKey
    public var member1: String
    public var member2: String
    public var unit: Unit? = nil

    @inlinable public init(key: RedisKey, member1: String, member2: String, unit: Unit? = nil) {
        self.key = key
        self.member1 = member1
        self.member2 = member2
        self.unit = unit
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("GEODIST", key, member1, member2, unit)
    }
}

/// Returns members from a geospatial index as geohash strings.
public struct GEOHASH: RedisCommand {
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var member: [String] = []

    @inlinable public init(key: RedisKey, member: [String] = []) {
        self.key = key
        self.member = member
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("GEOHASH", key, member)
    }
}

/// Returns the longitude and latitude of members from a geospatial index.
public struct GEOPOS: RedisCommand {
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var member: [String] = []

    @inlinable public init(key: RedisKey, member: [String] = []) {
        self.key = key
        self.member = member
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("GEOPOS", key, member)
    }
}

/// Queries a geospatial index for members within a distance from a coordinate, optionally stores the result.
public struct GEORADIUS: RedisCommand {
    public enum Unit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            if self.any { count += "ANY".encode(into: &commandEncoder) }
            return count
        }
    }
    public enum Order: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public enum Store: RESPRenderable {
        case storekey(RedisKey)
        case storedistkey(RedisKey)

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).encode(into: &commandEncoder)
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken

    public var key: RedisKey
    public var longitude: Double
    public var latitude: Double
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool = false
    public var withdist: Bool = false
    public var withhash: Bool = false
    public var countBlock: CountBlock? = nil
    public var order: Order? = nil
    public var store: Store? = nil

    @inlinable public init(key: RedisKey, longitude: Double, latitude: Double, radius: Double, unit: Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: CountBlock? = nil, order: Order? = nil, store: Store? = nil) {
        self.key = key
        self.longitude = longitude
        self.latitude = latitude
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
        self.store = store
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("GEORADIUS", key, longitude, latitude, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order, store)
    }
}

/// Queries a geospatial index for members within a distance from a member, optionally stores the result.
public struct GEORADIUSBYMEMBER: RedisCommand {
    public enum Unit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            if self.any { count += "ANY".encode(into: &commandEncoder) }
            return count
        }
    }
    public enum Order: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public enum Store: RESPRenderable {
        case storekey(RedisKey)
        case storedistkey(RedisKey)

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).encode(into: &commandEncoder)
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken

    public var key: RedisKey
    public var member: String
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool = false
    public var withdist: Bool = false
    public var withhash: Bool = false
    public var countBlock: CountBlock? = nil
    public var order: Order? = nil
    public var store: Store? = nil

    @inlinable public init(key: RedisKey, member: String, radius: Double, unit: Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: CountBlock? = nil, order: Order? = nil, store: Store? = nil) {
        self.key = key
        self.member = member
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
        self.store = store
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("GEORADIUSBYMEMBER", key, member, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order, store)
    }
}

/// Returns members from a geospatial index that are within a distance from a member.
public struct GEORADIUSBYMEMBERRO: RedisCommand {
    public enum Unit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            if self.any { count += "ANY".encode(into: &commandEncoder) }
            return count
        }
    }
    public enum Order: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken

    public var key: RedisKey
    public var member: String
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool = false
    public var withdist: Bool = false
    public var withhash: Bool = false
    public var countBlock: CountBlock? = nil
    public var order: Order? = nil

    @inlinable public init(key: RedisKey, member: String, radius: Double, unit: Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: CountBlock? = nil, order: Order? = nil) {
        self.key = key
        self.member = member
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("GEORADIUSBYMEMBER_RO", key, member, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order)
    }
}

/// Returns members from a geospatial index that are within a distance from a coordinate.
public struct GEORADIUSRO: RedisCommand {
    public enum Unit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            if self.any { count += "ANY".encode(into: &commandEncoder) }
            return count
        }
    }
    public enum Order: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken

    public var key: RedisKey
    public var longitude: Double
    public var latitude: Double
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool = false
    public var withdist: Bool = false
    public var withhash: Bool = false
    public var countBlock: CountBlock? = nil
    public var order: Order? = nil

    @inlinable public init(key: RedisKey, longitude: Double, latitude: Double, radius: Double, unit: Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: CountBlock? = nil, order: Order? = nil) {
        self.key = key
        self.longitude = longitude
        self.latitude = latitude
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("GEORADIUS_RO", key, longitude, latitude, radius, unit, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash), countBlock, order)
    }
}

/// Queries a geospatial index for members inside an area of a box or a circle.
public struct GEOSEARCH: RedisCommand {
    public struct FromFromlonlat: RESPRenderable {
        @usableFromInline let longitude: Double
        @usableFromInline let latitude: Double

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += longitude.encode(into: &commandEncoder)
            count += latitude.encode(into: &commandEncoder)
            return count
        }
    }
    public enum From: RESPRenderable {
        case member(String)
        case fromlonlat(FromFromlonlat)

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).encode(into: &commandEncoder)
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).encode(into: &commandEncoder)
            }
        }
    }
    public enum ByCircleUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByCircle: RESPRenderable {
        @usableFromInline let radius: Double
        @usableFromInline let unit: ByCircleUnit

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("BYRADIUS", radius).encode(into: &commandEncoder)
            count += unit.encode(into: &commandEncoder)
            return count
        }
    }
    public enum ByBoxUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByBox: RESPRenderable {
        @usableFromInline let width: Double
        @usableFromInline let height: Double
        @usableFromInline let unit: ByBoxUnit

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("BYBOX", width).encode(into: &commandEncoder)
            count += height.encode(into: &commandEncoder)
            count += unit.encode(into: &commandEncoder)
            return count
        }
    }
    public enum By: RESPRenderable {
        case circle(ByCircle)
        case box(ByBox)

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .circle(let circle): circle.encode(into: &commandEncoder)
            case .box(let box): box.encode(into: &commandEncoder)
            }
        }
    }
    public enum Order: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            if self.any { count += "ANY".encode(into: &commandEncoder) }
            return count
        }
    }
    public typealias Response = RESPToken

    public var key: RedisKey
    public var from: From
    public var by: By
    public var order: Order? = nil
    public var countBlock: CountBlock? = nil
    public var withcoord: Bool = false
    public var withdist: Bool = false
    public var withhash: Bool = false

    @inlinable public init(key: RedisKey, from: From, by: By, order: Order? = nil, countBlock: CountBlock? = nil, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false) {
        self.key = key
        self.from = from
        self.by = by
        self.order = order
        self.countBlock = countBlock
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("GEOSEARCH", key, from, by, order, countBlock, RedisPureToken("WITHCOORD", withcoord), RedisPureToken("WITHDIST", withdist), RedisPureToken("WITHHASH", withhash))
    }
}

/// Queries a geospatial index for members inside an area of a box or a circle, optionally stores the result.
public struct GEOSEARCHSTORE: RedisCommand {
    public struct FromFromlonlat: RESPRenderable {
        @usableFromInline let longitude: Double
        @usableFromInline let latitude: Double

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += longitude.encode(into: &commandEncoder)
            count += latitude.encode(into: &commandEncoder)
            return count
        }
    }
    public enum From: RESPRenderable {
        case member(String)
        case fromlonlat(FromFromlonlat)

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).encode(into: &commandEncoder)
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).encode(into: &commandEncoder)
            }
        }
    }
    public enum ByCircleUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByCircle: RESPRenderable {
        @usableFromInline let radius: Double
        @usableFromInline let unit: ByCircleUnit

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("BYRADIUS", radius).encode(into: &commandEncoder)
            count += unit.encode(into: &commandEncoder)
            return count
        }
    }
    public enum ByBoxUnit: RESPRenderable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByBox: RESPRenderable {
        @usableFromInline let width: Double
        @usableFromInline let height: Double
        @usableFromInline let unit: ByBoxUnit

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("BYBOX", width).encode(into: &commandEncoder)
            count += height.encode(into: &commandEncoder)
            count += unit.encode(into: &commandEncoder)
            return count
        }
    }
    public enum By: RESPRenderable {
        case circle(ByCircle)
        case box(ByBox)

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .circle(let circle): circle.encode(into: &commandEncoder)
            case .box(let box): box.encode(into: &commandEncoder)
            }
        }
    }
    public enum Order: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            if self.any { count += "ANY".encode(into: &commandEncoder) }
            return count
        }
    }
    public typealias Response = Int

    public var destination: RedisKey
    public var source: RedisKey
    public var from: From
    public var by: By
    public var order: Order? = nil
    public var countBlock: CountBlock? = nil
    public var storedist: Bool = false

    @inlinable public init(destination: RedisKey, source: RedisKey, from: From, by: By, order: Order? = nil, countBlock: CountBlock? = nil, storedist: Bool = false) {
        self.destination = destination
        self.source = source
        self.from = from
        self.by = by
        self.order = order
        self.countBlock = countBlock
        self.storedist = storedist
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("GEOSEARCHSTORE", destination, source, from, by, order, countBlock, RedisPureToken("STOREDIST", storedist))
    }
}


extension RedisConnection {
    /// Adds one or more members to a geospatial index. The key is created if it doesn't exist.
    ///
    /// - Documentation: [GEOADD](https:/redis.io/docs/latest/commands/geoadd)
    /// - Version: 3.2.0
    /// - Complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
    /// - Categories: @write, @geo, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): When used without optional arguments, the number of elements added to the sorted set (excluding score updates).  If the CH option is specified, the number of elements that were changed (added or updated).
    @inlinable
    public func geoadd(key: RedisKey, condition: GEOADD.Condition? = nil, change: Bool = false, data: [GEOADD.Data]) async throws -> Int {
        try await send(command: GEOADD(key: key, condition: condition, change: change, data: data))
    }

    /// Returns the distance between two members of a geospatial index.
    ///
    /// - Documentation: [GEODIST](https:/redis.io/docs/latest/commands/geodist)
    /// - Version: 3.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): one or both of the elements are missing.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): distance as a double (represented as a string) in the specified units.
    @inlinable
    public func geodist(key: RedisKey, member1: String, member2: String, unit: GEODIST.Unit? = nil) async throws -> String? {
        try await send(command: GEODIST(key: key, member1: member1, member2: member2, unit: unit))
    }

    /// Returns members from a geospatial index as geohash strings.
    ///
    /// - Documentation: [GEOHASH](https:/redis.io/docs/latest/commands/geohash)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): An array where each element is the Geohash corresponding to each member name passed as an argument to the command.
    @inlinable
    public func geohash(key: RedisKey, member: [String] = []) async throws -> [RESPToken] {
        try await send(command: GEOHASH(key: key, member: member))
    }

    /// Returns the longitude and latitude of members from a geospatial index.
    ///
    /// - Documentation: [GEOPOS](https:/redis.io/docs/latest/commands/geopos)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): An array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command. Non-existing elements are reported as [Null](https:/redis.io/docs/reference/protocol-spec#nulls) elements of the array.
    @inlinable
    public func geopos(key: RedisKey, member: [String] = []) async throws -> [RESPToken] {
        try await send(command: GEOPOS(key: key, member: member))
    }

    /// Queries a geospatial index for members within a distance from a coordinate, optionally stores the result.
    ///
    /// - Documentation: [GEORADIUS](https:/redis.io/docs/latest/commands/georadius)
    /// - Version: 3.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @write, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         1. The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         1. The Geohash integer.
    ///         1. The coordinates as a two items x,y array (longitude,latitude).
    ///     
    ///     For example, the command `GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST` will return each item in the following way:
    ///     
    ///     `["Palermo","190.4424",["13.361389338970184","38.115556395496299"]]`
    @inlinable
    public func georadius(key: RedisKey, longitude: Double, latitude: Double, radius: Double, unit: GEORADIUS.Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUS.CountBlock? = nil, order: GEORADIUS.Order? = nil, store: GEORADIUS.Store? = nil) async throws -> RESPToken {
        try await send(command: GEORADIUS(key: key, longitude: longitude, latitude: latitude, radius: radius, unit: unit, withcoord: withcoord, withdist: withdist, withhash: withhash, countBlock: countBlock, order: order, store: store))
    }

    /// Queries a geospatial index for members within a distance from a member, optionally stores the result.
    ///
    /// - Documentation: [GEORADIUSBYMEMBER](https:/redis.io/docs/latest/commands/georadiusbymember)
    /// - Version: 3.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @write, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public func georadiusbymember(key: RedisKey, member: String, radius: Double, unit: GEORADIUSBYMEMBER.Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUSBYMEMBER.CountBlock? = nil, order: GEORADIUSBYMEMBER.Order? = nil, store: GEORADIUSBYMEMBER.Store? = nil) async throws -> RESPToken {
        try await send(command: GEORADIUSBYMEMBER(key: key, member: member, radius: radius, unit: unit, withcoord: withcoord, withdist: withdist, withhash: withhash, countBlock: countBlock, order: order, store: store))
    }

    /// Returns members from a geospatial index that are within a distance from a member.
    ///
    /// - Documentation: [GEORADIUSBYMEMBER_RO](https:/redis.io/docs/latest/commands/georadiusbymember_ro)
    /// - Version: 3.2.10
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public func georadiusbymemberRo(key: RedisKey, member: String, radius: Double, unit: GEORADIUSBYMEMBERRO.Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUSBYMEMBERRO.CountBlock? = nil, order: GEORADIUSBYMEMBERRO.Order? = nil) async throws -> RESPToken {
        try await send(command: GEORADIUSBYMEMBERRO(key: key, member: member, radius: radius, unit: unit, withcoord: withcoord, withdist: withdist, withhash: withhash, countBlock: countBlock, order: order))
    }

    /// Returns members from a geospatial index that are within a distance from a coordinate.
    ///
    /// - Documentation: [GEORADIUS_RO](https:/redis.io/docs/latest/commands/georadius_ro)
    /// - Version: 3.2.10
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public func georadiusRo(key: RedisKey, longitude: Double, latitude: Double, radius: Double, unit: GEORADIUSRO.Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUSRO.CountBlock? = nil, order: GEORADIUSRO.Order? = nil) async throws -> RESPToken {
        try await send(command: GEORADIUSRO(key: key, longitude: longitude, latitude: latitude, radius: radius, unit: unit, withcoord: withcoord, withdist: withdist, withhash: withhash, countBlock: countBlock, order: order))
    }

    /// Queries a geospatial index for members inside an area of a box or a circle.
    ///
    /// - Documentation: [GEOSEARCH](https:/redis.io/docs/latest/commands/geosearch)
    /// - Version: 6.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public func geosearch(key: RedisKey, from: GEOSEARCH.From, by: GEOSEARCH.By, order: GEOSEARCH.Order? = nil, countBlock: GEOSEARCH.CountBlock? = nil, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false) async throws -> RESPToken {
        try await send(command: GEOSEARCH(key: key, from: from, by: by, order: order, countBlock: countBlock, withcoord: withcoord, withdist: withdist, withhash: withhash))
    }

    /// Queries a geospatial index for members inside an area of a box or a circle, optionally stores the result.
    ///
    /// - Documentation: [GEOSEARCHSTORE](https:/redis.io/docs/latest/commands/geosearchstore)
    /// - Version: 6.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
    /// - Categories: @write, @geo, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of elements in the resulting set
    @inlinable
    public func geosearchstore(destination: RedisKey, source: RedisKey, from: GEOSEARCHSTORE.From, by: GEOSEARCHSTORE.By, order: GEOSEARCHSTORE.Order? = nil, countBlock: GEOSEARCHSTORE.CountBlock? = nil, storedist: Bool = false) async throws -> Int {
        try await send(command: GEOSEARCHSTORE(destination: destination, source: source, from: from, by: by, order: order, countBlock: countBlock, storedist: storedist))
    }

}
