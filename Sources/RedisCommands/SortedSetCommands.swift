//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2025 the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// Removes and returns a member by score from one or more sorted sets. Blocks until a member is available otherwise. Deletes the sorted set if the last element was popped.
public struct BZMPOP: RedisCommand {
    public enum Where: RESPRenderable {
        case min
        case max

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .min: "MIN".encode(into: &commandEncoder)
            case .max: "MAX".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = [RESPToken]?

    public var timeout: Double
    public var key: [RedisKey]
    public var `where`: Where
    public var count: Int? = nil

    @inlinable public init(timeout: Double, key: [RedisKey], `where`: Where, count: Int? = nil) {
        self.timeout = timeout
        self.key = key
        self.`where` = `where`
        self.count = count
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("BZMPOP", timeout, RESPArrayWithCount(key), `where`, RESPWithToken("COUNT", count))
    }
}

/// Removes and returns the member with the highest score from one or more sorted sets. Blocks until a member available otherwise.  Deletes the sorted set if the last element was popped.
public struct BZPOPMAX: RedisCommand {
    public typealias Response = [RESPToken]?

    public var key: [RedisKey]
    public var timeout: Double

    @inlinable public init(key: [RedisKey], timeout: Double) {
        self.key = key
        self.timeout = timeout
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("BZPOPMAX", key, timeout)
    }
}

/// Removes and returns the member with the lowest score from one or more sorted sets. Blocks until a member is available otherwise. Deletes the sorted set if the last element was popped.
public struct BZPOPMIN: RedisCommand {
    public typealias Response = [RESPToken]?

    public var key: [RedisKey]
    public var timeout: Double

    @inlinable public init(key: [RedisKey], timeout: Double) {
        self.key = key
        self.timeout = timeout
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("BZPOPMIN", key, timeout)
    }
}

/// Adds one or more members to a sorted set, or updates their scores. Creates the key if it doesn't exist.
public struct ZADD: RedisCommand {
    public enum Condition: RESPRenderable {
        case nx
        case xx

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .nx: "NX".encode(into: &commandEncoder)
            case .xx: "XX".encode(into: &commandEncoder)
            }
        }
    }
    public enum Comparison: RESPRenderable {
        case gt
        case lt

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .gt: "GT".encode(into: &commandEncoder)
            case .lt: "LT".encode(into: &commandEncoder)
            }
        }
    }
    public struct Data: RESPRenderable {
        @usableFromInline let score: Double
        @usableFromInline let member: String

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += score.encode(into: &commandEncoder)
            count += member.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = RESPToken

    public var key: RedisKey
    public var condition: Condition? = nil
    public var comparison: Comparison? = nil
    public var change: Bool = false
    public var increment: Bool = false
    public var data: [Data]

    @inlinable public init(key: RedisKey, condition: Condition? = nil, comparison: Comparison? = nil, change: Bool = false, increment: Bool = false, data: [Data]) {
        self.key = key
        self.condition = condition
        self.comparison = comparison
        self.change = change
        self.increment = increment
        self.data = data
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZADD", key, condition, comparison, RedisPureToken("CH", change), RedisPureToken("INCR", increment), data)
    }
}

/// Returns the number of members in a sorted set.
public struct ZCARD: RedisCommand {
    public typealias Response = Int

    public var key: RedisKey

    @inlinable public init(key: RedisKey) {
        self.key = key
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZCARD", key)
    }
}

/// Returns the count of members in a sorted set that have scores within a range.
public struct ZCOUNT: RedisCommand {
    public typealias Response = Int

    public var key: RedisKey
    public var min: Double
    public var max: Double

    @inlinable public init(key: RedisKey, min: Double, max: Double) {
        self.key = key
        self.min = min
        self.max = max
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZCOUNT", key, min, max)
    }
}

/// Returns the difference between multiple sorted sets.
public struct ZDIFF: RedisCommand {
    public typealias Response = [RESPToken]

    public var key: [RedisKey]
    public var withscores: Bool = false

    @inlinable public init(key: [RedisKey], withscores: Bool = false) {
        self.key = key
        self.withscores = withscores
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZDIFF", RESPArrayWithCount(key), RedisPureToken("WITHSCORES", withscores))
    }
}

/// Stores the difference of multiple sorted sets in a key.
public struct ZDIFFSTORE: RedisCommand {
    public typealias Response = Int

    public var destination: RedisKey
    public var key: [RedisKey]

    @inlinable public init(destination: RedisKey, key: [RedisKey]) {
        self.destination = destination
        self.key = key
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZDIFFSTORE", destination, RESPArrayWithCount(key))
    }
}

/// Increments the score of a member in a sorted set.
public struct ZINCRBY: RedisCommand {
    public typealias Response = Double

    public var key: RedisKey
    public var increment: Int
    public var member: String

    @inlinable public init(key: RedisKey, increment: Int, member: String) {
        self.key = key
        self.increment = increment
        self.member = member
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZINCRBY", key, increment, member)
    }
}

/// Returns the intersect of multiple sorted sets.
public struct ZINTER: RedisCommand {
    public enum Aggregate: RESPRenderable {
        case sum
        case min
        case max

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .sum: "SUM".encode(into: &commandEncoder)
            case .min: "MIN".encode(into: &commandEncoder)
            case .max: "MAX".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = [RESPToken]

    public var key: [RedisKey]
    public var weight: [Int] = []
    public var aggregate: Aggregate? = nil
    public var withscores: Bool = false

    @inlinable public init(key: [RedisKey], weight: [Int] = [], aggregate: Aggregate? = nil, withscores: Bool = false) {
        self.key = key
        self.weight = weight
        self.aggregate = aggregate
        self.withscores = withscores
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZINTER", RESPArrayWithCount(key), RESPWithToken("WEIGHTS", weight), RESPWithToken("AGGREGATE", aggregate), RedisPureToken("WITHSCORES", withscores))
    }
}

/// Returns the number of members of the intersect of multiple sorted sets.
public struct ZINTERCARD: RedisCommand {
    public typealias Response = Int

    public var key: [RedisKey]
    public var limit: Int? = nil

    @inlinable public init(key: [RedisKey], limit: Int? = nil) {
        self.key = key
        self.limit = limit
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZINTERCARD", RESPArrayWithCount(key), RESPWithToken("LIMIT", limit))
    }
}

/// Stores the intersect of multiple sorted sets in a key.
public struct ZINTERSTORE: RedisCommand {
    public enum Aggregate: RESPRenderable {
        case sum
        case min
        case max

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .sum: "SUM".encode(into: &commandEncoder)
            case .min: "MIN".encode(into: &commandEncoder)
            case .max: "MAX".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = Int

    public var destination: RedisKey
    public var key: [RedisKey]
    public var weight: [Int] = []
    public var aggregate: Aggregate? = nil

    @inlinable public init(destination: RedisKey, key: [RedisKey], weight: [Int] = [], aggregate: Aggregate? = nil) {
        self.destination = destination
        self.key = key
        self.weight = weight
        self.aggregate = aggregate
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZINTERSTORE", destination, RESPArrayWithCount(key), RESPWithToken("WEIGHTS", weight), RESPWithToken("AGGREGATE", aggregate))
    }
}

/// Returns the number of members in a sorted set within a lexicographical range.
public struct ZLEXCOUNT: RedisCommand {
    public typealias Response = Int

    public var key: RedisKey
    public var min: String
    public var max: String

    @inlinable public init(key: RedisKey, min: String, max: String) {
        self.key = key
        self.min = min
        self.max = max
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZLEXCOUNT", key, min, max)
    }
}

/// Returns the highest- or lowest-scoring members from one or more sorted sets after removing them. Deletes the sorted set if the last member was popped.
public struct ZMPOP: RedisCommand {
    public enum Where: RESPRenderable {
        case min
        case max

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .min: "MIN".encode(into: &commandEncoder)
            case .max: "MAX".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = [RESPToken]?

    public var key: [RedisKey]
    public var `where`: Where
    public var count: Int? = nil

    @inlinable public init(key: [RedisKey], `where`: Where, count: Int? = nil) {
        self.key = key
        self.`where` = `where`
        self.count = count
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZMPOP", RESPArrayWithCount(key), `where`, RESPWithToken("COUNT", count))
    }
}

/// Returns the score of one or more members in a sorted set.
public struct ZMSCORE: RedisCommand {
    public typealias Response = [RESPToken]?

    public var key: RedisKey
    public var member: [String]

    @inlinable public init(key: RedisKey, member: [String]) {
        self.key = key
        self.member = member
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZMSCORE", key, member)
    }
}

/// Returns the highest-scoring members from a sorted set after removing them. Deletes the sorted set if the last member was popped.
public struct ZPOPMAX: RedisCommand {
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var count: Int? = nil

    @inlinable public init(key: RedisKey, count: Int? = nil) {
        self.key = key
        self.count = count
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZPOPMAX", key, count)
    }
}

/// Returns the lowest-scoring members from a sorted set after removing them. Deletes the sorted set if the last member was popped.
public struct ZPOPMIN: RedisCommand {
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var count: Int? = nil

    @inlinable public init(key: RedisKey, count: Int? = nil) {
        self.key = key
        self.count = count
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZPOPMIN", key, count)
    }
}

/// Returns one or more random members from a sorted set.
public struct ZRANDMEMBER: RedisCommand {
    public struct Options: RESPRenderable {
        @usableFromInline let count: Int
        @usableFromInline let withscores: Bool

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += count.encode(into: &commandEncoder)
            if self.withscores { count += "WITHSCORES".encode(into: &commandEncoder) }
            return count
        }
    }
    public typealias Response = RESPToken

    public var key: RedisKey
    public var options: Options? = nil

    @inlinable public init(key: RedisKey, options: Options? = nil) {
        self.key = key
        self.options = options
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZRANDMEMBER", key, options)
    }
}

/// Returns members in a sorted set within a range of indexes.
public struct ZRANGE: RedisCommand {
    public enum Sortby: RESPRenderable {
        case byscore
        case bylex

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .byscore: "BYSCORE".encode(into: &commandEncoder)
            case .bylex: "BYLEX".encode(into: &commandEncoder)
            }
        }
    }
    public struct Limit: RESPRenderable {
        @usableFromInline let offset: Int
        @usableFromInline let count: Int

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += offset.encode(into: &commandEncoder)
            count += count.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var start: String
    public var stop: String
    public var sortby: Sortby? = nil
    public var rev: Bool = false
    public var limit: Limit? = nil
    public var withscores: Bool = false

    @inlinable public init(key: RedisKey, start: String, stop: String, sortby: Sortby? = nil, rev: Bool = false, limit: Limit? = nil, withscores: Bool = false) {
        self.key = key
        self.start = start
        self.stop = stop
        self.sortby = sortby
        self.rev = rev
        self.limit = limit
        self.withscores = withscores
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZRANGE", key, start, stop, sortby, RedisPureToken("REV", rev), RESPWithToken("LIMIT", limit), RedisPureToken("WITHSCORES", withscores))
    }
}

/// Returns members in a sorted set within a lexicographical range.
public struct ZRANGEBYLEX: RedisCommand {
    public struct Limit: RESPRenderable {
        @usableFromInline let offset: Int
        @usableFromInline let count: Int

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += offset.encode(into: &commandEncoder)
            count += count.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var min: String
    public var max: String
    public var limit: Limit? = nil

    @inlinable public init(key: RedisKey, min: String, max: String, limit: Limit? = nil) {
        self.key = key
        self.min = min
        self.max = max
        self.limit = limit
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZRANGEBYLEX", key, min, max, RESPWithToken("LIMIT", limit))
    }
}

/// Returns members in a sorted set within a range of scores.
public struct ZRANGEBYSCORE: RedisCommand {
    public struct Limit: RESPRenderable {
        @usableFromInline let offset: Int
        @usableFromInline let count: Int

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += offset.encode(into: &commandEncoder)
            count += count.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var min: Double
    public var max: Double
    public var withscores: Bool = false
    public var limit: Limit? = nil

    @inlinable public init(key: RedisKey, min: Double, max: Double, withscores: Bool = false, limit: Limit? = nil) {
        self.key = key
        self.min = min
        self.max = max
        self.withscores = withscores
        self.limit = limit
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZRANGEBYSCORE", key, min, max, RedisPureToken("WITHSCORES", withscores), RESPWithToken("LIMIT", limit))
    }
}

/// Stores a range of members from sorted set in a key.
public struct ZRANGESTORE: RedisCommand {
    public enum Sortby: RESPRenderable {
        case byscore
        case bylex

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .byscore: "BYSCORE".encode(into: &commandEncoder)
            case .bylex: "BYLEX".encode(into: &commandEncoder)
            }
        }
    }
    public struct Limit: RESPRenderable {
        @usableFromInline let offset: Int
        @usableFromInline let count: Int

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += offset.encode(into: &commandEncoder)
            count += count.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = Int

    public var dst: RedisKey
    public var src: RedisKey
    public var min: String
    public var max: String
    public var sortby: Sortby? = nil
    public var rev: Bool = false
    public var limit: Limit? = nil

    @inlinable public init(dst: RedisKey, src: RedisKey, min: String, max: String, sortby: Sortby? = nil, rev: Bool = false, limit: Limit? = nil) {
        self.dst = dst
        self.src = src
        self.min = min
        self.max = max
        self.sortby = sortby
        self.rev = rev
        self.limit = limit
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZRANGESTORE", dst, src, min, max, sortby, RedisPureToken("REV", rev), RESPWithToken("LIMIT", limit))
    }
}

/// Returns the index of a member in a sorted set ordered by ascending scores.
public struct ZRANK: RedisCommand {
    public typealias Response = RESPToken

    public var key: RedisKey
    public var member: String
    public var withscore: Bool = false

    @inlinable public init(key: RedisKey, member: String, withscore: Bool = false) {
        self.key = key
        self.member = member
        self.withscore = withscore
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZRANK", key, member, RedisPureToken("WITHSCORE", withscore))
    }
}

/// Removes one or more members from a sorted set. Deletes the sorted set if all members were removed.
public struct ZREM: RedisCommand {
    public typealias Response = Int

    public var key: RedisKey
    public var member: [String]

    @inlinable public init(key: RedisKey, member: [String]) {
        self.key = key
        self.member = member
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZREM", key, member)
    }
}

/// Removes members in a sorted set within a lexicographical range. Deletes the sorted set if all members were removed.
public struct ZREMRANGEBYLEX: RedisCommand {
    public typealias Response = Int

    public var key: RedisKey
    public var min: String
    public var max: String

    @inlinable public init(key: RedisKey, min: String, max: String) {
        self.key = key
        self.min = min
        self.max = max
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZREMRANGEBYLEX", key, min, max)
    }
}

/// Removes members in a sorted set within a range of indexes. Deletes the sorted set if all members were removed.
public struct ZREMRANGEBYRANK: RedisCommand {
    public typealias Response = Int

    public var key: RedisKey
    public var start: Int
    public var stop: Int

    @inlinable public init(key: RedisKey, start: Int, stop: Int) {
        self.key = key
        self.start = start
        self.stop = stop
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZREMRANGEBYRANK", key, start, stop)
    }
}

/// Removes members in a sorted set within a range of scores. Deletes the sorted set if all members were removed.
public struct ZREMRANGEBYSCORE: RedisCommand {
    public typealias Response = Int

    public var key: RedisKey
    public var min: Double
    public var max: Double

    @inlinable public init(key: RedisKey, min: Double, max: Double) {
        self.key = key
        self.min = min
        self.max = max
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZREMRANGEBYSCORE", key, min, max)
    }
}

/// Returns members in a sorted set within a range of indexes in reverse order.
public struct ZREVRANGE: RedisCommand {
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var start: Int
    public var stop: Int
    public var withscores: Bool = false

    @inlinable public init(key: RedisKey, start: Int, stop: Int, withscores: Bool = false) {
        self.key = key
        self.start = start
        self.stop = stop
        self.withscores = withscores
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZREVRANGE", key, start, stop, RedisPureToken("WITHSCORES", withscores))
    }
}

/// Returns members in a sorted set within a lexicographical range in reverse order.
public struct ZREVRANGEBYLEX: RedisCommand {
    public struct Limit: RESPRenderable {
        @usableFromInline let offset: Int
        @usableFromInline let count: Int

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += offset.encode(into: &commandEncoder)
            count += count.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var max: String
    public var min: String
    public var limit: Limit? = nil

    @inlinable public init(key: RedisKey, max: String, min: String, limit: Limit? = nil) {
        self.key = key
        self.max = max
        self.min = min
        self.limit = limit
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZREVRANGEBYLEX", key, max, min, RESPWithToken("LIMIT", limit))
    }
}

/// Returns members in a sorted set within a range of scores in reverse order.
public struct ZREVRANGEBYSCORE: RedisCommand {
    public struct Limit: RESPRenderable {
        @usableFromInline let offset: Int
        @usableFromInline let count: Int

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += offset.encode(into: &commandEncoder)
            count += count.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var max: Double
    public var min: Double
    public var withscores: Bool = false
    public var limit: Limit? = nil

    @inlinable public init(key: RedisKey, max: Double, min: Double, withscores: Bool = false, limit: Limit? = nil) {
        self.key = key
        self.max = max
        self.min = min
        self.withscores = withscores
        self.limit = limit
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZREVRANGEBYSCORE", key, max, min, RedisPureToken("WITHSCORES", withscores), RESPWithToken("LIMIT", limit))
    }
}

/// Returns the index of a member in a sorted set ordered by descending scores.
public struct ZREVRANK: RedisCommand {
    public typealias Response = RESPToken

    public var key: RedisKey
    public var member: String
    public var withscore: Bool = false

    @inlinable public init(key: RedisKey, member: String, withscore: Bool = false) {
        self.key = key
        self.member = member
        self.withscore = withscore
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZREVRANK", key, member, RedisPureToken("WITHSCORE", withscore))
    }
}

/// Iterates over members and scores of a sorted set.
public struct ZSCAN: RedisCommand {
    public typealias Response = [RESPToken]

    public var key: RedisKey
    public var cursor: Int
    public var pattern: String? = nil
    public var count: Int? = nil

    @inlinable public init(key: RedisKey, cursor: Int, pattern: String? = nil, count: Int? = nil) {
        self.key = key
        self.cursor = cursor
        self.pattern = pattern
        self.count = count
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZSCAN", key, cursor, RESPWithToken("MATCH", pattern), RESPWithToken("COUNT", count))
    }
}

/// Returns the score of a member in a sorted set.
public struct ZSCORE: RedisCommand {
    public typealias Response = Double?

    public var key: RedisKey
    public var member: String

    @inlinable public init(key: RedisKey, member: String) {
        self.key = key
        self.member = member
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZSCORE", key, member)
    }
}

/// Returns the union of multiple sorted sets.
public struct ZUNION: RedisCommand {
    public enum Aggregate: RESPRenderable {
        case sum
        case min
        case max

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .sum: "SUM".encode(into: &commandEncoder)
            case .min: "MIN".encode(into: &commandEncoder)
            case .max: "MAX".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = [RESPToken]

    public var key: [RedisKey]
    public var weight: [Int] = []
    public var aggregate: Aggregate? = nil
    public var withscores: Bool = false

    @inlinable public init(key: [RedisKey], weight: [Int] = [], aggregate: Aggregate? = nil, withscores: Bool = false) {
        self.key = key
        self.weight = weight
        self.aggregate = aggregate
        self.withscores = withscores
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZUNION", RESPArrayWithCount(key), RESPWithToken("WEIGHTS", weight), RESPWithToken("AGGREGATE", aggregate), RedisPureToken("WITHSCORES", withscores))
    }
}

/// Stores the union of multiple sorted sets in a key.
public struct ZUNIONSTORE: RedisCommand {
    public enum Aggregate: RESPRenderable {
        case sum
        case min
        case max

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            switch self {
            case .sum: "SUM".encode(into: &commandEncoder)
            case .min: "MIN".encode(into: &commandEncoder)
            case .max: "MAX".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = Int

    public var destination: RedisKey
    public var key: [RedisKey]
    public var weight: [Int] = []
    public var aggregate: Aggregate? = nil

    @inlinable public init(destination: RedisKey, key: [RedisKey], weight: [Int] = [], aggregate: Aggregate? = nil) {
        self.destination = destination
        self.key = key
        self.weight = weight
        self.aggregate = aggregate
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ZUNIONSTORE", destination, RESPArrayWithCount(key), RESPWithToken("WEIGHTS", weight), RESPWithToken("AGGREGATE", aggregate))
    }
}


extension RedisConnection {
    /// Removes and returns a member by score from one or more sorted sets. Blocks until a member is available otherwise. Deletes the sorted set if the last element was popped.
    ///
    /// - Documentation: [BZMPOP](https:/redis.io/docs/latest/commands/bzmpop)
    /// - Version: 7.0.0
    /// - Complexity: O(K) + O(M*log(N)) where K is the number of provided keys, N being the number of elements in the sorted set, and M being the number of elements popped.
    /// - Categories: @write, @sortedset, @slow, @blocking
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): when no element could be popped.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a two-element array with the first element being the name of the key from which elements were popped, and the second element is an array of the popped elements. Every entry in the elements array is also an array that contains the member and its score.
    @inlinable
    public func bzmpop(timeout: Double, key: [RedisKey], `where`: BZMPOP.Where, count: Int? = nil) async throws -> [RESPToken]? {
        try await send(command: BZMPOP(timeout: timeout, key: key, where: `where`, count: count))
    }

    /// Removes and returns the member with the highest score from one or more sorted sets. Blocks until a member available otherwise.  Deletes the sorted set if the last element was popped.
    ///
    /// - Documentation: [BZPOPMAX](https:/redis.io/docs/latest/commands/bzpopmax)
    /// - Version: 5.0.0
    /// - Complexity: O(log(N)) with N being the number of elements in the sorted set.
    /// - Categories: @write, @sortedset, @fast, @blocking
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): when no element could be popped and the _timeout_ expired.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): the keyname, popped member, and its score.
    @inlinable
    public func bzpopmax(key: [RedisKey], timeout: Double) async throws -> [RESPToken]? {
        try await send(command: BZPOPMAX(key: key, timeout: timeout))
    }

    /// Removes and returns the member with the lowest score from one or more sorted sets. Blocks until a member is available otherwise. Deletes the sorted set if the last element was popped.
    ///
    /// - Documentation: [BZPOPMIN](https:/redis.io/docs/latest/commands/bzpopmin)
    /// - Version: 5.0.0
    /// - Complexity: O(log(N)) with N being the number of elements in the sorted set.
    /// - Categories: @write, @sortedset, @fast, @blocking
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): when no element could be popped and the _timeout_ expired.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): the keyname, popped member, and its score.
    @inlinable
    public func bzpopmin(key: [RedisKey], timeout: Double) async throws -> [RESPToken]? {
        try await send(command: BZPOPMIN(key: key, timeout: timeout))
    }

    /// Adds one or more members to a sorted set, or updates their scores. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [ZADD](https:/redis.io/docs/latest/commands/zadd)
    /// - Version: 1.2.0
    /// - Complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
    /// - Categories: @write, @sortedset, @fast
    /// - Returns: Any of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the operation was aborted because of a conflict with one of the _XX/NX/LT/GT_ options.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of new members when the _CH_ option is not used.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of new or updated members when the _CH_ option is used.
    ///     * [Double](https:/redis.io/docs/reference/protocol-spec#doubles): the updated score of the member when the _INCR_ option is used.
    @inlinable
    public func zadd(key: RedisKey, condition: ZADD.Condition? = nil, comparison: ZADD.Comparison? = nil, change: Bool = false, increment: Bool = false, data: [ZADD.Data]) async throws -> RESPToken {
        try await send(command: ZADD(key: key, condition: condition, comparison: comparison, change: change, increment: increment, data: data))
    }

    /// Returns the number of members in a sorted set.
    ///
    /// - Documentation: [ZCARD](https:/redis.io/docs/latest/commands/zcard)
    /// - Version: 1.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @sortedset, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the cardinality (number of members) of the sorted set, or 0 if the key doesn't exist.
    @inlinable
    public func zcard(key: RedisKey) async throws -> Int {
        try await send(command: ZCARD(key: key))
    }

    /// Returns the count of members in a sorted set that have scores within a range.
    ///
    /// - Documentation: [ZCOUNT](https:/redis.io/docs/latest/commands/zcount)
    /// - Version: 2.0.0
    /// - Complexity: O(log(N)) with N being the number of elements in the sorted set.
    /// - Categories: @read, @sortedset, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of members in the specified score range.
    @inlinable
    public func zcount(key: RedisKey, min: Double, max: Double) async throws -> Int {
        try await send(command: ZCOUNT(key: key, min: min, max: max))
    }

    /// Returns the difference between multiple sorted sets.
    ///
    /// - Documentation: [ZDIFF](https:/redis.io/docs/latest/commands/zdiff)
    /// - Version: 6.2.0
    /// - Complexity: O(L + (N-K)log(N)) worst case where L is the total number of elements in all the sets, N is the size of the first set, and K is the size of the result set.
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): the result of the difference including, optionally, scores when the _WITHSCORES_ option is used.
    @inlinable
    public func zdiff(key: [RedisKey], withscores: Bool = false) async throws -> [RESPToken] {
        try await send(command: ZDIFF(key: key, withscores: withscores))
    }

    /// Stores the difference of multiple sorted sets in a key.
    ///
    /// - Documentation: [ZDIFFSTORE](https:/redis.io/docs/latest/commands/zdiffstore)
    /// - Version: 6.2.0
    /// - Complexity: O(L + (N-K)log(N)) worst case where L is the total number of elements in all the sets, N is the size of the first set, and K is the size of the result set.
    /// - Categories: @write, @sortedset, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of members in the resulting sorted set at _destination_.
    @inlinable
    public func zdiffstore(destination: RedisKey, key: [RedisKey]) async throws -> Int {
        try await send(command: ZDIFFSTORE(destination: destination, key: key))
    }

    /// Increments the score of a member in a sorted set.
    ///
    /// - Documentation: [ZINCRBY](https:/redis.io/docs/latest/commands/zincrby)
    /// - Version: 1.2.0
    /// - Complexity: O(log(N)) where N is the number of elements in the sorted set.
    /// - Categories: @write, @sortedset, @fast
    /// - Returns: [Double](https:/redis.io/docs/reference/protocol-spec#doubles): the new score of _member_.
    @inlinable
    public func zincrby(key: RedisKey, increment: Int, member: String) async throws -> Double {
        try await send(command: ZINCRBY(key: key, increment: increment, member: member))
    }

    /// Returns the intersect of multiple sorted sets.
    ///
    /// - Documentation: [ZINTER](https:/redis.io/docs/latest/commands/zinter)
    /// - Version: 6.2.0
    /// - Complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set.
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): the result of the intersection including, optionally, scores when the _WITHSCORES_ option is used.
    @inlinable
    public func zinter(key: [RedisKey], weight: [Int] = [], aggregate: ZINTER.Aggregate? = nil, withscores: Bool = false) async throws -> [RESPToken] {
        try await send(command: ZINTER(key: key, weight: weight, aggregate: aggregate, withscores: withscores))
    }

    /// Returns the number of members of the intersect of multiple sorted sets.
    ///
    /// - Documentation: [ZINTERCARD](https:/redis.io/docs/latest/commands/zintercard)
    /// - Version: 7.0.0
    /// - Complexity: O(N*K) worst case with N being the smallest input sorted set, K being the number of input sorted sets.
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of members in the resulting intersection.
    @inlinable
    public func zintercard(key: [RedisKey], limit: Int? = nil) async throws -> Int {
        try await send(command: ZINTERCARD(key: key, limit: limit))
    }

    /// Stores the intersect of multiple sorted sets in a key.
    ///
    /// - Documentation: [ZINTERSTORE](https:/redis.io/docs/latest/commands/zinterstore)
    /// - Version: 2.0.0
    /// - Complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set.
    /// - Categories: @write, @sortedset, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of members in the resulting sorted set at the _destination_.
    @inlinable
    public func zinterstore(destination: RedisKey, key: [RedisKey], weight: [Int] = [], aggregate: ZINTERSTORE.Aggregate? = nil) async throws -> Int {
        try await send(command: ZINTERSTORE(destination: destination, key: key, weight: weight, aggregate: aggregate))
    }

    /// Returns the number of members in a sorted set within a lexicographical range.
    ///
    /// - Documentation: [ZLEXCOUNT](https:/redis.io/docs/latest/commands/zlexcount)
    /// - Version: 2.8.9
    /// - Complexity: O(log(N)) with N being the number of elements in the sorted set.
    /// - Categories: @read, @sortedset, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of members in the specified score range.
    @inlinable
    public func zlexcount(key: RedisKey, min: String, max: String) async throws -> Int {
        try await send(command: ZLEXCOUNT(key: key, min: min, max: max))
    }

    /// Returns the highest- or lowest-scoring members from one or more sorted sets after removing them. Deletes the sorted set if the last member was popped.
    ///
    /// - Documentation: [ZMPOP](https:/redis.io/docs/latest/commands/zmpop)
    /// - Version: 7.0.0
    /// - Complexity: O(K) + O(M*log(N)) where K is the number of provided keys, N being the number of elements in the sorted set, and M being the number of elements popped.
    /// - Categories: @write, @sortedset, @slow
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): when no element could be popped.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): A two-element array with the first element being the name of the key from which elements were popped, and the second element is an array of the popped elements. Every entry in the elements array is also an array that contains the member and its score.
    @inlinable
    public func zmpop(key: [RedisKey], `where`: ZMPOP.Where, count: Int? = nil) async throws -> [RESPToken]? {
        try await send(command: ZMPOP(key: key, where: `where`, count: count))
    }

    /// Returns the score of one or more members in a sorted set.
    ///
    /// - Documentation: [ZMSCORE](https:/redis.io/docs/latest/commands/zmscore)
    /// - Version: 6.2.0
    /// - Complexity: O(N) where N is the number of members being requested.
    /// - Categories: @read, @sortedset, @fast
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the member does not exist in the sorted set.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of [Double](https:/redis.io/docs/reference/protocol-spec#doubles) _member_ scores as double-precision floating point numbers.
    @inlinable
    public func zmscore(key: RedisKey, member: [String]) async throws -> [RESPToken]? {
        try await send(command: ZMSCORE(key: key, member: member))
    }

    /// Returns the highest-scoring members from a sorted set after removing them. Deletes the sorted set if the last member was popped.
    ///
    /// - Documentation: [ZPOPMAX](https:/redis.io/docs/latest/commands/zpopmax)
    /// - Version: 5.0.0
    /// - Complexity: O(log(N)*M) with N being the number of elements in the sorted set, and M being the number of elements popped.
    /// - Categories: @write, @sortedset, @fast
    /// - Returns: * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of popped elements and scores.
    @inlinable
    public func zpopmax(key: RedisKey, count: Int? = nil) async throws -> [RESPToken] {
        try await send(command: ZPOPMAX(key: key, count: count))
    }

    /// Returns the lowest-scoring members from a sorted set after removing them. Deletes the sorted set if the last member was popped.
    ///
    /// - Documentation: [ZPOPMIN](https:/redis.io/docs/latest/commands/zpopmin)
    /// - Version: 5.0.0
    /// - Complexity: O(log(N)*M) with N being the number of elements in the sorted set, and M being the number of elements popped.
    /// - Categories: @write, @sortedset, @fast
    /// - Returns: * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of popped elements and scores.
    @inlinable
    public func zpopmin(key: RedisKey, count: Int? = nil) async throws -> [RESPToken] {
        try await send(command: ZPOPMIN(key: key, count: count))
    }

    /// Returns one or more random members from a sorted set.
    ///
    /// - Documentation: [ZRANDMEMBER](https:/redis.io/docs/latest/commands/zrandmember)
    /// - Version: 6.2.0
    /// - Complexity: O(N) where N is the number of members returned
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): without the additional _count_ argument, the command returns a randomly selected member, or [Null](https:/redis.io/docs/reference/protocol-spec#nulls) when _key_ doesn't exist.
    ///     [Array](https:/redis.io/docs/reference/protocol-spec#arrays): when the additional _count_ argument is passed, the command returns an array of members, or an empty array when _key_ doesn't exist. If the _WITHSCORES_ modifier is used, the reply is a list of members and their scores from the sorted set.
    @inlinable
    public func zrandmember(key: RedisKey, options: ZRANDMEMBER.Options? = nil) async throws -> RESPToken {
        try await send(command: ZRANDMEMBER(key: key, options: options))
    }

    /// Returns members in a sorted set within a range of indexes.
    ///
    /// - Documentation: [ZRANGE](https:/redis.io/docs/latest/commands/zrange)
    /// - Version: 1.2.0
    /// - Complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of members in the specified range with, optionally, their scores when the _WITHSCORES_ option is given.
    @inlinable
    public func zrange(key: RedisKey, start: String, stop: String, sortby: ZRANGE.Sortby? = nil, rev: Bool = false, limit: ZRANGE.Limit? = nil, withscores: Bool = false) async throws -> [RESPToken] {
        try await send(command: ZRANGE(key: key, start: start, stop: stop, sortby: sortby, rev: rev, limit: limit, withscores: withscores))
    }

    /// Returns members in a sorted set within a lexicographical range.
    ///
    /// - Documentation: [ZRANGEBYLEX](https:/redis.io/docs/latest/commands/zrangebylex)
    /// - Version: 2.8.9
    /// - Complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of elements in the specified score range.
    @inlinable
    public func zrangebylex(key: RedisKey, min: String, max: String, limit: ZRANGEBYLEX.Limit? = nil) async throws -> [RESPToken] {
        try await send(command: ZRANGEBYLEX(key: key, min: min, max: max, limit: limit))
    }

    /// Returns members in a sorted set within a range of scores.
    ///
    /// - Documentation: [ZRANGEBYSCORE](https:/redis.io/docs/latest/commands/zrangebyscore)
    /// - Version: 1.0.5
    /// - Complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of the members with, optionally, their scores in the specified score range.
    @inlinable
    public func zrangebyscore(key: RedisKey, min: Double, max: Double, withscores: Bool = false, limit: ZRANGEBYSCORE.Limit? = nil) async throws -> [RESPToken] {
        try await send(command: ZRANGEBYSCORE(key: key, min: min, max: max, withscores: withscores, limit: limit))
    }

    /// Stores a range of members from sorted set in a key.
    ///
    /// - Documentation: [ZRANGESTORE](https:/redis.io/docs/latest/commands/zrangestore)
    /// - Version: 6.2.0
    /// - Complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements stored into the destination key.
    /// - Categories: @write, @sortedset, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of elements in the resulting sorted set.
    @inlinable
    public func zrangestore(dst: RedisKey, src: RedisKey, min: String, max: String, sortby: ZRANGESTORE.Sortby? = nil, rev: Bool = false, limit: ZRANGESTORE.Limit? = nil) async throws -> Int {
        try await send(command: ZRANGESTORE(dst: dst, src: src, min: min, max: max, sortby: sortby, rev: rev, limit: limit))
    }

    /// Returns the index of a member in a sorted set ordered by ascending scores.
    ///
    /// - Documentation: [ZRANK](https:/redis.io/docs/latest/commands/zrank)
    /// - Version: 2.0.0
    /// - Complexity: O(log(N))
    /// - Categories: @read, @sortedset, @fast
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key does not exist or the member does not exist in the sorted set.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the rank of the member when _WITHSCORE_ is not used.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): the rank and score of the member when _WITHSCORE_ is used.
    @inlinable
    public func zrank(key: RedisKey, member: String, withscore: Bool = false) async throws -> RESPToken {
        try await send(command: ZRANK(key: key, member: member, withscore: withscore))
    }

    /// Removes one or more members from a sorted set. Deletes the sorted set if all members were removed.
    ///
    /// - Documentation: [ZREM](https:/redis.io/docs/latest/commands/zrem)
    /// - Version: 1.2.0
    /// - Complexity: O(M*log(N)) with N being the number of elements in the sorted set and M the number of elements to be removed.
    /// - Categories: @write, @sortedset, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of members removed from the sorted set, not including non-existing members.
    @inlinable
    public func zrem(key: RedisKey, member: [String]) async throws -> Int {
        try await send(command: ZREM(key: key, member: member))
    }

    /// Removes members in a sorted set within a lexicographical range. Deletes the sorted set if all members were removed.
    ///
    /// - Documentation: [ZREMRANGEBYLEX](https:/redis.io/docs/latest/commands/zremrangebylex)
    /// - Version: 2.8.9
    /// - Complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
    /// - Categories: @write, @sortedset, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): Number of members removed.
    @inlinable
    public func zremrangebylex(key: RedisKey, min: String, max: String) async throws -> Int {
        try await send(command: ZREMRANGEBYLEX(key: key, min: min, max: max))
    }

    /// Removes members in a sorted set within a range of indexes. Deletes the sorted set if all members were removed.
    ///
    /// - Documentation: [ZREMRANGEBYRANK](https:/redis.io/docs/latest/commands/zremrangebyrank)
    /// - Version: 2.0.0
    /// - Complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
    /// - Categories: @write, @sortedset, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): Number of members removed.
    @inlinable
    public func zremrangebyrank(key: RedisKey, start: Int, stop: Int) async throws -> Int {
        try await send(command: ZREMRANGEBYRANK(key: key, start: start, stop: stop))
    }

    /// Removes members in a sorted set within a range of scores. Deletes the sorted set if all members were removed.
    ///
    /// - Documentation: [ZREMRANGEBYSCORE](https:/redis.io/docs/latest/commands/zremrangebyscore)
    /// - Version: 1.2.0
    /// - Complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
    /// - Categories: @write, @sortedset, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): Number of members removed.
    @inlinable
    public func zremrangebyscore(key: RedisKey, min: Double, max: Double) async throws -> Int {
        try await send(command: ZREMRANGEBYSCORE(key: key, min: min, max: max))
    }

    /// Returns members in a sorted set within a range of indexes in reverse order.
    ///
    /// - Documentation: [ZREVRANGE](https:/redis.io/docs/latest/commands/zrevrange)
    /// - Version: 1.2.0
    /// - Complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of members in the specified range, optionally with their scores if _WITHSCORE_ was used.
    @inlinable
    public func zrevrange(key: RedisKey, start: Int, stop: Int, withscores: Bool = false) async throws -> [RESPToken] {
        try await send(command: ZREVRANGE(key: key, start: start, stop: stop, withscores: withscores))
    }

    /// Returns members in a sorted set within a lexicographical range in reverse order.
    ///
    /// - Documentation: [ZREVRANGEBYLEX](https:/redis.io/docs/latest/commands/zrevrangebylex)
    /// - Version: 2.8.9
    /// - Complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): List of the elements in the specified score range.
    @inlinable
    public func zrevrangebylex(key: RedisKey, max: String, min: String, limit: ZREVRANGEBYLEX.Limit? = nil) async throws -> [RESPToken] {
        try await send(command: ZREVRANGEBYLEX(key: key, max: max, min: min, limit: limit))
    }

    /// Returns members in a sorted set within a range of scores in reverse order.
    ///
    /// - Documentation: [ZREVRANGEBYSCORE](https:/redis.io/docs/latest/commands/zrevrangebyscore)
    /// - Version: 2.2.0
    /// - Complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of the members and, optionally, their scores in the specified score range.
    @inlinable
    public func zrevrangebyscore(key: RedisKey, max: Double, min: Double, withscores: Bool = false, limit: ZREVRANGEBYSCORE.Limit? = nil) async throws -> [RESPToken] {
        try await send(command: ZREVRANGEBYSCORE(key: key, max: max, min: min, withscores: withscores, limit: limit))
    }

    /// Returns the index of a member in a sorted set ordered by descending scores.
    ///
    /// - Documentation: [ZREVRANK](https:/redis.io/docs/latest/commands/zrevrank)
    /// - Version: 2.0.0
    /// - Complexity: O(log(N))
    /// - Categories: @read, @sortedset, @fast
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key does not exist or the member does not exist in the sorted set.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): The rank of the member when _WITHSCORE_ is not used.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): The rank and score of the member when _WITHSCORE_ is used.
    @inlinable
    public func zrevrank(key: RedisKey, member: String, withscore: Bool = false) async throws -> RESPToken {
        try await send(command: ZREVRANK(key: key, member: member, withscore: withscore))
    }

    /// Iterates over members and scores of a sorted set.
    ///
    /// - Documentation: [ZSCAN](https:/redis.io/docs/latest/commands/zscan)
    /// - Version: 2.8.0
    /// - Complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): cursor and scan response in array form.
    @inlinable
    public func zscan(key: RedisKey, cursor: Int, pattern: String? = nil, count: Int? = nil) async throws -> [RESPToken] {
        try await send(command: ZSCAN(key: key, cursor: cursor, pattern: pattern, count: count))
    }

    /// Returns the score of a member in a sorted set.
    ///
    /// - Documentation: [ZSCORE](https:/redis.io/docs/latest/commands/zscore)
    /// - Version: 1.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @sortedset, @fast
    /// - Returns: One of the following:
    ///     * [Double](https:/redis.io/docs/reference/protocol-spec#doubles): the score of the member (a double-precision floating point number).
    ///     * [Nil](https:/redis.io/docs/reference/protocol-spec#bulk-strings): if _member_ does not exist in the sorted set, or the key does not exist.
    @inlinable
    public func zscore(key: RedisKey, member: String) async throws -> Double? {
        try await send(command: ZSCORE(key: key, member: member))
    }

    /// Returns the union of multiple sorted sets.
    ///
    /// - Documentation: [ZUNION](https:/redis.io/docs/latest/commands/zunion)
    /// - Version: 6.2.0
    /// - Complexity: O(N)+O(M*log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set.
    /// - Categories: @read, @sortedset, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): the result of the union with, optionally, their scores when _WITHSCORES_ is used.
    @inlinable
    public func zunion(key: [RedisKey], weight: [Int] = [], aggregate: ZUNION.Aggregate? = nil, withscores: Bool = false) async throws -> [RESPToken] {
        try await send(command: ZUNION(key: key, weight: weight, aggregate: aggregate, withscores: withscores))
    }

    /// Stores the union of multiple sorted sets in a key.
    ///
    /// - Documentation: [ZUNIONSTORE](https:/redis.io/docs/latest/commands/zunionstore)
    /// - Version: 2.0.0
    /// - Complexity: O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set.
    /// - Categories: @write, @sortedset, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of elements in the resulting sorted set.
    @inlinable
    public func zunionstore(destination: RedisKey, key: [RedisKey], weight: [Int] = [], aggregate: ZUNIONSTORE.Aggregate? = nil) async throws -> Int {
        try await send(command: ZUNIONSTORE(destination: destination, key: key, weight: weight, aggregate: aggregate))
    }

}
