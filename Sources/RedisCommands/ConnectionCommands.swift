//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2023 Apple Inc. and the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import RESP
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension RESPCommand {
    /// Authenticates the connection.
    ///
    /// - Documentation: [AUTH](https:/redis.io/docs/latest/commands/auth)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of passwords defined for the user
    /// - Categories: @fast, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`, or an error if the password, or username/password pair, is invalid.
    @inlinable
    public static func auth(username: String? = nil, password: String) -> RESPCommand {
        RESPCommand("AUTH", username, password)
    }

    public enum CLIENTCACHINGMode: RESPRenderable {
        case yes
        case no

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .yes: "YES".writeToRESPBuffer(&buffer)
            case .no: "NO".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Instructs the server whether to track the keys in the next request.
    ///
    /// - Documentation: [CLIENT CACHING](https:/redis.io/docs/latest/commands/client-caching)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` or an error if the argument is not "yes" or "no".
    @inlinable
    public static func clientCaching(mode: CLIENTCACHINGMode) -> RESPCommand {
        RESPCommand("CLIENT", "CACHING", mode)
    }

    /// Returns the name of the connection.
    ///
    /// - Documentation: [CLIENT GETNAME](https:/redis.io/docs/latest/commands/client-getname)
    /// - Version: 2.6.9
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the connection name of the current connection.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): the connection name was not set.
    @inlinable
    public static func clientGetname() -> RESPCommand {
        RESPCommand("CLIENT", "GETNAME")
    }

    /// Returns the client ID to which the connection's tracking notifications are redirected.
    ///
    /// - Documentation: [CLIENT GETREDIR](https:/redis.io/docs/latest/commands/client-getredir)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` when not redirecting notifications to any client.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if client tracking is not enabled.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the ID of the client to which notification are being redirected.
    @inlinable
    public static func clientGetredir() -> RESPCommand {
        RESPCommand("CLIENT", "GETREDIR")
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [CLIENT HELP](https:/redis.io/docs/latest/commands/client-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of subcommands and their descriptions.
    @inlinable
    public static func clientHelp() -> RESPCommand {
        RESPCommand("CLIENT", "HELP")
    }

    /// Returns the unique client ID of the connection.
    ///
    /// - Documentation: [CLIENT ID](https:/redis.io/docs/latest/commands/client-id)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the ID of the client.
    @inlinable
    public static func clientId() -> RESPCommand {
        RESPCommand("CLIENT", "ID")
    }

    /// Returns information about the connection.
    ///
    /// - Documentation: [CLIENT INFO](https:/redis.io/docs/latest/commands/client-info)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): a unique string for the current client, as described at the `CLIENT LIST` page.
    @inlinable
    public static func clientInfo() -> RESPCommand {
        RESPCommand("CLIENT", "INFO")
    }

    public enum CLIENTKILLFilterNewFormatClientType: RESPRenderable {
        case normal
        case master
        case slave
        case replica
        case pubsub

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .normal: "NORMAL".writeToRESPBuffer(&buffer)
            case .master: "MASTER".writeToRESPBuffer(&buffer)
            case .slave: "SLAVE".writeToRESPBuffer(&buffer)
            case .replica: "REPLICA".writeToRESPBuffer(&buffer)
            case .pubsub: "PUBSUB".writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum CLIENTKILLFilterNewFormatSkipme: RESPRenderable {
        case yes
        case no

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .yes: "YES".writeToRESPBuffer(&buffer)
            case .no: "NO".writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum CLIENTKILLFilterNewFormat: RESPRenderable {
        case clientId(Int?)
        case clientType(CLIENTKILLFilterNewFormatClientType?)
        case username(String?)
        case addr(String?)
        case laddr(String?)
        case skipme(CLIENTKILLFilterNewFormatSkipme?)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .clientId(let clientId): RESPWithToken("ID", clientId).writeToRESPBuffer(&buffer)
            case .clientType(let clientType): RESPWithToken("TYPE", clientType).writeToRESPBuffer(&buffer)
            case .username(let username): RESPWithToken("USER", username).writeToRESPBuffer(&buffer)
            case .addr(let addr): RESPWithToken("ADDR", addr).writeToRESPBuffer(&buffer)
            case .laddr(let laddr): RESPWithToken("LADDR", laddr).writeToRESPBuffer(&buffer)
            case .skipme(let skipme): RESPWithToken("SKIPME", skipme).writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum CLIENTKILLFilter: RESPRenderable {
        case oldFormat(String)
        case newFormat([CLIENTKILLFilterNewFormat])

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .oldFormat(let oldFormat): oldFormat.writeToRESPBuffer(&buffer)
            case .newFormat(let newFormat): newFormat.writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Terminates open connections.
    ///
    /// - Documentation: [CLIENT KILL](https:/redis.io/docs/latest/commands/client-kill)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Response: One of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` when called in 3 argument format and the connection has been closed.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): when called in filter/value format, the number of clients killed.
    @inlinable
    public static func clientKill(filter: CLIENTKILLFilter) -> RESPCommand {
        RESPCommand("CLIENT", "KILL", filter)
    }

    public enum CLIENTLISTClientType: RESPRenderable {
        case normal
        case master
        case replica
        case pubsub

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .normal: "NORMAL".writeToRESPBuffer(&buffer)
            case .master: "MASTER".writeToRESPBuffer(&buffer)
            case .replica: "REPLICA".writeToRESPBuffer(&buffer)
            case .pubsub: "PUBSUB".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Lists open connections.
    ///
    /// - Documentation: [CLIENT LIST](https:/redis.io/docs/latest/commands/client-list)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Response: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): information and statistics about client connections.
    @inlinable
    public static func clientList(clientType: CLIENTLISTClientType? = nil, clientId: Int? = nil) -> RESPCommand {
        RESPCommand("CLIENT", "LIST", RESPWithToken("TYPE", clientType), RESPWithToken("ID", clientId))
    }

    /// Lists open connections.
    ///
    /// - Documentation: [CLIENT LIST](https:/redis.io/docs/latest/commands/client-list)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Response: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): information and statistics about client connections.
    @inlinable
    public static func clientList(clientType: CLIENTLISTClientType? = nil, clientIds: [Int]) -> RESPCommand {
        RESPCommand("CLIENT", "LIST", RESPWithToken("TYPE", clientType), RESPWithToken("ID", clientIds))
    }

    public enum CLIENTNOEVICTEnabled: RESPRenderable {
        case on
        case off

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .on: "ON".writeToRESPBuffer(&buffer)
            case .off: "OFF".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Sets the client eviction mode of the connection.
    ///
    /// - Documentation: [CLIENT NO-EVICT](https:/redis.io/docs/latest/commands/client-no-evict)
    /// - Version: 7.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func clientNoEvict(enabled: CLIENTNOEVICTEnabled) -> RESPCommand {
        RESPCommand("CLIENT", "NO-EVICT", enabled)
    }

    public enum CLIENTNOTOUCHEnabled: RESPRenderable {
        case on
        case off

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .on: "ON".writeToRESPBuffer(&buffer)
            case .off: "OFF".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Controls whether commands sent by the client affect the LRU/LFU of accessed keys.
    ///
    /// - Documentation: [CLIENT NO-TOUCH](https:/redis.io/docs/latest/commands/client-no-touch)
    /// - Version: 7.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func clientNoTouch(enabled: CLIENTNOTOUCHEnabled) -> RESPCommand {
        RESPCommand("CLIENT", "NO-TOUCH", enabled)
    }

    public enum CLIENTPAUSEMode: RESPRenderable {
        case write
        case all

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .write: "WRITE".writeToRESPBuffer(&buffer)
            case .all: "ALL".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Suspends commands processing.
    ///
    /// - Documentation: [CLIENT PAUSE](https:/redis.io/docs/latest/commands/client-pause)
    /// - Version: 3.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` or an error if the timeout is invalid.
    @inlinable
    public static func clientPause(timeout: Int, mode: CLIENTPAUSEMode? = nil) -> RESPCommand {
        RESPCommand("CLIENT", "PAUSE", timeout, mode)
    }

    public enum CLIENTREPLYAction: RESPRenderable {
        case on
        case off
        case skip

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .on: "ON".writeToRESPBuffer(&buffer)
            case .off: "OFF".writeToRESPBuffer(&buffer)
            case .skip: "SKIP".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Instructs the server whether to reply to commands.
    ///
    /// - Documentation: [CLIENT REPLY](https:/redis.io/docs/latest/commands/client-reply)
    /// - Version: 3.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` when called with `ON`. When called with either `OFF` or `SKIP` sub-commands, no reply is made.
    @inlinable
    public static func clientReply(action: CLIENTREPLYAction) -> RESPCommand {
        RESPCommand("CLIENT", "REPLY", action)
    }

    public enum CLIENTSETINFOAttr: RESPRenderable {
        case libname(String)
        case libver(String)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .libname(let libname): RESPWithToken("LIB-NAME", libname).writeToRESPBuffer(&buffer)
            case .libver(let libver): RESPWithToken("LIB-VER", libver).writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Sets information specific to the client or connection.
    ///
    /// - Documentation: [CLIENT SETINFO](https:/redis.io/docs/latest/commands/client-setinfo)
    /// - Version: 7.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the attribute name was successfully set.
    @inlinable
    public static func clientSetinfo(attr: CLIENTSETINFOAttr) -> RESPCommand {
        RESPCommand("CLIENT", "SETINFO", attr)
    }

    /// Sets the connection name.
    ///
    /// - Documentation: [CLIENT SETNAME](https:/redis.io/docs/latest/commands/client-setname)
    /// - Version: 2.6.9
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the connection name was successfully set.
    @inlinable
    public static func clientSetname(connectionName: String) -> RESPCommand {
        RESPCommand("CLIENT", "SETNAME", connectionName)
    }

    public enum CLIENTTRACKINGStatus: RESPRenderable {
        case on
        case off

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .on: "ON".writeToRESPBuffer(&buffer)
            case .off: "OFF".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Controls server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKING](https:/redis.io/docs/latest/commands/client-tracking)
    /// - Version: 6.0.0
    /// - Complexity: O(1). Some options may introduce additional complexity.
    /// - Categories: @slow, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the connection was successfully put in tracking mode or if the tracking mode was successfully disabled. Otherwise, an error is returned.
    @inlinable
    public static func clientTracking(status: CLIENTTRACKINGStatus, clientId: Int? = nil, prefix: String? = nil, bcast: Bool = false, optin: Bool = false, optout: Bool = false, noloop: Bool = false) -> RESPCommand {
        RESPCommand("CLIENT", "TRACKING", status, RESPWithToken("REDIRECT", clientId), RESPWithToken("PREFIX", prefix), RedisPureToken("BCAST", bcast), RedisPureToken("OPTIN", optin), RedisPureToken("OPTOUT", optout), RedisPureToken("NOLOOP", noloop))
    }

    /// Controls server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKING](https:/redis.io/docs/latest/commands/client-tracking)
    /// - Version: 6.0.0
    /// - Complexity: O(1). Some options may introduce additional complexity.
    /// - Categories: @slow, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the connection was successfully put in tracking mode or if the tracking mode was successfully disabled. Otherwise, an error is returned.
    @inlinable
    public static func clientTracking(status: CLIENTTRACKINGStatus, clientId: Int? = nil, prefixs: [String], bcast: Bool = false, optin: Bool = false, optout: Bool = false, noloop: Bool = false) -> RESPCommand {
        RESPCommand("CLIENT", "TRACKING", status, RESPWithToken("REDIRECT", clientId), RESPWithToken("PREFIX", prefixs), RedisPureToken("BCAST", bcast), RedisPureToken("OPTIN", optin), RedisPureToken("OPTOUT", optout), RedisPureToken("NOLOOP", noloop))
    }

    /// Returns information about server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKINGINFO](https:/redis.io/docs/latest/commands/client-trackinginfo)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Map](https:/redis.io/docs/reference/protocol-spec#maps): a list of tracking information sections and their respective values.
    @inlinable
    public static func clientTrackinginfo() -> RESPCommand {
        RESPCommand("CLIENT", "TRACKINGINFO")
    }

    public enum CLIENTUNBLOCKUnblockType: RESPRenderable {
        case timeout
        case error

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .timeout: "TIMEOUT".writeToRESPBuffer(&buffer)
            case .error: "ERROR".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Unblocks a client blocked by a blocking command from a different connection.
    ///
    /// - Documentation: [CLIENT UNBLOCK](https:/redis.io/docs/latest/commands/client-unblock)
    /// - Version: 5.0.0
    /// - Complexity: O(log N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the client was unblocked successfully.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the client wasn't unblocked.
    @inlinable
    public static func clientUnblock(clientId: Int, unblockType: CLIENTUNBLOCKUnblockType? = nil) -> RESPCommand {
        RESPCommand("CLIENT", "UNBLOCK", clientId, unblockType)
    }

    /// Resumes processing commands from paused clients.
    ///
    /// - Documentation: [CLIENT UNPAUSE](https:/redis.io/docs/latest/commands/client-unpause)
    /// - Version: 6.2.0
    /// - Complexity: O(N) Where N is the number of paused clients
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func clientUnpause() -> RESPCommand {
        RESPCommand("CLIENT", "UNPAUSE")
    }

    /// Returns the given string.
    ///
    /// - Documentation: [ECHO](https:/redis.io/docs/latest/commands/echo)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Response: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the given string.
    @inlinable
    public static func echo(message: String) -> RESPCommand {
        RESPCommand("ECHO", message)
    }

    public struct HELLOArgumentsAuth: RESPRenderable {
        @usableFromInline let username: String
        @usableFromInline let password: String

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += username.writeToRESPBuffer(&buffer)
            count += password.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public struct HELLOArguments: RESPRenderable {
        @usableFromInline let protover: Int
        @usableFromInline let auth: HELLOArgumentsAuth?
        @usableFromInline let clientname: String?

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += protover.writeToRESPBuffer(&buffer)
            count += RESPWithToken("AUTH", auth).writeToRESPBuffer(&buffer)
            count += RESPWithToken("SETNAME", clientname).writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Handshakes with the Redis server.
    ///
    /// - Documentation: [HELLO](https:/redis.io/docs/latest/commands/hello)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Response: [Map](https:/redis.io/docs/reference/protocol-spec#maps): a list of server properties.
    ///     [Simple error](https:/redis.io/docs/reference/protocol-spec#simple-errors): if the `protover` requested does not exist.
    @inlinable
    public static func hello(arguments: HELLOArguments? = nil) -> RESPCommand {
        RESPCommand("HELLO", arguments)
    }

    /// Returns the server's liveliness response.
    ///
    /// - Documentation: [PING](https:/redis.io/docs/latest/commands/ping)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Response: Any of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `PONG` when no argument is provided.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the provided argument.
    @inlinable
    public static func ping(message: String? = nil) -> RESPCommand {
        RESPCommand("PING", message)
    }

    /// Closes the connection.
    ///
    /// - Documentation: [QUIT](https:/redis.io/docs/latest/commands/quit)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func quit() -> RESPCommand {
        RESPCommand("QUIT")
    }

    /// Resets the connection.
    ///
    /// - Documentation: [RESET](https:/redis.io/docs/latest/commands/reset)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `RESET`.
    @inlinable
    public static func reset() -> RESPCommand {
        RESPCommand("RESET")
    }

    /// Changes the selected database.
    ///
    /// - Documentation: [SELECT](https:/redis.io/docs/latest/commands/select)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func select(index: Int) -> RESPCommand {
        RESPCommand("SELECT", index)
    }

}

extension RedisConnection {
    /// Authenticates the connection.
    ///
    /// - Documentation: [AUTH](https:/redis.io/docs/latest/commands/auth)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of passwords defined for the user
    /// - Categories: @fast, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`, or an error if the password, or username/password pair, is invalid.
    @inlinable
    public func auth(username: String? = nil, password: String) async throws {
        try await send("AUTH", username, password)
    }

    /// Instructs the server whether to track the keys in the next request.
    ///
    /// - Documentation: [CLIENT CACHING](https:/redis.io/docs/latest/commands/client-caching)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` or an error if the argument is not "yes" or "no".
    @inlinable
    public func clientCaching(mode: RESPCommand.CLIENTCACHINGMode) async throws {
        try await send("CLIENT", "CACHING", mode)
    }

    /// Returns the name of the connection.
    ///
    /// - Documentation: [CLIENT GETNAME](https:/redis.io/docs/latest/commands/client-getname)
    /// - Version: 2.6.9
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the connection name of the current connection.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): the connection name was not set.
    @inlinable
    public func clientGetname() async throws -> String? {
        try await send("CLIENT", "GETNAME").converting()
    }

    /// Returns the client ID to which the connection's tracking notifications are redirected.
    ///
    /// - Documentation: [CLIENT GETREDIR](https:/redis.io/docs/latest/commands/client-getredir)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` when not redirecting notifications to any client.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if client tracking is not enabled.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the ID of the client to which notification are being redirected.
    @inlinable
    public func clientGetredir() async throws -> Int {
        try await send("CLIENT", "GETREDIR").converting()
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [CLIENT HELP](https:/redis.io/docs/latest/commands/client-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of subcommands and their descriptions.
    @inlinable
    public func clientHelp() async throws -> [RESPToken] {
        try await send("CLIENT", "HELP").converting()
    }

    /// Returns the unique client ID of the connection.
    ///
    /// - Documentation: [CLIENT ID](https:/redis.io/docs/latest/commands/client-id)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the ID of the client.
    @inlinable
    public func clientId() async throws -> Int {
        try await send("CLIENT", "ID").converting()
    }

    /// Returns information about the connection.
    ///
    /// - Documentation: [CLIENT INFO](https:/redis.io/docs/latest/commands/client-info)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): a unique string for the current client, as described at the `CLIENT LIST` page.
    @inlinable
    public func clientInfo() async throws -> String {
        try await send("CLIENT", "INFO").converting()
    }

    /// Terminates open connections.
    ///
    /// - Documentation: [CLIENT KILL](https:/redis.io/docs/latest/commands/client-kill)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: One of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` when called in 3 argument format and the connection has been closed.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): when called in filter/value format, the number of clients killed.
    @inlinable
    public func clientKill(filter: RESPCommand.CLIENTKILLFilter) async throws -> Int? {
        try await send("CLIENT", "KILL", filter).converting()
    }

    /// Lists open connections.
    ///
    /// - Documentation: [CLIENT LIST](https:/redis.io/docs/latest/commands/client-list)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): information and statistics about client connections.
    @inlinable
    public func clientList(clientType: RESPCommand.CLIENTLISTClientType? = nil, clientId: Int? = nil) async throws -> String {
        try await send("CLIENT", "LIST", RESPWithToken("TYPE", clientType), RESPWithToken("ID", clientId)).converting()
    }

    /// Lists open connections.
    ///
    /// - Documentation: [CLIENT LIST](https:/redis.io/docs/latest/commands/client-list)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): information and statistics about client connections.
    @inlinable
    public func clientList(clientType: RESPCommand.CLIENTLISTClientType? = nil, clientIds: [Int]) async throws -> String {
        try await send("CLIENT", "LIST", RESPWithToken("TYPE", clientType), RESPWithToken("ID", clientIds)).converting()
    }

    /// Sets the client eviction mode of the connection.
    ///
    /// - Documentation: [CLIENT NO-EVICT](https:/redis.io/docs/latest/commands/client-no-evict)
    /// - Version: 7.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func clientNoEvict(enabled: RESPCommand.CLIENTNOEVICTEnabled) async throws {
        try await send("CLIENT", "NO-EVICT", enabled)
    }

    /// Controls whether commands sent by the client affect the LRU/LFU of accessed keys.
    ///
    /// - Documentation: [CLIENT NO-TOUCH](https:/redis.io/docs/latest/commands/client-no-touch)
    /// - Version: 7.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func clientNoTouch(enabled: RESPCommand.CLIENTNOTOUCHEnabled) async throws {
        try await send("CLIENT", "NO-TOUCH", enabled)
    }

    /// Suspends commands processing.
    ///
    /// - Documentation: [CLIENT PAUSE](https:/redis.io/docs/latest/commands/client-pause)
    /// - Version: 3.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` or an error if the timeout is invalid.
    @inlinable
    public func clientPause(timeout: Int, mode: RESPCommand.CLIENTPAUSEMode? = nil) async throws {
        try await send("CLIENT", "PAUSE", timeout, mode)
    }

    /// Instructs the server whether to reply to commands.
    ///
    /// - Documentation: [CLIENT REPLY](https:/redis.io/docs/latest/commands/client-reply)
    /// - Version: 3.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` when called with `ON`. When called with either `OFF` or `SKIP` sub-commands, no reply is made.
    @inlinable
    public func clientReply(action: RESPCommand.CLIENTREPLYAction) async throws {
        try await send("CLIENT", "REPLY", action)
    }

    /// Sets information specific to the client or connection.
    ///
    /// - Documentation: [CLIENT SETINFO](https:/redis.io/docs/latest/commands/client-setinfo)
    /// - Version: 7.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the attribute name was successfully set.
    @inlinable
    public func clientSetinfo(attr: RESPCommand.CLIENTSETINFOAttr) async throws {
        try await send("CLIENT", "SETINFO", attr)
    }

    /// Sets the connection name.
    ///
    /// - Documentation: [CLIENT SETNAME](https:/redis.io/docs/latest/commands/client-setname)
    /// - Version: 2.6.9
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the connection name was successfully set.
    @inlinable
    public func clientSetname(connectionName: String) async throws {
        try await send("CLIENT", "SETNAME", connectionName)
    }

    /// Controls server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKING](https:/redis.io/docs/latest/commands/client-tracking)
    /// - Version: 6.0.0
    /// - Complexity: O(1). Some options may introduce additional complexity.
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the connection was successfully put in tracking mode or if the tracking mode was successfully disabled. Otherwise, an error is returned.
    @inlinable
    public func clientTracking(status: RESPCommand.CLIENTTRACKINGStatus, clientId: Int? = nil, prefix: String? = nil, bcast: Bool = false, optin: Bool = false, optout: Bool = false, noloop: Bool = false) async throws {
        try await send("CLIENT", "TRACKING", status, RESPWithToken("REDIRECT", clientId), RESPWithToken("PREFIX", prefix), RedisPureToken("BCAST", bcast), RedisPureToken("OPTIN", optin), RedisPureToken("OPTOUT", optout), RedisPureToken("NOLOOP", noloop))
    }

    /// Controls server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKING](https:/redis.io/docs/latest/commands/client-tracking)
    /// - Version: 6.0.0
    /// - Complexity: O(1). Some options may introduce additional complexity.
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the connection was successfully put in tracking mode or if the tracking mode was successfully disabled. Otherwise, an error is returned.
    @inlinable
    public func clientTracking(status: RESPCommand.CLIENTTRACKINGStatus, clientId: Int? = nil, prefixs: [String], bcast: Bool = false, optin: Bool = false, optout: Bool = false, noloop: Bool = false) async throws {
        try await send("CLIENT", "TRACKING", status, RESPWithToken("REDIRECT", clientId), RESPWithToken("PREFIX", prefixs), RedisPureToken("BCAST", bcast), RedisPureToken("OPTIN", optin), RedisPureToken("OPTOUT", optout), RedisPureToken("NOLOOP", noloop))
    }

    /// Returns information about server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKINGINFO](https:/redis.io/docs/latest/commands/client-trackinginfo)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Map](https:/redis.io/docs/reference/protocol-spec#maps): a list of tracking information sections and their respective values.
    @inlinable
    public func clientTrackinginfo() async throws -> RESPToken {
        try await send("CLIENT", "TRACKINGINFO")
    }

    /// Unblocks a client blocked by a blocking command from a different connection.
    ///
    /// - Documentation: [CLIENT UNBLOCK](https:/redis.io/docs/latest/commands/client-unblock)
    /// - Version: 5.0.0
    /// - Complexity: O(log N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the client was unblocked successfully.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the client wasn't unblocked.
    @inlinable
    public func clientUnblock(clientId: Int, unblockType: RESPCommand.CLIENTUNBLOCKUnblockType? = nil) async throws -> Int {
        try await send("CLIENT", "UNBLOCK", clientId, unblockType).converting()
    }

    /// Resumes processing commands from paused clients.
    ///
    /// - Documentation: [CLIENT UNPAUSE](https:/redis.io/docs/latest/commands/client-unpause)
    /// - Version: 6.2.0
    /// - Complexity: O(N) Where N is the number of paused clients
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func clientUnpause() async throws {
        try await send("CLIENT", "UNPAUSE")
    }

    /// Returns the given string.
    ///
    /// - Documentation: [ECHO](https:/redis.io/docs/latest/commands/echo)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the given string.
    @inlinable
    public func echo(message: String) async throws -> String {
        try await send("ECHO", message).converting()
    }

    /// Handshakes with the Redis server.
    ///
    /// - Documentation: [HELLO](https:/redis.io/docs/latest/commands/hello)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: [Map](https:/redis.io/docs/reference/protocol-spec#maps): a list of server properties.
    ///     [Simple error](https:/redis.io/docs/reference/protocol-spec#simple-errors): if the `protover` requested does not exist.
    @inlinable
    public func hello(arguments: RESPCommand.HELLOArguments? = nil) async throws -> RESPToken {
        try await send("HELLO", arguments)
    }

    /// Returns the server's liveliness response.
    ///
    /// - Documentation: [PING](https:/redis.io/docs/latest/commands/ping)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: Any of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `PONG` when no argument is provided.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the provided argument.
    @inlinable
    public func ping(message: String? = nil) async throws -> String {
        try await send("PING", message).converting()
    }

    /// Closes the connection.
    ///
    /// - Documentation: [QUIT](https:/redis.io/docs/latest/commands/quit)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func quit() async throws {
        try await send("QUIT")
    }

    /// Resets the connection.
    ///
    /// - Documentation: [RESET](https:/redis.io/docs/latest/commands/reset)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `RESET`.
    @inlinable
    public func reset() async throws -> String {
        try await send("RESET").converting()
    }

    /// Changes the selected database.
    ///
    /// - Documentation: [SELECT](https:/redis.io/docs/latest/commands/select)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func select(index: Int) async throws {
        try await send("SELECT", index)
    }

}
