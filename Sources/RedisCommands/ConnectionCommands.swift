//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2025 Apple Inc. and the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// A container for client connection commands.
public enum CLIENT {
    /// Instructs the server whether to track the keys in the next request.
    public struct CACHING: RedisCommand {
        public enum Mode: RESPRenderable {
            case yes
            case no

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = RESPToken

        public var mode: Mode

        @inlinable public init(mode: Mode) {
            self.mode = mode
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "CACHING", mode)
        }
    }

    /// Returns the name of the connection.
    public struct GETNAME: RedisCommand {
        public typealias Response = String?


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "GETNAME")
        }
    }

    /// Returns the client ID to which the connection's tracking notifications are redirected.
    public struct GETREDIR: RedisCommand {
        public typealias Response = Int


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "GETREDIR")
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: RedisCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "HELP")
        }
    }

    /// Returns the unique client ID of the connection.
    public struct ID: RedisCommand {
        public typealias Response = Int


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "ID")
        }
    }

    /// Returns information about the connection.
    public struct INFO: RedisCommand {
        public typealias Response = String


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "INFO")
        }
    }

    /// Terminates open connections.
    public struct KILL: RedisCommand {
        public enum FilterNewFormatClientType: RESPRenderable {
            case normal
            case master
            case slave
            case replica
            case pubsub

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .normal: "NORMAL".encode(into: &commandEncoder)
                case .master: "MASTER".encode(into: &commandEncoder)
                case .slave: "SLAVE".encode(into: &commandEncoder)
                case .replica: "REPLICA".encode(into: &commandEncoder)
                case .pubsub: "PUBSUB".encode(into: &commandEncoder)
                }
            }
        }
        public enum FilterNewFormatSkipme: RESPRenderable {
            case yes
            case no

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        public enum FilterNewFormat: RESPRenderable {
            case clientId(Int?)
            case clientType(FilterNewFormatClientType?)
            case username(String?)
            case addr(String?)
            case laddr(String?)
            case skipme(FilterNewFormatSkipme?)

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .clientId(let clientId): RESPWithToken("ID", clientId).encode(into: &commandEncoder)
                case .clientType(let clientType): RESPWithToken("TYPE", clientType).encode(into: &commandEncoder)
                case .username(let username): RESPWithToken("USER", username).encode(into: &commandEncoder)
                case .addr(let addr): RESPWithToken("ADDR", addr).encode(into: &commandEncoder)
                case .laddr(let laddr): RESPWithToken("LADDR", laddr).encode(into: &commandEncoder)
                case .skipme(let skipme): RESPWithToken("SKIPME", skipme).encode(into: &commandEncoder)
                }
            }
        }
        public enum Filter: RESPRenderable {
            case oldFormat(String)
            case newFormat([FilterNewFormat])

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .oldFormat(let oldFormat): oldFormat.encode(into: &commandEncoder)
                case .newFormat(let newFormat): newFormat.encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = Int?

        public var filter: Filter

        @inlinable public init(filter: Filter) {
            self.filter = filter
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "KILL", filter)
        }
    }

    /// Lists open connections.
    public struct LIST: RedisCommand {
        public enum ClientType: RESPRenderable {
            case normal
            case master
            case replica
            case pubsub

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .normal: "NORMAL".encode(into: &commandEncoder)
                case .master: "MASTER".encode(into: &commandEncoder)
                case .replica: "REPLICA".encode(into: &commandEncoder)
                case .pubsub: "PUBSUB".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = String

        public var clientType: ClientType? = nil
        public var clientId: [Int] = []

        @inlinable public init(clientType: ClientType? = nil, clientId: [Int] = []) {
            self.clientType = clientType
            self.clientId = clientId
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "LIST", RESPWithToken("TYPE", clientType), RESPWithToken("ID", clientId))
        }
    }

    /// Sets the client eviction mode of the connection.
    public struct NOEVICT: RedisCommand {
        public enum Enabled: RESPRenderable {
            case on
            case off

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = RESPToken

        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "NO-EVICT", enabled)
        }
    }

    /// Controls whether commands sent by the client affect the LRU/LFU of accessed keys.
    public struct NOTOUCH: RedisCommand {
        public enum Enabled: RESPRenderable {
            case on
            case off

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = RESPToken

        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "NO-TOUCH", enabled)
        }
    }

    /// Suspends commands processing.
    public struct PAUSE: RedisCommand {
        public enum Mode: RESPRenderable {
            case write
            case all

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .write: "WRITE".encode(into: &commandEncoder)
                case .all: "ALL".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = RESPToken

        public var timeout: Int
        public var mode: Mode? = nil

        @inlinable public init(timeout: Int, mode: Mode? = nil) {
            self.timeout = timeout
            self.mode = mode
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "PAUSE", timeout, mode)
        }
    }

    /// Instructs the server whether to reply to commands.
    public struct REPLY: RedisCommand {
        public enum Action: RESPRenderable {
            case on
            case off
            case skip

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                case .skip: "SKIP".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = RESPToken

        public var action: Action

        @inlinable public init(action: Action) {
            self.action = action
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "REPLY", action)
        }
    }

    /// Sets information specific to the client or connection.
    public struct SETINFO: RedisCommand {
        public enum Attr: RESPRenderable {
            case libname(String)
            case libver(String)

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .libname(let libname): RESPWithToken("LIB-NAME", libname).encode(into: &commandEncoder)
                case .libver(let libver): RESPWithToken("LIB-VER", libver).encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = RESPToken

        public var attr: Attr

        @inlinable public init(attr: Attr) {
            self.attr = attr
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "SETINFO", attr)
        }
    }

    /// Sets the connection name.
    public struct SETNAME: RedisCommand {
        public typealias Response = RESPToken

        public var connectionName: String

        @inlinable public init(connectionName: String) {
            self.connectionName = connectionName
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "SETNAME", connectionName)
        }
    }

    /// Controls server-assisted client-side caching for the connection.
    public struct TRACKING: RedisCommand {
        public enum Status: RESPRenderable {
            case on
            case off

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = RESPToken

        public var status: Status
        public var clientId: Int? = nil
        public var prefix: [String] = []
        public var bcast: Bool = false
        public var optin: Bool = false
        public var optout: Bool = false
        public var noloop: Bool = false

        @inlinable public init(status: Status, clientId: Int? = nil, prefix: [String] = [], bcast: Bool = false, optin: Bool = false, optout: Bool = false, noloop: Bool = false) {
            self.status = status
            self.clientId = clientId
            self.prefix = prefix
            self.bcast = bcast
            self.optin = optin
            self.optout = optout
            self.noloop = noloop
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "TRACKING", status, RESPWithToken("REDIRECT", clientId), RESPWithToken("PREFIX", prefix), RedisPureToken("BCAST", bcast), RedisPureToken("OPTIN", optin), RedisPureToken("OPTOUT", optout), RedisPureToken("NOLOOP", noloop))
        }
    }

    /// Returns information about server-assisted client-side caching for the connection.
    public struct TRACKINGINFO: RedisCommand {
        public typealias Response = [String: RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "TRACKINGINFO")
        }
    }

    /// Unblocks a client blocked by a blocking command from a different connection.
    public struct UNBLOCK: RedisCommand {
        public enum UnblockType: RESPRenderable {
            case timeout
            case error

            @inlinable
            public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
                switch self {
                case .timeout: "TIMEOUT".encode(into: &commandEncoder)
                case .error: "ERROR".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = Int

        public var clientId: Int
        public var unblockType: UnblockType? = nil

        @inlinable public init(clientId: Int, unblockType: UnblockType? = nil) {
            self.clientId = clientId
            self.unblockType = unblockType
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "UNBLOCK", clientId, unblockType)
        }
    }

    /// Resumes processing commands from paused clients.
    public struct UNPAUSE: RedisCommand {
        public typealias Response = RESPToken


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "UNPAUSE")
        }
    }

}

/// Authenticates the connection.
public struct AUTH: RedisCommand {
    public typealias Response = RESPToken

    public var username: String? = nil
    public var password: String

    @inlinable public init(username: String? = nil, password: String) {
        self.username = username
        self.password = password
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("AUTH", username, password)
    }
}

/// Returns the given string.
public struct ECHO: RedisCommand {
    public typealias Response = String

    public var message: String

    @inlinable public init(message: String) {
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("ECHO", message)
    }
}

/// Handshakes with the Redis server.
public struct HELLO: RedisCommand {
    public struct ArgumentsAuth: RESPRenderable {
        @usableFromInline let username: String
        @usableFromInline let password: String

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += username.encode(into: &commandEncoder)
            count += password.encode(into: &commandEncoder)
            return count
        }
    }
    public struct Arguments: RESPRenderable {
        @usableFromInline let protover: Int
        @usableFromInline let auth: ArgumentsAuth?
        @usableFromInline let clientname: String?

        @inlinable
        public func encode(into commandEncoder: inout RedisCommandEncoder) -> Int {
            var count = 0
            count += protover.encode(into: &commandEncoder)
            count += RESPWithToken("AUTH", auth).encode(into: &commandEncoder)
            count += RESPWithToken("SETNAME", clientname).encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = [String: RESPToken]

    public var arguments: Arguments? = nil

    @inlinable public init(arguments: Arguments? = nil) {
        self.arguments = arguments
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("HELLO", arguments)
    }
}

/// Returns the server's liveliness response.
public struct PING: RedisCommand {
    public typealias Response = String

    public var message: String? = nil

    @inlinable public init(message: String? = nil) {
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("PING", message)
    }
}

/// Closes the connection.
public struct QUIT: RedisCommand {
    public typealias Response = RESPToken


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("QUIT")
    }
}

/// Resets the connection.
public struct RESET: RedisCommand {
    public typealias Response = String


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("RESET")
    }
}

/// Changes the selected database.
public struct SELECT: RedisCommand {
    public typealias Response = RESPToken

    public var index: Int

    @inlinable public init(index: Int) {
        self.index = index
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("SELECT", index)
    }
}


extension RedisConnection {
    /// Authenticates the connection.
    ///
    /// - Documentation: [AUTH](https:/redis.io/docs/latest/commands/auth)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of passwords defined for the user
    /// - Categories: @fast, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`, or an error if the password, or username/password pair, is invalid.
    @inlinable
    public func auth(username: String? = nil, password: String) async throws -> RESPToken {
        try await send(command: AUTH(username: username, password: password))
    }

    /// Instructs the server whether to track the keys in the next request.
    ///
    /// - Documentation: [CLIENT CACHING](https:/redis.io/docs/latest/commands/client-caching)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` or an error if the argument is not "yes" or "no".
    @inlinable
    public func clientCaching(mode: CLIENT.CACHING.Mode) async throws -> RESPToken {
        try await send(command: CLIENT.CACHING(mode: mode))
    }

    /// Returns the name of the connection.
    ///
    /// - Documentation: [CLIENT GETNAME](https:/redis.io/docs/latest/commands/client-getname)
    /// - Version: 2.6.9
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the connection name of the current connection.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): the connection name was not set.
    @inlinable
    public func clientGetname() async throws -> String? {
        try await send(command: CLIENT.GETNAME())
    }

    /// Returns the client ID to which the connection's tracking notifications are redirected.
    ///
    /// - Documentation: [CLIENT GETREDIR](https:/redis.io/docs/latest/commands/client-getredir)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` when not redirecting notifications to any client.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if client tracking is not enabled.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the ID of the client to which notification are being redirected.
    @inlinable
    public func clientGetredir() async throws -> Int {
        try await send(command: CLIENT.GETREDIR())
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [CLIENT HELP](https:/redis.io/docs/latest/commands/client-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of subcommands and their descriptions.
    @inlinable
    public func clientHelp() async throws -> [RESPToken] {
        try await send(command: CLIENT.HELP())
    }

    /// Returns the unique client ID of the connection.
    ///
    /// - Documentation: [CLIENT ID](https:/redis.io/docs/latest/commands/client-id)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the ID of the client.
    @inlinable
    public func clientId() async throws -> Int {
        try await send(command: CLIENT.ID())
    }

    /// Returns information about the connection.
    ///
    /// - Documentation: [CLIENT INFO](https:/redis.io/docs/latest/commands/client-info)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): a unique string for the current client, as described at the `CLIENT LIST` page.
    @inlinable
    public func clientInfo() async throws -> String {
        try await send(command: CLIENT.INFO())
    }

    /// Terminates open connections.
    ///
    /// - Documentation: [CLIENT KILL](https:/redis.io/docs/latest/commands/client-kill)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: One of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` when called in 3 argument format and the connection has been closed.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): when called in filter/value format, the number of clients killed.
    @inlinable
    public func clientKill(filter: CLIENT.KILL.Filter) async throws -> Int? {
        try await send(command: CLIENT.KILL(filter: filter))
    }

    /// Lists open connections.
    ///
    /// - Documentation: [CLIENT LIST](https:/redis.io/docs/latest/commands/client-list)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): information and statistics about client connections.
    @inlinable
    public func clientList(clientType: CLIENT.LIST.ClientType? = nil, clientId: [Int] = []) async throws -> String {
        try await send(command: CLIENT.LIST(clientType: clientType, clientId: clientId))
    }

    /// Sets the client eviction mode of the connection.
    ///
    /// - Documentation: [CLIENT NO-EVICT](https:/redis.io/docs/latest/commands/client-no-evict)
    /// - Version: 7.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func clientNoEvict(enabled: CLIENT.NOEVICT.Enabled) async throws -> RESPToken {
        try await send(command: CLIENT.NOEVICT(enabled: enabled))
    }

    /// Controls whether commands sent by the client affect the LRU/LFU of accessed keys.
    ///
    /// - Documentation: [CLIENT NO-TOUCH](https:/redis.io/docs/latest/commands/client-no-touch)
    /// - Version: 7.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func clientNoTouch(enabled: CLIENT.NOTOUCH.Enabled) async throws -> RESPToken {
        try await send(command: CLIENT.NOTOUCH(enabled: enabled))
    }

    /// Suspends commands processing.
    ///
    /// - Documentation: [CLIENT PAUSE](https:/redis.io/docs/latest/commands/client-pause)
    /// - Version: 3.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` or an error if the timeout is invalid.
    @inlinable
    public func clientPause(timeout: Int, mode: CLIENT.PAUSE.Mode? = nil) async throws -> RESPToken {
        try await send(command: CLIENT.PAUSE(timeout: timeout, mode: mode))
    }

    /// Instructs the server whether to reply to commands.
    ///
    /// - Documentation: [CLIENT REPLY](https:/redis.io/docs/latest/commands/client-reply)
    /// - Version: 3.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` when called with `ON`. When called with either `OFF` or `SKIP` sub-commands, no reply is made.
    @inlinable
    public func clientReply(action: CLIENT.REPLY.Action) async throws -> RESPToken {
        try await send(command: CLIENT.REPLY(action: action))
    }

    /// Sets information specific to the client or connection.
    ///
    /// - Documentation: [CLIENT SETINFO](https:/redis.io/docs/latest/commands/client-setinfo)
    /// - Version: 7.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the attribute name was successfully set.
    @inlinable
    public func clientSetinfo(attr: CLIENT.SETINFO.Attr) async throws -> RESPToken {
        try await send(command: CLIENT.SETINFO(attr: attr))
    }

    /// Sets the connection name.
    ///
    /// - Documentation: [CLIENT SETNAME](https:/redis.io/docs/latest/commands/client-setname)
    /// - Version: 2.6.9
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the connection name was successfully set.
    @inlinable
    public func clientSetname(connectionName: String) async throws -> RESPToken {
        try await send(command: CLIENT.SETNAME(connectionName: connectionName))
    }

    /// Controls server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKING](https:/redis.io/docs/latest/commands/client-tracking)
    /// - Version: 6.0.0
    /// - Complexity: O(1). Some options may introduce additional complexity.
    /// - Categories: @slow, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the connection was successfully put in tracking mode or if the tracking mode was successfully disabled. Otherwise, an error is returned.
    @inlinable
    public func clientTracking(status: CLIENT.TRACKING.Status, clientId: Int? = nil, prefix: [String] = [], bcast: Bool = false, optin: Bool = false, optout: Bool = false, noloop: Bool = false) async throws -> RESPToken {
        try await send(command: CLIENT.TRACKING(status: status, clientId: clientId, prefix: prefix, bcast: bcast, optin: optin, optout: optout, noloop: noloop))
    }

    /// Returns information about server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKINGINFO](https:/redis.io/docs/latest/commands/client-trackinginfo)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Map](https:/redis.io/docs/reference/protocol-spec#maps): a list of tracking information sections and their respective values.
    @inlinable
    public func clientTrackinginfo() async throws -> [String: RESPToken] {
        try await send(command: CLIENT.TRACKINGINFO())
    }

    /// Unblocks a client blocked by a blocking command from a different connection.
    ///
    /// - Documentation: [CLIENT UNBLOCK](https:/redis.io/docs/latest/commands/client-unblock)
    /// - Version: 5.0.0
    /// - Complexity: O(log N) where N is the number of client connections
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the client was unblocked successfully.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the client wasn't unblocked.
    @inlinable
    public func clientUnblock(clientId: Int, unblockType: CLIENT.UNBLOCK.UnblockType? = nil) async throws -> Int {
        try await send(command: CLIENT.UNBLOCK(clientId: clientId, unblockType: unblockType))
    }

    /// Resumes processing commands from paused clients.
    ///
    /// - Documentation: [CLIENT UNPAUSE](https:/redis.io/docs/latest/commands/client-unpause)
    /// - Version: 6.2.0
    /// - Complexity: O(N) Where N is the number of paused clients
    /// - Categories: @admin, @slow, @dangerous, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func clientUnpause() async throws -> RESPToken {
        try await send(command: CLIENT.UNPAUSE())
    }

    /// Returns the given string.
    ///
    /// - Documentation: [ECHO](https:/redis.io/docs/latest/commands/echo)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the given string.
    @inlinable
    public func echo(message: String) async throws -> String {
        try await send(command: ECHO(message: message))
    }

    /// Handshakes with the Redis server.
    ///
    /// - Documentation: [HELLO](https:/redis.io/docs/latest/commands/hello)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: [Map](https:/redis.io/docs/reference/protocol-spec#maps): a list of server properties.
    ///     [Simple error](https:/redis.io/docs/reference/protocol-spec#simple-errors): if the `protover` requested does not exist.
    @inlinable
    public func hello(arguments: HELLO.Arguments? = nil) async throws -> [String: RESPToken] {
        try await send(command: HELLO(arguments: arguments))
    }

    /// Returns the server's liveliness response.
    ///
    /// - Documentation: [PING](https:/redis.io/docs/latest/commands/ping)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: Any of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `PONG` when no argument is provided.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the provided argument.
    @inlinable
    public func ping(message: String? = nil) async throws -> String {
        try await send(command: PING(message: message))
    }

    /// Closes the connection.
    ///
    /// - Documentation: [QUIT](https:/redis.io/docs/latest/commands/quit)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func quit() async throws -> RESPToken {
        try await send(command: QUIT())
    }

    /// Resets the connection.
    ///
    /// - Documentation: [RESET](https:/redis.io/docs/latest/commands/reset)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `RESET`.
    @inlinable
    public func reset() async throws -> String {
        try await send(command: RESET())
    }

    /// Changes the selected database.
    ///
    /// - Documentation: [SELECT](https:/redis.io/docs/latest/commands/select)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @fast, @connection
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func select(index: Int) async throws -> RESPToken {
        try await send(command: SELECT(index: index))
    }

}
