//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2025 the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// A container for Pub/Sub commands.
public enum PUBSUB {
    /// Returns the active channels.
    public struct CHANNELS: RedisCommand {
        public typealias Response = [RESPToken]

        public var pattern: String? = nil

        @inlinable public init(pattern: String? = nil) {
            self.pattern = pattern
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "CHANNELS", pattern)
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: RedisCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "HELP")
        }
    }

    /// Returns a count of unique pattern subscriptions.
    public struct NUMPAT: RedisCommand {
        public typealias Response = Int


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "NUMPAT")
        }
    }

    /// Returns a count of subscribers to channels.
    public struct NUMSUB: RedisCommand {
        public typealias Response = [RESPToken]

        public var channel: [String] = []

        @inlinable public init(channel: [String] = []) {
            self.channel = channel
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "NUMSUB", channel)
        }
    }

    /// Returns the active shard channels.
    public struct SHARDCHANNELS: RedisCommand {
        public typealias Response = [RESPToken]

        public var pattern: String? = nil

        @inlinable public init(pattern: String? = nil) {
            self.pattern = pattern
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "SHARDCHANNELS", pattern)
        }
    }

    /// Returns the count of subscribers of shard channels.
    public struct SHARDNUMSUB: RedisCommand {
        public typealias Response = [RESPToken]

        public var shardchannel: [String] = []

        @inlinable public init(shardchannel: [String] = []) {
            self.shardchannel = shardchannel
        }

        @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "SHARDNUMSUB", shardchannel)
        }
    }

}

/// Listens for messages published to channels that match one or more patterns.
public struct PSUBSCRIBE: RedisCommand {
    public typealias Response = RESPToken

    public var pattern: [String]

    @inlinable public init(pattern: [String]) {
        self.pattern = pattern
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("PSUBSCRIBE", pattern)
    }
}

/// Posts a message to a channel.
public struct PUBLISH: RedisCommand {
    public typealias Response = Int

    public var channel: String
    public var message: String

    @inlinable public init(channel: String, message: String) {
        self.channel = channel
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("PUBLISH", channel, message)
    }
}

/// Stops listening to messages published to channels that match one or more patterns.
public struct PUNSUBSCRIBE: RedisCommand {
    public typealias Response = RESPToken

    public var pattern: [String] = []

    @inlinable public init(pattern: [String] = []) {
        self.pattern = pattern
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("PUNSUBSCRIBE", pattern)
    }
}

/// Post a message to a shard channel
public struct SPUBLISH: RedisCommand {
    public typealias Response = Int

    public var shardchannel: String
    public var message: String

    @inlinable public init(shardchannel: String, message: String) {
        self.shardchannel = shardchannel
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("SPUBLISH", shardchannel, message)
    }
}

/// Listens for messages published to shard channels.
public struct SSUBSCRIBE: RedisCommand {
    public typealias Response = RESPToken

    public var shardchannel: [String]

    @inlinable public init(shardchannel: [String]) {
        self.shardchannel = shardchannel
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("SSUBSCRIBE", shardchannel)
    }
}

/// Listens for messages published to channels.
public struct SUBSCRIBE: RedisCommand {
    public typealias Response = RESPToken

    public var channel: [String]

    @inlinable public init(channel: [String]) {
        self.channel = channel
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("SUBSCRIBE", channel)
    }
}

/// Stops listening to messages posted to shard channels.
public struct SUNSUBSCRIBE: RedisCommand {
    public typealias Response = RESPToken

    public var shardchannel: [String] = []

    @inlinable public init(shardchannel: [String] = []) {
        self.shardchannel = shardchannel
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("SUNSUBSCRIBE", shardchannel)
    }
}

/// Stops listening to messages posted to channels.
public struct UNSUBSCRIBE: RedisCommand {
    public typealias Response = RESPToken

    public var channel: [String] = []

    @inlinable public init(channel: [String] = []) {
        self.channel = channel
    }

    @inlinable public func encode(into commandEncoder: inout RedisCommandEncoder) {
        commandEncoder.encodeArray("UNSUBSCRIBE", channel)
    }
}


extension RedisConnection {
    /// Listens for messages published to channels that match one or more patterns.
    ///
    /// - Documentation: [PSUBSCRIBE](https:/redis.io/docs/latest/commands/psubscribe)
    /// - Version: 2.0.0
    /// - Complexity: O(N) where N is the number of patterns to subscribe to.
    /// - Categories: @pubsub, @slow
    /// - Returns: When successful, this command doesn't return anything. Instead, for each pattern, one message with the first element being the string `psubscribe` is pushed as a confirmation that the command succeeded.
    @inlinable
    public func psubscribe(pattern: [String]) async throws -> RESPToken {
        try await send(command: PSUBSCRIBE(pattern: pattern))
    }

    /// Posts a message to a channel.
    ///
    /// - Documentation: [PUBLISH](https:/redis.io/docs/latest/commands/publish)
    /// - Version: 2.0.0
    /// - Complexity: O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).
    /// - Categories: @pubsub, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of clients that received the message. Note that in a Redis Cluster, only clients that are connected to the same node as the publishing client are included in the count.
    @inlinable
    public func publish(channel: String, message: String) async throws -> Int {
        try await send(command: PUBLISH(channel: channel, message: message))
    }

    /// Returns the active channels.
    ///
    /// - Documentation: [PUBSUB CHANNELS](https:/redis.io/docs/latest/commands/pubsub-channels)
    /// - Version: 2.8.0
    /// - Complexity: O(N) where N is the number of active channels, and assuming constant time pattern matching (relatively short channels and patterns)
    /// - Categories: @pubsub, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of active channels, optionally matching the specified pattern.
    @inlinable
    public func pubsubChannels(pattern: String? = nil) async throws -> [RESPToken] {
        try await send(command: PUBSUB.CHANNELS(pattern: pattern))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [PUBSUB HELP](https:/redis.io/docs/latest/commands/pubsub-help)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func pubsubHelp() async throws -> [RESPToken] {
        try await send(command: PUBSUB.HELP())
    }

    /// Returns a count of unique pattern subscriptions.
    ///
    /// - Documentation: [PUBSUB NUMPAT](https:/redis.io/docs/latest/commands/pubsub-numpat)
    /// - Version: 2.8.0
    /// - Complexity: O(1)
    /// - Categories: @pubsub, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of patterns all the clients are subscribed to.
    @inlinable
    public func pubsubNumpat() async throws -> Int {
        try await send(command: PUBSUB.NUMPAT())
    }

    /// Returns a count of subscribers to channels.
    ///
    /// - Documentation: [PUBSUB NUMSUB](https:/redis.io/docs/latest/commands/pubsub-numsub)
    /// - Version: 2.8.0
    /// - Complexity: O(N) for the NUMSUB subcommand, where N is the number of requested channels
    /// - Categories: @pubsub, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): the number of subscribers per channel, each even element (including the 0th) is channel name, each odd element is the number of subscribers
    @inlinable
    public func pubsubNumsub(channel: [String] = []) async throws -> [RESPToken] {
        try await send(command: PUBSUB.NUMSUB(channel: channel))
    }

    /// Returns the active shard channels.
    ///
    /// - Documentation: [PUBSUB SHARDCHANNELS](https:/redis.io/docs/latest/commands/pubsub-shardchannels)
    /// - Version: 7.0.0
    /// - Complexity: O(N) where N is the number of active shard channels, and assuming constant time pattern matching (relatively short shard channels).
    /// - Categories: @pubsub, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of active channels, optionally matching the specified pattern.
    @inlinable
    public func pubsubShardchannels(pattern: String? = nil) async throws -> [RESPToken] {
        try await send(command: PUBSUB.SHARDCHANNELS(pattern: pattern))
    }

    /// Returns the count of subscribers of shard channels.
    ///
    /// - Documentation: [PUBSUB SHARDNUMSUB](https:/redis.io/docs/latest/commands/pubsub-shardnumsub)
    /// - Version: 7.0.0
    /// - Complexity: O(N) for the SHARDNUMSUB subcommand, where N is the number of requested shard channels
    /// - Categories: @pubsub, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): the number of subscribers per shard channel, each even element (including the 0th) is channel name, each odd element is the number of subscribers.
    @inlinable
    public func pubsubShardnumsub(shardchannel: [String] = []) async throws -> [RESPToken] {
        try await send(command: PUBSUB.SHARDNUMSUB(shardchannel: shardchannel))
    }

    /// Stops listening to messages published to channels that match one or more patterns.
    ///
    /// - Documentation: [PUNSUBSCRIBE](https:/redis.io/docs/latest/commands/punsubscribe)
    /// - Version: 2.0.0
    /// - Complexity: O(N) where N is the number of patterns to unsubscribe.
    /// - Categories: @pubsub, @slow
    /// - Returns: When successful, this command doesn't return anything. Instead, for each pattern, one message with the first element being the string `punsubscribe` is pushed as a confirmation that the command succeeded.
    @inlinable
    public func punsubscribe(pattern: [String] = []) async throws -> RESPToken {
        try await send(command: PUNSUBSCRIBE(pattern: pattern))
    }

    /// Post a message to a shard channel
    ///
    /// - Documentation: [SPUBLISH](https:/redis.io/docs/latest/commands/spublish)
    /// - Version: 7.0.0
    /// - Complexity: O(N) where N is the number of clients subscribed to the receiving shard channel.
    /// - Categories: @pubsub, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of clients that received the message. Note that in a Redis Cluster, only clients that are connected to the same node as the publishing client are included in the count
    @inlinable
    public func spublish(shardchannel: String, message: String) async throws -> Int {
        try await send(command: SPUBLISH(shardchannel: shardchannel, message: message))
    }

    /// Listens for messages published to shard channels.
    ///
    /// - Documentation: [SSUBSCRIBE](https:/redis.io/docs/latest/commands/ssubscribe)
    /// - Version: 7.0.0
    /// - Complexity: O(N) where N is the number of shard channels to subscribe to.
    /// - Categories: @pubsub, @slow
    /// - Returns: When successful, this command doesn't return anything. Instead, for each shard channel, one message with the first element being the string 'ssubscribe' is pushed as a confirmation that the command succeeded. Note that this command can also return a -MOVED redirect.
    @inlinable
    public func ssubscribe(shardchannel: [String]) async throws -> RESPToken {
        try await send(command: SSUBSCRIBE(shardchannel: shardchannel))
    }

    /// Listens for messages published to channels.
    ///
    /// - Documentation: [SUBSCRIBE](https:/redis.io/docs/latest/commands/subscribe)
    /// - Version: 2.0.0
    /// - Complexity: O(N) where N is the number of channels to subscribe to.
    /// - Categories: @pubsub, @slow
    /// - Returns: When successful, this command doesn't return anything. Instead, for each channel, one message with the first element being the string `subscribe` is pushed as a confirmation that the command succeeded.
    @inlinable
    public func subscribe(channel: [String]) async throws -> RESPToken {
        try await send(command: SUBSCRIBE(channel: channel))
    }

    /// Stops listening to messages posted to shard channels.
    ///
    /// - Documentation: [SUNSUBSCRIBE](https:/redis.io/docs/latest/commands/sunsubscribe)
    /// - Version: 7.0.0
    /// - Complexity: O(N) where N is the number of shard channels to unsubscribe.
    /// - Categories: @pubsub, @slow
    /// - Returns: When successful, this command doesn't return anything. Instead, for each shard channel, one message with the first element being the string `sunsubscribe` is pushed as a confirmation that the command succeeded.
    @inlinable
    public func sunsubscribe(shardchannel: [String] = []) async throws -> RESPToken {
        try await send(command: SUNSUBSCRIBE(shardchannel: shardchannel))
    }

    /// Stops listening to messages posted to channels.
    ///
    /// - Documentation: [UNSUBSCRIBE](https:/redis.io/docs/latest/commands/unsubscribe)
    /// - Version: 2.0.0
    /// - Complexity: O(N) where N is the number of channels to unsubscribe.
    /// - Categories: @pubsub, @slow
    /// - Returns: When successful, this command doesn't return anything. Instead, for each channel, one message with the first element being the string `unsubscribe` is pushed as a confirmation that the command succeeded.
    @inlinable
    public func unsubscribe(channel: [String] = []) async throws -> RESPToken {
        try await send(command: UNSUBSCRIBE(channel: channel))
    }

}
