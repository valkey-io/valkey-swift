//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2023 Apple Inc. and the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import RESP
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension RESPCommand {
    /// Returns the number of messages that were successfully acknowledged by the consumer group member of a stream.
    ///
    /// - Documentation: [XACK](https:/redis.io/docs/latest/commands/xack)
    /// - Version: 5.0.0
    /// - Complexity: O(1) for each message ID processed.
    /// - Categories: @write, @stream, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have already been acknowledged), and XACK will not count them as successfully acknowledged.
    @inlinable
    public static func xack(key: RedisKey, group: String, id: String) -> RESPCommand {
        RESPCommand("XACK", key, group, id)
    }

    /// Returns the number of messages that were successfully acknowledged by the consumer group member of a stream.
    ///
    /// - Documentation: [XACK](https:/redis.io/docs/latest/commands/xack)
    /// - Version: 5.0.0
    /// - Complexity: O(1) for each message ID processed.
    /// - Categories: @write, @stream, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have already been acknowledged), and XACK will not count them as successfully acknowledged.
    @inlinable
    public static func xack(key: RedisKey, group: String, ids: [String]) -> RESPCommand {
        RESPCommand("XACK", key, group, ids)
    }

    public enum XADDTrimStrategy: RESPRenderable {
        case maxlen
        case minid

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .maxlen: "MAXLEN".writeToRESPBuffer(&buffer)
            case .minid: "MINID".writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum XADDTrimOperator: RESPRenderable {
        case equal
        case approximately

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .equal: "=".writeToRESPBuffer(&buffer)
            case .approximately: "~".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct XADDTrim: RESPRenderable {
        @usableFromInline let strategy: XADDTrimStrategy
        @usableFromInline let `operator`: XADDTrimOperator?
        @usableFromInline let threshold: String
        @usableFromInline let count: Int?

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += strategy.writeToRESPBuffer(&buffer)
            count += `operator`.writeToRESPBuffer(&buffer)
            count += threshold.writeToRESPBuffer(&buffer)
            count += RESPWithToken("LIMIT", count).writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum XADDIdSelector: RESPRenderable {
        case autoId
        case id(String)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .autoId: "*".writeToRESPBuffer(&buffer)
            case .id(let id): id.writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct XADDData: RESPRenderable {
        @usableFromInline let field: String
        @usableFromInline let value: String

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += field.writeToRESPBuffer(&buffer)
            count += value.writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Appends a new message to a stream. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [XADD](https:/redis.io/docs/latest/commands/xadd)
    /// - Version: 5.0.0
    /// - Complexity: O(1) when adding a new entry, O(N) when trimming where N being the number of entries evicted.
    /// - Categories: @write, @stream, @fast
    /// - Response: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): The ID of the added entry. The ID is the one automatically generated if an asterisk (`*`) is passed as the _id_ argument, otherwise the command just returns the same ID specified by the user during insertion.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the NOMKSTREAM option is given and the key doesn't exist.
    @inlinable
    public static func xadd(key: RedisKey, nomkstream: Bool = false, trim: XADDTrim? = nil, idSelector: XADDIdSelector, data: XADDData) -> RESPCommand {
        RESPCommand("XADD", key, RedisPureToken("NOMKSTREAM", nomkstream), trim, idSelector, data)
    }

    /// Appends a new message to a stream. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [XADD](https:/redis.io/docs/latest/commands/xadd)
    /// - Version: 5.0.0
    /// - Complexity: O(1) when adding a new entry, O(N) when trimming where N being the number of entries evicted.
    /// - Categories: @write, @stream, @fast
    /// - Response: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): The ID of the added entry. The ID is the one automatically generated if an asterisk (`*`) is passed as the _id_ argument, otherwise the command just returns the same ID specified by the user during insertion.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the NOMKSTREAM option is given and the key doesn't exist.
    @inlinable
    public static func xadd(key: RedisKey, nomkstream: Bool = false, trim: XADDTrim? = nil, idSelector: XADDIdSelector, datas: [XADDData]) -> RESPCommand {
        RESPCommand("XADD", key, RedisPureToken("NOMKSTREAM", nomkstream), trim, idSelector, datas)
    }

    /// Changes, or acquires, ownership of messages in a consumer group, as if the messages were delivered to as consumer group member.
    ///
    /// - Documentation: [XAUTOCLAIM](https:/redis.io/docs/latest/commands/xautoclaim)
    /// - Version: 6.2.0
    /// - Complexity: O(1) if COUNT is small.
    /// - Categories: @write, @stream, @fast
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays), specifically, an array with three elements:
    ///     1. A stream ID to be used as the _start_ argument for the next call to XAUTOCLAIM.
    ///     2. An [Array](https:/redis.io/docs/reference/protocol-spec#arrays) containing all the successfully claimed messages in the same format as `XRANGE`.
    ///     3. An [Array](https:/redis.io/docs/reference/protocol-spec#arrays) containing message IDs that no longer exist in the stream, and were deleted from the PEL in which they were found.
    @inlinable
    public static func xautoclaim(key: RedisKey, group: String, consumer: String, minIdleTime: String, start: String, count: Int? = nil, justid: Bool = false) -> RESPCommand {
        RESPCommand("XAUTOCLAIM", key, group, consumer, minIdleTime, start, RESPWithToken("COUNT", count), RedisPureToken("JUSTID", justid))
    }

    /// Changes, or acquires, ownership of a message in a consumer group, as if the message was delivered a consumer group member.
    ///
    /// - Documentation: [XCLAIM](https:/redis.io/docs/latest/commands/xclaim)
    /// - Version: 5.0.0
    /// - Complexity: O(log N) with N being the number of messages in the PEL of the consumer group.
    /// - Categories: @write, @stream, @fast
    /// - Response: Any of the following:
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): when the _JUSTID_ option is specified, an array of IDs of messages successfully claimed.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): an array of stream entries, each of which contains an array of two elements, the entry ID and the entry data itself.
    @inlinable
    public static func xclaim(key: RedisKey, group: String, consumer: String, minIdleTime: String, id: String, ms: Int? = nil, unixTimeMilliseconds: Date? = nil, count: Int? = nil, force: Bool = false, justid: Bool = false, lastid: String? = nil) -> RESPCommand {
        RESPCommand("XCLAIM", key, group, consumer, minIdleTime, id, RESPWithToken("IDLE", ms), RESPWithToken("TIME", unixTimeMilliseconds.map { Int($0.timeIntervalSince1970 * 1000) }), RESPWithToken("RETRYCOUNT", count), RedisPureToken("FORCE", force), RedisPureToken("JUSTID", justid), RESPWithToken("LASTID", lastid))
    }

    /// Changes, or acquires, ownership of a message in a consumer group, as if the message was delivered a consumer group member.
    ///
    /// - Documentation: [XCLAIM](https:/redis.io/docs/latest/commands/xclaim)
    /// - Version: 5.0.0
    /// - Complexity: O(log N) with N being the number of messages in the PEL of the consumer group.
    /// - Categories: @write, @stream, @fast
    /// - Response: Any of the following:
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): when the _JUSTID_ option is specified, an array of IDs of messages successfully claimed.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): an array of stream entries, each of which contains an array of two elements, the entry ID and the entry data itself.
    @inlinable
    public static func xclaim(key: RedisKey, group: String, consumer: String, minIdleTime: String, ids: [String], ms: Int? = nil, unixTimeMilliseconds: Date? = nil, count: Int? = nil, force: Bool = false, justid: Bool = false, lastid: String? = nil) -> RESPCommand {
        RESPCommand("XCLAIM", key, group, consumer, minIdleTime, ids, RESPWithToken("IDLE", ms), RESPWithToken("TIME", unixTimeMilliseconds.map { Int($0.timeIntervalSince1970 * 1000) }), RESPWithToken("RETRYCOUNT", count), RedisPureToken("FORCE", force), RedisPureToken("JUSTID", justid), RESPWithToken("LASTID", lastid))
    }

    /// Returns the number of messages after removing them from a stream.
    ///
    /// - Documentation: [XDEL](https:/redis.io/docs/latest/commands/xdel)
    /// - Version: 5.0.0
    /// - Complexity: O(1) for each single item to delete in the stream, regardless of the stream size.
    /// - Categories: @write, @stream, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of entries that were deleted.
    @inlinable
    public static func xdel(key: RedisKey, id: String) -> RESPCommand {
        RESPCommand("XDEL", key, id)
    }

    /// Returns the number of messages after removing them from a stream.
    ///
    /// - Documentation: [XDEL](https:/redis.io/docs/latest/commands/xdel)
    /// - Version: 5.0.0
    /// - Complexity: O(1) for each single item to delete in the stream, regardless of the stream size.
    /// - Categories: @write, @stream, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of entries that were deleted.
    @inlinable
    public static func xdel(key: RedisKey, ids: [String]) -> RESPCommand {
        RESPCommand("XDEL", key, ids)
    }

    public enum XGROUPCREATEIdSelector: RESPRenderable {
        case id(String)
        case newId

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .id(let id): id.writeToRESPBuffer(&buffer)
            case .newId: "$".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Creates a consumer group.
    ///
    /// - Documentation: [XGROUP CREATE](https:/redis.io/docs/latest/commands/xgroup-create)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func xgroupCreate(key: RedisKey, group: String, idSelector: XGROUPCREATEIdSelector, mkstream: Bool = false, entriesRead: Int? = nil) -> RESPCommand {
        RESPCommand("XGROUP", "CREATE", key, group, idSelector, RedisPureToken("MKSTREAM", mkstream), RESPWithToken("ENTRIESREAD", entriesRead))
    }

    /// Creates a consumer in a consumer group.
    ///
    /// - Documentation: [XGROUP CREATECONSUMER](https:/redis.io/docs/latest/commands/xgroup-createconsumer)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of created consumers, either 0 or 1.
    @inlinable
    public static func xgroupCreateconsumer(key: RedisKey, group: String, consumer: String) -> RESPCommand {
        RESPCommand("XGROUP", "CREATECONSUMER", key, group, consumer)
    }

    /// Deletes a consumer from a consumer group.
    ///
    /// - Documentation: [XGROUP DELCONSUMER](https:/redis.io/docs/latest/commands/xgroup-delconsumer)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of pending messages the consumer had before it was deleted.
    @inlinable
    public static func xgroupDelconsumer(key: RedisKey, group: String, consumer: String) -> RESPCommand {
        RESPCommand("XGROUP", "DELCONSUMER", key, group, consumer)
    }

    /// Destroys a consumer group.
    ///
    /// - Documentation: [XGROUP DESTROY](https:/redis.io/docs/latest/commands/xgroup-destroy)
    /// - Version: 5.0.0
    /// - Complexity: O(N) where N is the number of entries in the group's pending entries list (PEL).
    /// - Categories: @write, @stream, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of destroyed consumer groups, either 0 or 1.
    @inlinable
    public static func xgroupDestroy(key: RedisKey, group: String) -> RESPCommand {
        RESPCommand("XGROUP", "DESTROY", key, group)
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [XGROUP HELP](https:/redis.io/docs/latest/commands/xgroup-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @stream, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public static func xgroupHelp() -> RESPCommand {
        RESPCommand("XGROUP", "HELP")
    }

    public enum XGROUPSETIDIdSelector: RESPRenderable {
        case id(String)
        case newId

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .id(let id): id.writeToRESPBuffer(&buffer)
            case .newId: "$".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Sets the last-delivered ID of a consumer group.
    ///
    /// - Documentation: [XGROUP SETID](https:/redis.io/docs/latest/commands/xgroup-setid)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func xgroupSetid(key: RedisKey, group: String, idSelector: XGROUPSETIDIdSelector, entriesread: Int? = nil) -> RESPCommand {
        RESPCommand("XGROUP", "SETID", key, group, idSelector, RESPWithToken("ENTRIESREAD", entriesread))
    }

    /// Returns a list of the consumers in a consumer group.
    ///
    /// - Documentation: [XINFO CONSUMERS](https:/redis.io/docs/latest/commands/xinfo-consumers)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of consumers and their attributes.
    @inlinable
    public static func xinfoConsumers(key: RedisKey, group: String) -> RESPCommand {
        RESPCommand("XINFO", "CONSUMERS", key, group)
    }

    /// Returns a list of the consumer groups of a stream.
    ///
    /// - Documentation: [XINFO GROUPS](https:/redis.io/docs/latest/commands/xinfo-groups)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of consumer groups.
    @inlinable
    public static func xinfoGroups(key: RedisKey) -> RESPCommand {
        RESPCommand("XINFO", "GROUPS", key)
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [XINFO HELP](https:/redis.io/docs/latest/commands/xinfo-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @stream, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public static func xinfoHelp() -> RESPCommand {
        RESPCommand("XINFO", "HELP")
    }

    public struct XINFOSTREAMFullBlock: RESPRenderable {
        @usableFromInline let full: Bool
        @usableFromInline let count: Int?

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            if self.full { count += "FULL".writeToRESPBuffer(&buffer) }
            count += RESPWithToken("COUNT", count).writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Returns information about a stream.
    ///
    /// - Documentation: [XINFO STREAM](https:/redis.io/docs/latest/commands/xinfo-stream)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @slow
    /// - Response: One of the following:
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): when the _FULL_ argument was not given, a list of information about a stream in summary form.
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): when the _FULL_ argument was given, a list of information about a stream in extended form.
    @inlinable
    public static func xinfoStream(key: RedisKey, fullBlock: XINFOSTREAMFullBlock? = nil) -> RESPCommand {
        RESPCommand("XINFO", "STREAM", key, fullBlock)
    }

    /// Return the number of messages in a stream.
    ///
    /// - Documentation: [XLEN](https:/redis.io/docs/latest/commands/xlen)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of entries of the stream at _key_.
    @inlinable
    public static func xlen(key: RedisKey) -> RESPCommand {
        RESPCommand("XLEN", key)
    }

    public struct XPENDINGFilters: RESPRenderable {
        @usableFromInline let minIdleTime: Int?
        @usableFromInline let start: String
        @usableFromInline let end: String
        @usableFromInline let count: Int
        @usableFromInline let consumer: String?

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("IDLE", minIdleTime).writeToRESPBuffer(&buffer)
            count += start.writeToRESPBuffer(&buffer)
            count += end.writeToRESPBuffer(&buffer)
            count += count.writeToRESPBuffer(&buffer)
            count += consumer.writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Returns the information and entries from a stream consumer group's pending entries list.
    ///
    /// - Documentation: [XPENDING](https:/redis.io/docs/latest/commands/xpending)
    /// - Version: 5.0.0
    /// - Complexity: O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). O(M), where M is the total number of entries scanned when used with the IDLE filter. When the command returns just the summary and the list of consumers is small, it runs in O(1) time; otherwise, an additional O(N) time for iterating every consumer.
    /// - Categories: @read, @stream, @slow
    /// - Response: * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): different data depending on the way XPENDING is called, as explained on this page.
    @inlinable
    public static func xpending(key: RedisKey, group: String, filters: XPENDINGFilters? = nil) -> RESPCommand {
        RESPCommand("XPENDING", key, group, filters)
    }

    /// Returns the messages from a stream within a range of IDs.
    ///
    /// - Documentation: [XRANGE](https:/redis.io/docs/latest/commands/xrange)
    /// - Version: 5.0.0
    /// - Complexity: O(N) with N being the number of elements being returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
    /// - Categories: @read, @stream, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of stream entries with IDs matching the specified range.
    @inlinable
    public static func xrange(key: RedisKey, start: String, end: String, count: Int? = nil) -> RESPCommand {
        RESPCommand("XRANGE", key, start, end, RESPWithToken("COUNT", count))
    }

    public struct XREADStreams: RESPRenderable {
        @usableFromInline let key: [RedisKey]
        @usableFromInline let id: [String]

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += key.writeToRESPBuffer(&buffer)
            count += id.writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Returns messages from multiple streams with IDs greater than the ones requested. Blocks until a message is available otherwise.
    ///
    /// - Documentation: [XREAD](https:/redis.io/docs/latest/commands/xread)
    /// - Version: 5.0.0
    /// - Categories: @read, @stream, @slow, @blocking
    /// - Response: One of the following:
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): A map of key-value elements where each element is composed of the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by `XADD`.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the _BLOCK_ option is given and a timeout occurs, or if there is no stream that can be served.
    @inlinable
    public static func xread(count: Int? = nil, milliseconds: Int? = nil, streams: XREADStreams) -> RESPCommand {
        RESPCommand("XREAD", RESPWithToken("COUNT", count), RESPWithToken("BLOCK", milliseconds), RESPWithToken("STREAMS", streams))
    }

    public struct XREADGROUPGroupBlock: RESPRenderable {
        @usableFromInline let group: String
        @usableFromInline let consumer: String

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += group.writeToRESPBuffer(&buffer)
            count += consumer.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public struct XREADGROUPStreams: RESPRenderable {
        @usableFromInline let key: [RedisKey]
        @usableFromInline let id: [String]

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += key.writeToRESPBuffer(&buffer)
            count += id.writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Returns new or historical messages from a stream for a consumer in a group. Blocks until a message is available otherwise.
    ///
    /// - Documentation: [XREADGROUP](https:/redis.io/docs/latest/commands/xreadgroup)
    /// - Version: 5.0.0
    /// - Complexity: For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data.
    /// - Categories: @write, @stream, @slow, @blocking
    /// - Response: One of the following:
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): A map of key-value elements where each element is composed of the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by `XADD`.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the _BLOCK_ option is given and a timeout occurs, or if there is no stream that can be served.
    @inlinable
    public static func xreadgroup(groupBlock: XREADGROUPGroupBlock, count: Int? = nil, milliseconds: Int? = nil, noack: Bool = false, streams: XREADGROUPStreams) -> RESPCommand {
        RESPCommand("XREADGROUP", RESPWithToken("GROUP", groupBlock), RESPWithToken("COUNT", count), RESPWithToken("BLOCK", milliseconds), RedisPureToken("NOACK", noack), RESPWithToken("STREAMS", streams))
    }

    /// Returns the messages from a stream within a range of IDs in reverse order.
    ///
    /// - Documentation: [XREVRANGE](https:/redis.io/docs/latest/commands/xrevrange)
    /// - Version: 5.0.0
    /// - Complexity: O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
    /// - Categories: @read, @stream, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): The command returns the entries with IDs matching the specified range. The returned entries are complete, which means that the ID and all the fields they are composed of are returned. Moreover, the entries are returned with their fields and values in the same order as `XADD` added them.
    @inlinable
    public static func xrevrange(key: RedisKey, end: String, start: String, count: Int? = nil) -> RESPCommand {
        RESPCommand("XREVRANGE", key, end, start, RESPWithToken("COUNT", count))
    }

    /// An internal command for replicating stream values.
    ///
    /// - Documentation: [XSETID](https:/redis.io/docs/latest/commands/xsetid)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @fast
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func xsetid(key: RedisKey, lastId: String, entriesAdded: Int? = nil, maxDeletedId: String? = nil) -> RESPCommand {
        RESPCommand("XSETID", key, lastId, RESPWithToken("ENTRIESADDED", entriesAdded), RESPWithToken("MAXDELETEDID", maxDeletedId))
    }

    public enum XTRIMTrimStrategy: RESPRenderable {
        case maxlen
        case minid

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .maxlen: "MAXLEN".writeToRESPBuffer(&buffer)
            case .minid: "MINID".writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum XTRIMTrimOperator: RESPRenderable {
        case equal
        case approximately

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .equal: "=".writeToRESPBuffer(&buffer)
            case .approximately: "~".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct XTRIMTrim: RESPRenderable {
        @usableFromInline let strategy: XTRIMTrimStrategy
        @usableFromInline let `operator`: XTRIMTrimOperator?
        @usableFromInline let threshold: String
        @usableFromInline let count: Int?

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += strategy.writeToRESPBuffer(&buffer)
            count += `operator`.writeToRESPBuffer(&buffer)
            count += threshold.writeToRESPBuffer(&buffer)
            count += RESPWithToken("LIMIT", count).writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Deletes messages from the beginning of a stream.
    ///
    /// - Documentation: [XTRIM](https:/redis.io/docs/latest/commands/xtrim)
    /// - Version: 5.0.0
    /// - Complexity: O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.
    /// - Categories: @write, @stream, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): The number of entries deleted from the stream.
    @inlinable
    public static func xtrim(key: RedisKey, trim: XTRIMTrim) -> RESPCommand {
        RESPCommand("XTRIM", key, trim)
    }

}

extension RedisConnection {
    /// Returns the number of messages that were successfully acknowledged by the consumer group member of a stream.
    ///
    /// - Documentation: [XACK](https:/redis.io/docs/latest/commands/xack)
    /// - Version: 5.0.0
    /// - Complexity: O(1) for each message ID processed.
    /// - Categories: @write, @stream, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have already been acknowledged), and XACK will not count them as successfully acknowledged.
    @inlinable
    public func xack(key: RedisKey, group: String, id: String) async throws -> Int {
        try await send("XACK", key, group, id).converting()
    }

    /// Returns the number of messages that were successfully acknowledged by the consumer group member of a stream.
    ///
    /// - Documentation: [XACK](https:/redis.io/docs/latest/commands/xack)
    /// - Version: 5.0.0
    /// - Complexity: O(1) for each message ID processed.
    /// - Categories: @write, @stream, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have already been acknowledged), and XACK will not count them as successfully acknowledged.
    @inlinable
    public func xack(key: RedisKey, group: String, ids: [String]) async throws -> Int {
        try await send("XACK", key, group, ids).converting()
    }

    /// Appends a new message to a stream. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [XADD](https:/redis.io/docs/latest/commands/xadd)
    /// - Version: 5.0.0
    /// - Complexity: O(1) when adding a new entry, O(N) when trimming where N being the number of entries evicted.
    /// - Categories: @write, @stream, @fast
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): The ID of the added entry. The ID is the one automatically generated if an asterisk (`*`) is passed as the _id_ argument, otherwise the command just returns the same ID specified by the user during insertion.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the NOMKSTREAM option is given and the key doesn't exist.
    @inlinable
    public func xadd(key: RedisKey, nomkstream: Bool = false, trim: RESPCommand.XADDTrim? = nil, idSelector: RESPCommand.XADDIdSelector, data: RESPCommand.XADDData) async throws -> String? {
        try await send("XADD", key, RedisPureToken("NOMKSTREAM", nomkstream), trim, idSelector, data).converting()
    }

    /// Appends a new message to a stream. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [XADD](https:/redis.io/docs/latest/commands/xadd)
    /// - Version: 5.0.0
    /// - Complexity: O(1) when adding a new entry, O(N) when trimming where N being the number of entries evicted.
    /// - Categories: @write, @stream, @fast
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): The ID of the added entry. The ID is the one automatically generated if an asterisk (`*`) is passed as the _id_ argument, otherwise the command just returns the same ID specified by the user during insertion.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the NOMKSTREAM option is given and the key doesn't exist.
    @inlinable
    public func xadd(key: RedisKey, nomkstream: Bool = false, trim: RESPCommand.XADDTrim? = nil, idSelector: RESPCommand.XADDIdSelector, datas: [RESPCommand.XADDData]) async throws -> String? {
        try await send("XADD", key, RedisPureToken("NOMKSTREAM", nomkstream), trim, idSelector, datas).converting()
    }

    /// Changes, or acquires, ownership of messages in a consumer group, as if the messages were delivered to as consumer group member.
    ///
    /// - Documentation: [XAUTOCLAIM](https:/redis.io/docs/latest/commands/xautoclaim)
    /// - Version: 6.2.0
    /// - Complexity: O(1) if COUNT is small.
    /// - Categories: @write, @stream, @fast
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays), specifically, an array with three elements:
    ///     1. A stream ID to be used as the _start_ argument for the next call to XAUTOCLAIM.
    ///     2. An [Array](https:/redis.io/docs/reference/protocol-spec#arrays) containing all the successfully claimed messages in the same format as `XRANGE`.
    ///     3. An [Array](https:/redis.io/docs/reference/protocol-spec#arrays) containing message IDs that no longer exist in the stream, and were deleted from the PEL in which they were found.
    @inlinable
    public func xautoclaim(key: RedisKey, group: String, consumer: String, minIdleTime: String, start: String, count: Int? = nil, justid: Bool = false) async throws -> [RESPToken] {
        try await send("XAUTOCLAIM", key, group, consumer, minIdleTime, start, RESPWithToken("COUNT", count), RedisPureToken("JUSTID", justid)).converting()
    }

    /// Changes, or acquires, ownership of a message in a consumer group, as if the message was delivered a consumer group member.
    ///
    /// - Documentation: [XCLAIM](https:/redis.io/docs/latest/commands/xclaim)
    /// - Version: 5.0.0
    /// - Complexity: O(log N) with N being the number of messages in the PEL of the consumer group.
    /// - Categories: @write, @stream, @fast
    /// - Returns: Any of the following:
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): when the _JUSTID_ option is specified, an array of IDs of messages successfully claimed.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): an array of stream entries, each of which contains an array of two elements, the entry ID and the entry data itself.
    @inlinable
    public func xclaim(key: RedisKey, group: String, consumer: String, minIdleTime: String, id: String, ms: Int? = nil, unixTimeMilliseconds: Date? = nil, count: Int? = nil, force: Bool = false, justid: Bool = false, lastid: String? = nil) async throws -> [RESPToken] {
        try await send("XCLAIM", key, group, consumer, minIdleTime, id, RESPWithToken("IDLE", ms), RESPWithToken("TIME", unixTimeMilliseconds.map { Int($0.timeIntervalSince1970 * 1000) }), RESPWithToken("RETRYCOUNT", count), RedisPureToken("FORCE", force), RedisPureToken("JUSTID", justid), RESPWithToken("LASTID", lastid)).converting()
    }

    /// Changes, or acquires, ownership of a message in a consumer group, as if the message was delivered a consumer group member.
    ///
    /// - Documentation: [XCLAIM](https:/redis.io/docs/latest/commands/xclaim)
    /// - Version: 5.0.0
    /// - Complexity: O(log N) with N being the number of messages in the PEL of the consumer group.
    /// - Categories: @write, @stream, @fast
    /// - Returns: Any of the following:
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): when the _JUSTID_ option is specified, an array of IDs of messages successfully claimed.
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): an array of stream entries, each of which contains an array of two elements, the entry ID and the entry data itself.
    @inlinable
    public func xclaim(key: RedisKey, group: String, consumer: String, minIdleTime: String, ids: [String], ms: Int? = nil, unixTimeMilliseconds: Date? = nil, count: Int? = nil, force: Bool = false, justid: Bool = false, lastid: String? = nil) async throws -> [RESPToken] {
        try await send("XCLAIM", key, group, consumer, minIdleTime, ids, RESPWithToken("IDLE", ms), RESPWithToken("TIME", unixTimeMilliseconds.map { Int($0.timeIntervalSince1970 * 1000) }), RESPWithToken("RETRYCOUNT", count), RedisPureToken("FORCE", force), RedisPureToken("JUSTID", justid), RESPWithToken("LASTID", lastid)).converting()
    }

    /// Returns the number of messages after removing them from a stream.
    ///
    /// - Documentation: [XDEL](https:/redis.io/docs/latest/commands/xdel)
    /// - Version: 5.0.0
    /// - Complexity: O(1) for each single item to delete in the stream, regardless of the stream size.
    /// - Categories: @write, @stream, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of entries that were deleted.
    @inlinable
    public func xdel(key: RedisKey, id: String) async throws -> Int {
        try await send("XDEL", key, id).converting()
    }

    /// Returns the number of messages after removing them from a stream.
    ///
    /// - Documentation: [XDEL](https:/redis.io/docs/latest/commands/xdel)
    /// - Version: 5.0.0
    /// - Complexity: O(1) for each single item to delete in the stream, regardless of the stream size.
    /// - Categories: @write, @stream, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of entries that were deleted.
    @inlinable
    public func xdel(key: RedisKey, ids: [String]) async throws -> Int {
        try await send("XDEL", key, ids).converting()
    }

    /// Creates a consumer group.
    ///
    /// - Documentation: [XGROUP CREATE](https:/redis.io/docs/latest/commands/xgroup-create)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func xgroupCreate(key: RedisKey, group: String, idSelector: RESPCommand.XGROUPCREATEIdSelector, mkstream: Bool = false, entriesRead: Int? = nil) async throws {
        try await send("XGROUP", "CREATE", key, group, idSelector, RedisPureToken("MKSTREAM", mkstream), RESPWithToken("ENTRIESREAD", entriesRead))
    }

    /// Creates a consumer in a consumer group.
    ///
    /// - Documentation: [XGROUP CREATECONSUMER](https:/redis.io/docs/latest/commands/xgroup-createconsumer)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of created consumers, either 0 or 1.
    @inlinable
    public func xgroupCreateconsumer(key: RedisKey, group: String, consumer: String) async throws -> Int {
        try await send("XGROUP", "CREATECONSUMER", key, group, consumer).converting()
    }

    /// Deletes a consumer from a consumer group.
    ///
    /// - Documentation: [XGROUP DELCONSUMER](https:/redis.io/docs/latest/commands/xgroup-delconsumer)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of pending messages the consumer had before it was deleted.
    @inlinable
    public func xgroupDelconsumer(key: RedisKey, group: String, consumer: String) async throws -> Int {
        try await send("XGROUP", "DELCONSUMER", key, group, consumer).converting()
    }

    /// Destroys a consumer group.
    ///
    /// - Documentation: [XGROUP DESTROY](https:/redis.io/docs/latest/commands/xgroup-destroy)
    /// - Version: 5.0.0
    /// - Complexity: O(N) where N is the number of entries in the group's pending entries list (PEL).
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of destroyed consumer groups, either 0 or 1.
    @inlinable
    public func xgroupDestroy(key: RedisKey, group: String) async throws -> Int {
        try await send("XGROUP", "DESTROY", key, group).converting()
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [XGROUP HELP](https:/redis.io/docs/latest/commands/xgroup-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @stream, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func xgroupHelp() async throws -> [RESPToken] {
        try await send("XGROUP", "HELP").converting()
    }

    /// Sets the last-delivered ID of a consumer group.
    ///
    /// - Documentation: [XGROUP SETID](https:/redis.io/docs/latest/commands/xgroup-setid)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func xgroupSetid(key: RedisKey, group: String, idSelector: RESPCommand.XGROUPSETIDIdSelector, entriesread: Int? = nil) async throws {
        try await send("XGROUP", "SETID", key, group, idSelector, RESPWithToken("ENTRIESREAD", entriesread))
    }

    /// Returns a list of the consumers in a consumer group.
    ///
    /// - Documentation: [XINFO CONSUMERS](https:/redis.io/docs/latest/commands/xinfo-consumers)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of consumers and their attributes.
    @inlinable
    public func xinfoConsumers(key: RedisKey, group: String) async throws -> [RESPToken] {
        try await send("XINFO", "CONSUMERS", key, group).converting()
    }

    /// Returns a list of the consumer groups of a stream.
    ///
    /// - Documentation: [XINFO GROUPS](https:/redis.io/docs/latest/commands/xinfo-groups)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of consumer groups.
    @inlinable
    public func xinfoGroups(key: RedisKey) async throws -> [RESPToken] {
        try await send("XINFO", "GROUPS", key).converting()
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [XINFO HELP](https:/redis.io/docs/latest/commands/xinfo-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @stream, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func xinfoHelp() async throws -> [RESPToken] {
        try await send("XINFO", "HELP").converting()
    }

    /// Returns information about a stream.
    ///
    /// - Documentation: [XINFO STREAM](https:/redis.io/docs/latest/commands/xinfo-stream)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @slow
    /// - Returns: One of the following:
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): when the _FULL_ argument was not given, a list of information about a stream in summary form.
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): when the _FULL_ argument was given, a list of information about a stream in extended form.
    @inlinable
    public func xinfoStream(key: RedisKey, fullBlock: RESPCommand.XINFOSTREAMFullBlock? = nil) async throws -> RESPToken {
        try await send("XINFO", "STREAM", key, fullBlock)
    }

    /// Return the number of messages in a stream.
    ///
    /// - Documentation: [XLEN](https:/redis.io/docs/latest/commands/xlen)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of entries of the stream at _key_.
    @inlinable
    public func xlen(key: RedisKey) async throws -> Int {
        try await send("XLEN", key).converting()
    }

    /// Returns the information and entries from a stream consumer group's pending entries list.
    ///
    /// - Documentation: [XPENDING](https:/redis.io/docs/latest/commands/xpending)
    /// - Version: 5.0.0
    /// - Complexity: O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). O(M), where M is the total number of entries scanned when used with the IDLE filter. When the command returns just the summary and the list of consumers is small, it runs in O(1) time; otherwise, an additional O(N) time for iterating every consumer.
    /// - Categories: @read, @stream, @slow
    /// - Returns: * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): different data depending on the way XPENDING is called, as explained on this page.
    @inlinable
    public func xpending(key: RedisKey, group: String, filters: RESPCommand.XPENDINGFilters? = nil) async throws -> RESPToken {
        try await send("XPENDING", key, group, filters)
    }

    /// Returns the messages from a stream within a range of IDs.
    ///
    /// - Documentation: [XRANGE](https:/redis.io/docs/latest/commands/xrange)
    /// - Version: 5.0.0
    /// - Complexity: O(N) with N being the number of elements being returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
    /// - Categories: @read, @stream, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of stream entries with IDs matching the specified range.
    @inlinable
    public func xrange(key: RedisKey, start: String, end: String, count: Int? = nil) async throws -> [RESPToken] {
        try await send("XRANGE", key, start, end, RESPWithToken("COUNT", count)).converting()
    }

    /// Returns messages from multiple streams with IDs greater than the ones requested. Blocks until a message is available otherwise.
    ///
    /// - Documentation: [XREAD](https:/redis.io/docs/latest/commands/xread)
    /// - Version: 5.0.0
    /// - Categories: @read, @stream, @slow, @blocking
    /// - Returns: One of the following:
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): A map of key-value elements where each element is composed of the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by `XADD`.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the _BLOCK_ option is given and a timeout occurs, or if there is no stream that can be served.
    @inlinable
    public func xread(count: Int? = nil, milliseconds: Int? = nil, streams: RESPCommand.XREADStreams) async throws -> RESPToken? {
        try await send("XREAD", RESPWithToken("COUNT", count), RESPWithToken("BLOCK", milliseconds), RESPWithToken("STREAMS", streams)).converting()
    }

    /// Returns new or historical messages from a stream for a consumer in a group. Blocks until a message is available otherwise.
    ///
    /// - Documentation: [XREADGROUP](https:/redis.io/docs/latest/commands/xreadgroup)
    /// - Version: 5.0.0
    /// - Complexity: For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data.
    /// - Categories: @write, @stream, @slow, @blocking
    /// - Returns: One of the following:
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): A map of key-value elements where each element is composed of the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by `XADD`.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the _BLOCK_ option is given and a timeout occurs, or if there is no stream that can be served.
    @inlinable
    public func xreadgroup(groupBlock: RESPCommand.XREADGROUPGroupBlock, count: Int? = nil, milliseconds: Int? = nil, noack: Bool = false, streams: RESPCommand.XREADGROUPStreams) async throws -> RESPToken? {
        try await send("XREADGROUP", RESPWithToken("GROUP", groupBlock), RESPWithToken("COUNT", count), RESPWithToken("BLOCK", milliseconds), RedisPureToken("NOACK", noack), RESPWithToken("STREAMS", streams)).converting()
    }

    /// Returns the messages from a stream within a range of IDs in reverse order.
    ///
    /// - Documentation: [XREVRANGE](https:/redis.io/docs/latest/commands/xrevrange)
    /// - Version: 5.0.0
    /// - Complexity: O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
    /// - Categories: @read, @stream, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): The command returns the entries with IDs matching the specified range. The returned entries are complete, which means that the ID and all the fields they are composed of are returned. Moreover, the entries are returned with their fields and values in the same order as `XADD` added them.
    @inlinable
    public func xrevrange(key: RedisKey, end: String, start: String, count: Int? = nil) async throws -> [RESPToken] {
        try await send("XREVRANGE", key, end, start, RESPWithToken("COUNT", count)).converting()
    }

    /// An internal command for replicating stream values.
    ///
    /// - Documentation: [XSETID](https:/redis.io/docs/latest/commands/xsetid)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @fast
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func xsetid(key: RedisKey, lastId: String, entriesAdded: Int? = nil, maxDeletedId: String? = nil) async throws {
        try await send("XSETID", key, lastId, RESPWithToken("ENTRIESADDED", entriesAdded), RESPWithToken("MAXDELETEDID", maxDeletedId))
    }

    /// Deletes messages from the beginning of a stream.
    ///
    /// - Documentation: [XTRIM](https:/redis.io/docs/latest/commands/xtrim)
    /// - Version: 5.0.0
    /// - Complexity: O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): The number of entries deleted from the stream.
    @inlinable
    public func xtrim(key: RedisKey, trim: RESPCommand.XTRIMTrim) async throws -> Int {
        try await send("XTRIM", key, trim).converting()
    }

}
