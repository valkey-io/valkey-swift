//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2023 Apple Inc. and the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import RESP
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension RESPCommand {
    public enum BITCOUNTRangeUnit: RESPRenderable {
        case byte
        case bit

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .byte: "BYTE".writeToRESPBuffer(&buffer)
            case .bit: "BIT".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct BITCOUNTRange: RESPRenderable {
        @usableFromInline let start: Int
        @usableFromInline let end: Int
        @usableFromInline let unit: BITCOUNTRangeUnit?

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += start.writeToRESPBuffer(&buffer)
            count += end.writeToRESPBuffer(&buffer)
            count += unit.writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Counts the number of set bits (population counting) in a string.
    ///
    /// - Documentation: [BITCOUNT](https:/redis.io/docs/latest/commands/bitcount)
    /// - Version: 2.6.0
    /// - Complexity: O(N)
    /// - Categories: @read, @bitmap, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of bits set to 1.
    @inlinable
    public static func bitcount(key: RedisKey, range: BITCOUNTRange? = nil) -> RESPCommand {
        RESPCommand("BITCOUNT", key, range)
    }

    public struct BITFIELDOperationGetBlock: RESPRenderable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += encoding.writeToRESPBuffer(&buffer)
            count += offset.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum BITFIELDOperationWriteOverflowBlock: RESPRenderable {
        case wrap
        case sat
        case fail

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .wrap: "WRAP".writeToRESPBuffer(&buffer)
            case .sat: "SAT".writeToRESPBuffer(&buffer)
            case .fail: "FAIL".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct BITFIELDOperationWriteWriteOperationSetBlock: RESPRenderable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int
        @usableFromInline let value: Int

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += encoding.writeToRESPBuffer(&buffer)
            count += offset.writeToRESPBuffer(&buffer)
            count += value.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public struct BITFIELDOperationWriteWriteOperationIncrbyBlock: RESPRenderable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int
        @usableFromInline let increment: Int

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += encoding.writeToRESPBuffer(&buffer)
            count += offset.writeToRESPBuffer(&buffer)
            count += increment.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum BITFIELDOperationWriteWriteOperation: RESPRenderable {
        case setBlock(BITFIELDOperationWriteWriteOperationSetBlock)
        case incrbyBlock(BITFIELDOperationWriteWriteOperationIncrbyBlock)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .setBlock(let setBlock): RESPWithToken("SET", setBlock).writeToRESPBuffer(&buffer)
            case .incrbyBlock(let incrbyBlock): RESPWithToken("INCRBY", incrbyBlock).writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct BITFIELDOperationWrite: RESPRenderable {
        @usableFromInline let overflowBlock: BITFIELDOperationWriteOverflowBlock?
        @usableFromInline let writeOperation: BITFIELDOperationWriteWriteOperation

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += RESPWithToken("OVERFLOW", overflowBlock).writeToRESPBuffer(&buffer)
            count += writeOperation.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum BITFIELDOperation: RESPRenderable {
        case getBlock(BITFIELDOperationGetBlock)
        case write(BITFIELDOperationWrite)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .getBlock(let getBlock): RESPWithToken("GET", getBlock).writeToRESPBuffer(&buffer)
            case .write(let write): write.writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Performs arbitrary bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD](https:/redis.io/docs/latest/commands/bitfield)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Categories: @write, @bitmap, @slow
    /// - Response: One of the following:
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): each entry being the corresponding result of the sub-command given at the same position.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if OVERFLOW FAIL was given and overflows or underflows are detected.
    @inlinable
    public static func bitfield(key: RedisKey, operation: BITFIELDOperation? = nil) -> RESPCommand {
        RESPCommand("BITFIELD", key, operation)
    }

    /// Performs arbitrary bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD](https:/redis.io/docs/latest/commands/bitfield)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Categories: @write, @bitmap, @slow
    /// - Response: One of the following:
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): each entry being the corresponding result of the sub-command given at the same position.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if OVERFLOW FAIL was given and overflows or underflows are detected.
    @inlinable
    public static func bitfield(key: RedisKey, operations: [BITFIELDOperation]) -> RESPCommand {
        RESPCommand("BITFIELD", key, operations)
    }

    public struct BITFIELDROGetBlock: RESPRenderable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += encoding.writeToRESPBuffer(&buffer)
            count += offset.writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Performs arbitrary read-only bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD_RO](https:/redis.io/docs/latest/commands/bitfield_ro)
    /// - Version: 6.0.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Categories: @read, @bitmap, @fast
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): each entry being the corresponding result of the sub-command given at the same position.
    @inlinable
    public static func bitfieldRo(key: RedisKey, getBlock: BITFIELDROGetBlock? = nil) -> RESPCommand {
        RESPCommand("BITFIELD_RO", key, RESPWithToken("GET", getBlock))
    }

    /// Performs arbitrary read-only bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD_RO](https:/redis.io/docs/latest/commands/bitfield_ro)
    /// - Version: 6.0.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Categories: @read, @bitmap, @fast
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): each entry being the corresponding result of the sub-command given at the same position.
    @inlinable
    public static func bitfieldRo(key: RedisKey, getBlocks: [BITFIELDROGetBlock]) -> RESPCommand {
        RESPCommand("BITFIELD_RO", key, RESPWithToken("GET", getBlocks))
    }

    public enum BITOPOperation: RESPRenderable {
        case and
        case or
        case xor
        case not

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .and: "AND".writeToRESPBuffer(&buffer)
            case .or: "OR".writeToRESPBuffer(&buffer)
            case .xor: "XOR".writeToRESPBuffer(&buffer)
            case .not: "NOT".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Performs bitwise operations on multiple strings, and stores the result.
    ///
    /// - Documentation: [BITOP](https:/redis.io/docs/latest/commands/bitop)
    /// - Version: 2.6.0
    /// - Complexity: O(N)
    /// - Categories: @write, @bitmap, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the size of the string stored in the destination key is equal to the size of the longest input string.
    @inlinable
    public static func bitop(operation: BITOPOperation, destkey: RedisKey, key: RedisKey) -> RESPCommand {
        RESPCommand("BITOP", operation, destkey, key)
    }

    /// Performs bitwise operations on multiple strings, and stores the result.
    ///
    /// - Documentation: [BITOP](https:/redis.io/docs/latest/commands/bitop)
    /// - Version: 2.6.0
    /// - Complexity: O(N)
    /// - Categories: @write, @bitmap, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the size of the string stored in the destination key is equal to the size of the longest input string.
    @inlinable
    public static func bitop(operation: BITOPOperation, destkey: RedisKey, keys: [RedisKey]) -> RESPCommand {
        RESPCommand("BITOP", operation, destkey, keys)
    }

    public enum BITPOSRangeEndUnitBlockUnit: RESPRenderable {
        case byte
        case bit

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .byte: "BYTE".writeToRESPBuffer(&buffer)
            case .bit: "BIT".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct BITPOSRangeEndUnitBlock: RESPRenderable {
        @usableFromInline let end: Int
        @usableFromInline let unit: BITPOSRangeEndUnitBlockUnit?

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += end.writeToRESPBuffer(&buffer)
            count += unit.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public struct BITPOSRange: RESPRenderable {
        @usableFromInline let start: Int
        @usableFromInline let endUnitBlock: BITPOSRangeEndUnitBlock?

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += start.writeToRESPBuffer(&buffer)
            count += endUnitBlock.writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Finds the first set (1) or clear (0) bit in a string.
    ///
    /// - Documentation: [BITPOS](https:/redis.io/docs/latest/commands/bitpos)
    /// - Version: 2.8.7
    /// - Complexity: O(N)
    /// - Categories: @read, @bitmap, @slow
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the position of the first bit set to 1 or 0 according to the request
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1`. In case the `bit` argument is 1 and the string is empty or composed of just zero bytes
    ///     
    ///     If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.
    ///     
    ///     If we look for clear bits (the bit argument is 0) and the string only contains bits set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value `0xff` the command `BITPOS key 0` will return 24, since up to bit 23 all the bits are 1.
    ///     
    ///     The function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the _start_ argument **only**.
    ///     
    ///     However, this behavior changes if you are looking for clear bits and specify a range with both _start_ and _end_.
    ///     If a clear bit isn't found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.
    @inlinable
    public static func bitpos(key: RedisKey, bit: Int, range: BITPOSRange? = nil) -> RESPCommand {
        RESPCommand("BITPOS", key, bit, range)
    }

    /// Returns a bit value by offset.
    ///
    /// - Documentation: [GETBIT](https:/redis.io/docs/latest/commands/getbit)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @bitmap, @fast
    /// - Response: The bit value stored at _offset_, one of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0`.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1`.
    @inlinable
    public static func getbit(key: RedisKey, offset: Int) -> RESPCommand {
        RESPCommand("GETBIT", key, offset)
    }

    /// Sets or clears the bit at offset of the string value. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETBIT](https:/redis.io/docs/latest/commands/setbit)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @bitmap, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the original bit value stored at _offset_.
    @inlinable
    public static func setbit(key: RedisKey, offset: Int, value: Int) -> RESPCommand {
        RESPCommand("SETBIT", key, offset, value)
    }

}

extension RedisConnection {
    /// Counts the number of set bits (population counting) in a string.
    ///
    /// - Documentation: [BITCOUNT](https:/redis.io/docs/latest/commands/bitcount)
    /// - Version: 2.6.0
    /// - Complexity: O(N)
    /// - Categories: @read, @bitmap, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of bits set to 1.
    @inlinable
    public func bitcount(key: RedisKey, range: RESPCommand.BITCOUNTRange? = nil) async throws -> Int {
        try await send("BITCOUNT", key, range).converting()
    }

    /// Performs arbitrary bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD](https:/redis.io/docs/latest/commands/bitfield)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Categories: @write, @bitmap, @slow
    /// - Returns: One of the following:
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): each entry being the corresponding result of the sub-command given at the same position.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if OVERFLOW FAIL was given and overflows or underflows are detected.
    @inlinable
    public func bitfield(key: RedisKey, operation: RESPCommand.BITFIELDOperation? = nil) async throws -> [RESPToken]? {
        try await send("BITFIELD", key, operation).converting()
    }

    /// Performs arbitrary bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD](https:/redis.io/docs/latest/commands/bitfield)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Categories: @write, @bitmap, @slow
    /// - Returns: One of the following:
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): each entry being the corresponding result of the sub-command given at the same position.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if OVERFLOW FAIL was given and overflows or underflows are detected.
    @inlinable
    public func bitfield(key: RedisKey, operations: [RESPCommand.BITFIELDOperation]) async throws -> [RESPToken]? {
        try await send("BITFIELD", key, operations).converting()
    }

    /// Performs arbitrary read-only bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD_RO](https:/redis.io/docs/latest/commands/bitfield_ro)
    /// - Version: 6.0.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Categories: @read, @bitmap, @fast
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): each entry being the corresponding result of the sub-command given at the same position.
    @inlinable
    public func bitfieldRo(key: RedisKey, getBlock: RESPCommand.BITFIELDROGetBlock? = nil) async throws -> [RESPToken] {
        try await send("BITFIELD_RO", key, RESPWithToken("GET", getBlock)).converting()
    }

    /// Performs arbitrary read-only bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD_RO](https:/redis.io/docs/latest/commands/bitfield_ro)
    /// - Version: 6.0.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Categories: @read, @bitmap, @fast
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): each entry being the corresponding result of the sub-command given at the same position.
    @inlinable
    public func bitfieldRo(key: RedisKey, getBlocks: [RESPCommand.BITFIELDROGetBlock]) async throws -> [RESPToken] {
        try await send("BITFIELD_RO", key, RESPWithToken("GET", getBlocks)).converting()
    }

    /// Performs bitwise operations on multiple strings, and stores the result.
    ///
    /// - Documentation: [BITOP](https:/redis.io/docs/latest/commands/bitop)
    /// - Version: 2.6.0
    /// - Complexity: O(N)
    /// - Categories: @write, @bitmap, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the size of the string stored in the destination key is equal to the size of the longest input string.
    @inlinable
    public func bitop(operation: RESPCommand.BITOPOperation, destkey: RedisKey, key: RedisKey) async throws -> Int {
        try await send("BITOP", operation, destkey, key).converting()
    }

    /// Performs bitwise operations on multiple strings, and stores the result.
    ///
    /// - Documentation: [BITOP](https:/redis.io/docs/latest/commands/bitop)
    /// - Version: 2.6.0
    /// - Complexity: O(N)
    /// - Categories: @write, @bitmap, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the size of the string stored in the destination key is equal to the size of the longest input string.
    @inlinable
    public func bitop(operation: RESPCommand.BITOPOperation, destkey: RedisKey, keys: [RedisKey]) async throws -> Int {
        try await send("BITOP", operation, destkey, keys).converting()
    }

    /// Finds the first set (1) or clear (0) bit in a string.
    ///
    /// - Documentation: [BITPOS](https:/redis.io/docs/latest/commands/bitpos)
    /// - Version: 2.8.7
    /// - Complexity: O(N)
    /// - Categories: @read, @bitmap, @slow
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the position of the first bit set to 1 or 0 according to the request
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1`. In case the `bit` argument is 1 and the string is empty or composed of just zero bytes
    ///     
    ///     If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.
    ///     
    ///     If we look for clear bits (the bit argument is 0) and the string only contains bits set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value `0xff` the command `BITPOS key 0` will return 24, since up to bit 23 all the bits are 1.
    ///     
    ///     The function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the _start_ argument **only**.
    ///     
    ///     However, this behavior changes if you are looking for clear bits and specify a range with both _start_ and _end_.
    ///     If a clear bit isn't found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.
    @inlinable
    public func bitpos(key: RedisKey, bit: Int, range: RESPCommand.BITPOSRange? = nil) async throws -> Int {
        try await send("BITPOS", key, bit, range).converting()
    }

    /// Returns a bit value by offset.
    ///
    /// - Documentation: [GETBIT](https:/redis.io/docs/latest/commands/getbit)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @bitmap, @fast
    /// - Returns: The bit value stored at _offset_, one of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0`.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1`.
    @inlinable
    public func getbit(key: RedisKey, offset: Int) async throws -> Int {
        try await send("GETBIT", key, offset).converting()
    }

    /// Sets or clears the bit at offset of the string value. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETBIT](https:/redis.io/docs/latest/commands/setbit)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @bitmap, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the original bit value stored at _offset_.
    @inlinable
    public func setbit(key: RedisKey, offset: Int, value: Int) async throws -> Int {
        try await send("SETBIT", key, offset, value).converting()
    }

}
