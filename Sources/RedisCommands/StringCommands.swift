//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2023 Apple Inc. and the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import RESP
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension RESPCommand {
    /// Appends a string to the value of a key. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [APPEND](https:/redis.io/docs/latest/commands/append)
    /// - Version: 2.0.0
    /// - Complexity: O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation.
    /// - Categories: @write, @string, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the string after the append operation.
    @inlinable
    public static func append(key: RedisKey, value: String) -> RESPCommand {
        RESPCommand("APPEND", key, value)
    }

    /// Decrements the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [DECR](https:/redis.io/docs/latest/commands/decr)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after decrementing it.
    @inlinable
    public static func decr(key: RedisKey) -> RESPCommand {
        RESPCommand("DECR", key)
    }

    /// Decrements a number from the integer value of a key. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [DECRBY](https:/redis.io/docs/latest/commands/decrby)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after decrementing it.
    @inlinable
    public static func decrby(key: RedisKey, decrement: Int) -> RESPCommand {
        RESPCommand("DECRBY", key, decrement)
    }

    /// Returns the string value of a key.
    ///
    /// - Documentation: [GET](https:/redis.io/docs/latest/commands/get)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @string, @fast
    /// - Response: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): key does not exist.
    @inlinable
    public static func get(key: RedisKey) -> RESPCommand {
        RESPCommand("GET", key)
    }

    /// Returns the string value of a key after deleting the key.
    ///
    /// - Documentation: [GETDEL](https:/redis.io/docs/latest/commands/getdel)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Response: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key does not exist or if the key's value type is not a string.
    @inlinable
    public static func getdel(key: RedisKey) -> RESPCommand {
        RESPCommand("GETDEL", key)
    }

    public enum GETEXExpiration: RESPRenderable {
        case seconds(Int)
        case milliseconds(Int)
        case unixTimeSeconds(Date)
        case unixTimeMilliseconds(Date)
        case persist

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .seconds(let seconds): RESPWithToken("EX", seconds).writeToRESPBuffer(&buffer)
            case .milliseconds(let milliseconds): RESPWithToken("PX", milliseconds).writeToRESPBuffer(&buffer)
            case .unixTimeSeconds(let unixTimeSeconds): RESPWithToken("EXAT", Int(unixTimeSeconds.timeIntervalSince1970)).writeToRESPBuffer(&buffer)
            case .unixTimeMilliseconds(let unixTimeMilliseconds): RESPWithToken("PXAT", Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000)).writeToRESPBuffer(&buffer)
            case .persist: "PERSIST".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Returns the string value of a key after setting its expiration time.
    ///
    /// - Documentation: [GETEX](https:/redis.io/docs/latest/commands/getex)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Response: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of `key`
    ///     [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if `key` does not exist.
    @inlinable
    public static func getex(key: RedisKey, expiration: GETEXExpiration? = nil) -> RESPCommand {
        RESPCommand("GETEX", key, expiration)
    }

    /// Returns a substring of the string stored at a key.
    ///
    /// - Documentation: [GETRANGE](https:/redis.io/docs/latest/commands/getrange)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
    /// - Categories: @read, @string, @slow
    /// - Response: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): The substring of the string value stored at key, determined by the offsets start and end (both are inclusive).
    @inlinable
    public static func getrange(key: RedisKey, start: Int, end: Int) -> RESPCommand {
        RESPCommand("GETRANGE", key, start, end)
    }

    /// Returns the previous string value of a key after setting it to a new value.
    ///
    /// - Documentation: [GETSET](https:/redis.io/docs/latest/commands/getset)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Response: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the old value stored at the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key does not exist.
    @inlinable
    public static func getset(key: RedisKey, value: String) -> RESPCommand {
        RESPCommand("GETSET", key, value)
    }

    /// Increments the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCR](https:/redis.io/docs/latest/commands/incr)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after the increment.
    @inlinable
    public static func incr(key: RedisKey) -> RESPCommand {
        RESPCommand("INCR", key)
    }

    /// Increments the integer value of a key by a number. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCRBY](https:/redis.io/docs/latest/commands/incrby)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after the increment.
    @inlinable
    public static func incrby(key: RedisKey, increment: Int) -> RESPCommand {
        RESPCommand("INCRBY", key, increment)
    }

    /// Increment the floating point value of a key by a number. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCRBYFLOAT](https:/redis.io/docs/latest/commands/incrbyfloat)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Response: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of the key after the increment.
    @inlinable
    public static func incrbyfloat(key: RedisKey, increment: Double) -> RESPCommand {
        RESPCommand("INCRBYFLOAT", key, increment)
    }

    /// Finds the longest common substring.
    ///
    /// - Documentation: [LCS](https:/redis.io/docs/latest/commands/lcs)
    /// - Version: 7.0.0
    /// - Complexity: O(N*M) where N and M are the lengths of s1 and s2, respectively
    /// - Categories: @read, @string, @slow
    /// - Response: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the longest common subsequence.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the longest common subsequence when _LEN_ is given.
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): a map with the LCS length and all the ranges in both the strings when _IDX_ is given.
    @inlinable
    public static func lcs(key1: RedisKey, key2: RedisKey, len: Bool = false, idx: Bool = false, minMatchLen: Int? = nil, withmatchlen: Bool = false) -> RESPCommand {
        RESPCommand("LCS", key1, key2, RedisPureToken("LEN", len), RedisPureToken("IDX", idx), RESPWithToken("MINMATCHLEN", minMatchLen), RedisPureToken("WITHMATCHLEN", withmatchlen))
    }

    /// Atomically returns the string values of one or more keys.
    ///
    /// - Documentation: [MGET](https:/redis.io/docs/latest/commands/mget)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys to retrieve.
    /// - Categories: @read, @string, @fast
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of values at the specified keys.
    @inlinable
    public static func mget(key: RedisKey) -> RESPCommand {
        RESPCommand("MGET", key)
    }

    /// Atomically returns the string values of one or more keys.
    ///
    /// - Documentation: [MGET](https:/redis.io/docs/latest/commands/mget)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys to retrieve.
    /// - Categories: @read, @string, @fast
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of values at the specified keys.
    @inlinable
    public static func mget(keys: [RedisKey]) -> RESPCommand {
        RESPCommand("MGET", keys)
    }

    public struct MSETData: RESPRenderable {
        @usableFromInline let key: RedisKey
        @usableFromInline let value: String

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += key.writeToRESPBuffer(&buffer)
            count += value.writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Atomically creates or modifies the string values of one or more keys.
    ///
    /// - Documentation: [MSET](https:/redis.io/docs/latest/commands/mset)
    /// - Version: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Categories: @write, @string, @slow
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): always `OK` because `MSET` can't fail.
    @inlinable
    public static func mset(data: MSETData) -> RESPCommand {
        RESPCommand("MSET", data)
    }

    /// Atomically creates or modifies the string values of one or more keys.
    ///
    /// - Documentation: [MSET](https:/redis.io/docs/latest/commands/mset)
    /// - Version: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Categories: @write, @string, @slow
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): always `OK` because `MSET` can't fail.
    @inlinable
    public static func mset(datas: [MSETData]) -> RESPCommand {
        RESPCommand("MSET", datas)
    }

    public struct MSETNXData: RESPRenderable {
        @usableFromInline let key: RedisKey
        @usableFromInline let value: String

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += key.writeToRESPBuffer(&buffer)
            count += value.writeToRESPBuffer(&buffer)
            return count
        }
    }
    /// Atomically modifies the string values of one or more keys only when all keys don't exist.
    ///
    /// - Documentation: [MSETNX](https:/redis.io/docs/latest/commands/msetnx)
    /// - Version: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Categories: @write, @string, @slow
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if no key was set (at least one key already existed).
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if all the keys were set.
    @inlinable
    public static func msetnx(data: MSETNXData) -> RESPCommand {
        RESPCommand("MSETNX", data)
    }

    /// Atomically modifies the string values of one or more keys only when all keys don't exist.
    ///
    /// - Documentation: [MSETNX](https:/redis.io/docs/latest/commands/msetnx)
    /// - Version: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Categories: @write, @string, @slow
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if no key was set (at least one key already existed).
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if all the keys were set.
    @inlinable
    public static func msetnx(datas: [MSETNXData]) -> RESPCommand {
        RESPCommand("MSETNX", datas)
    }

    /// Sets both string value and expiration time in milliseconds of a key. The key is created if it doesn't exist.
    ///
    /// - Documentation: [PSETEX](https:/redis.io/docs/latest/commands/psetex)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @slow
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func psetex(key: RedisKey, milliseconds: Int, value: String) -> RESPCommand {
        RESPCommand("PSETEX", key, milliseconds, value)
    }

    public enum SETCondition: RESPRenderable {
        case nx
        case xx

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .nx: "NX".writeToRESPBuffer(&buffer)
            case .xx: "XX".writeToRESPBuffer(&buffer)
            }
        }
    }
    public enum SETExpiration: RESPRenderable {
        case seconds(Int)
        case milliseconds(Int)
        case unixTimeSeconds(Date)
        case unixTimeMilliseconds(Date)
        case keepttl

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .seconds(let seconds): RESPWithToken("EX", seconds).writeToRESPBuffer(&buffer)
            case .milliseconds(let milliseconds): RESPWithToken("PX", milliseconds).writeToRESPBuffer(&buffer)
            case .unixTimeSeconds(let unixTimeSeconds): RESPWithToken("EXAT", Int(unixTimeSeconds.timeIntervalSince1970)).writeToRESPBuffer(&buffer)
            case .unixTimeMilliseconds(let unixTimeMilliseconds): RESPWithToken("PXAT", Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000)).writeToRESPBuffer(&buffer)
            case .keepttl: "KEEPTTL".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Sets the string value of a key, ignoring its type. The key is created if it doesn't exist.
    ///
    /// - Documentation: [SET](https:/redis.io/docs/latest/commands/set)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @slow
    /// - Response: Any of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): `GET` not given: Operation was aborted (conflict with one of the `XX`/`NX` options).
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`. `GET` not given: The key was set.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): `GET` given: The key didn't exist before the `SET`.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): `GET` given: The previous value of the key.
    @inlinable
    public static func set(key: RedisKey, value: String, condition: SETCondition? = nil, get: Bool = false, expiration: SETExpiration? = nil) -> RESPCommand {
        RESPCommand("SET", key, value, condition, RedisPureToken("GET", get), expiration)
    }

    /// Sets the string value and expiration time of a key. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETEX](https:/redis.io/docs/latest/commands/setex)
    /// - Version: 2.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @slow
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func setex(key: RedisKey, seconds: Int, value: String) -> RESPCommand {
        RESPCommand("SETEX", key, seconds, value)
    }

    /// Set the string value of a key only when the key doesn't exist.
    ///
    /// - Documentation: [SETNX](https:/redis.io/docs/latest/commands/setnx)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the key was not set.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the key was set.
    @inlinable
    public static func setnx(key: RedisKey, value: String) -> RESPCommand {
        RESPCommand("SETNX", key, value)
    }

    /// Overwrites a part of a string value with another by an offset. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETRANGE](https:/redis.io/docs/latest/commands/setrange)
    /// - Version: 2.2.0
    /// - Complexity: O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.
    /// - Categories: @write, @string, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the string after it was modified by the command.
    @inlinable
    public static func setrange(key: RedisKey, offset: Int, value: String) -> RESPCommand {
        RESPCommand("SETRANGE", key, offset, value)
    }

    /// Returns the length of a string value.
    ///
    /// - Documentation: [STRLEN](https:/redis.io/docs/latest/commands/strlen)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @string, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the string stored at key, or 0 when the key does not exist.
    @inlinable
    public static func strlen(key: RedisKey) -> RESPCommand {
        RESPCommand("STRLEN", key)
    }

    /// Returns a substring from a string value.
    ///
    /// - Documentation: [SUBSTR](https:/redis.io/docs/latest/commands/substr)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
    /// - Categories: @read, @string, @slow
    /// - Response: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the substring of the string value stored at key, determined by the offsets start and end (both are inclusive).
    @inlinable
    public static func substr(key: RedisKey, start: Int, end: Int) -> RESPCommand {
        RESPCommand("SUBSTR", key, start, end)
    }

}

extension RedisConnection {
    /// Appends a string to the value of a key. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [APPEND](https:/redis.io/docs/latest/commands/append)
    /// - Version: 2.0.0
    /// - Complexity: O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation.
    /// - Categories: @write, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the string after the append operation.
    @inlinable
    public func append(key: RedisKey, value: String) async throws -> Int {
        try await send("APPEND", key, value).converting()
    }

    /// Decrements the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [DECR](https:/redis.io/docs/latest/commands/decr)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after decrementing it.
    @inlinable
    public func decr(key: RedisKey) async throws -> Int {
        try await send("DECR", key).converting()
    }

    /// Decrements a number from the integer value of a key. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [DECRBY](https:/redis.io/docs/latest/commands/decrby)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after decrementing it.
    @inlinable
    public func decrby(key: RedisKey, decrement: Int) async throws -> Int {
        try await send("DECRBY", key, decrement).converting()
    }

    /// Returns the string value of a key.
    ///
    /// - Documentation: [GET](https:/redis.io/docs/latest/commands/get)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @string, @fast
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): key does not exist.
    @inlinable
    public func get(key: RedisKey) async throws -> String? {
        try await send("GET", key).converting()
    }

    /// Returns the string value of a key after deleting the key.
    ///
    /// - Documentation: [GETDEL](https:/redis.io/docs/latest/commands/getdel)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key does not exist or if the key's value type is not a string.
    @inlinable
    public func getdel(key: RedisKey) async throws -> String? {
        try await send("GETDEL", key).converting()
    }

    /// Returns the string value of a key after setting its expiration time.
    ///
    /// - Documentation: [GETEX](https:/redis.io/docs/latest/commands/getex)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of `key`
    ///     [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if `key` does not exist.
    @inlinable
    public func getex(key: RedisKey, expiration: RESPCommand.GETEXExpiration? = nil) async throws -> String? {
        try await send("GETEX", key, expiration).converting()
    }

    /// Returns a substring of the string stored at a key.
    ///
    /// - Documentation: [GETRANGE](https:/redis.io/docs/latest/commands/getrange)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
    /// - Categories: @read, @string, @slow
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): The substring of the string value stored at key, determined by the offsets start and end (both are inclusive).
    @inlinable
    public func getrange(key: RedisKey, start: Int, end: Int) async throws -> String {
        try await send("GETRANGE", key, start, end).converting()
    }

    /// Returns the previous string value of a key after setting it to a new value.
    ///
    /// - Documentation: [GETSET](https:/redis.io/docs/latest/commands/getset)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the old value stored at the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key does not exist.
    @inlinable
    public func getset(key: RedisKey, value: String) async throws -> String? {
        try await send("GETSET", key, value).converting()
    }

    /// Increments the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCR](https:/redis.io/docs/latest/commands/incr)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after the increment.
    @inlinable
    public func incr(key: RedisKey) async throws -> Int {
        try await send("INCR", key).converting()
    }

    /// Increments the integer value of a key by a number. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCRBY](https:/redis.io/docs/latest/commands/incrby)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after the increment.
    @inlinable
    public func incrby(key: RedisKey, increment: Int) async throws -> Int {
        try await send("INCRBY", key, increment).converting()
    }

    /// Increment the floating point value of a key by a number. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCRBYFLOAT](https:/redis.io/docs/latest/commands/incrbyfloat)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of the key after the increment.
    @inlinable
    public func incrbyfloat(key: RedisKey, increment: Double) async throws -> String {
        try await send("INCRBYFLOAT", key, increment).converting()
    }

    /// Finds the longest common substring.
    ///
    /// - Documentation: [LCS](https:/redis.io/docs/latest/commands/lcs)
    /// - Version: 7.0.0
    /// - Complexity: O(N*M) where N and M are the lengths of s1 and s2, respectively
    /// - Categories: @read, @string, @slow
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the longest common subsequence.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the longest common subsequence when _LEN_ is given.
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): a map with the LCS length and all the ranges in both the strings when _IDX_ is given.
    @inlinable
    public func lcs(key1: RedisKey, key2: RedisKey, len: Bool = false, idx: Bool = false, minMatchLen: Int? = nil, withmatchlen: Bool = false) async throws -> RESPToken {
        try await send("LCS", key1, key2, RedisPureToken("LEN", len), RedisPureToken("IDX", idx), RESPWithToken("MINMATCHLEN", minMatchLen), RedisPureToken("WITHMATCHLEN", withmatchlen))
    }

    /// Atomically returns the string values of one or more keys.
    ///
    /// - Documentation: [MGET](https:/redis.io/docs/latest/commands/mget)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys to retrieve.
    /// - Categories: @read, @string, @fast
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of values at the specified keys.
    @inlinable
    public func mget(key: RedisKey) async throws -> [RESPToken] {
        try await send("MGET", key).converting()
    }

    /// Atomically returns the string values of one or more keys.
    ///
    /// - Documentation: [MGET](https:/redis.io/docs/latest/commands/mget)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys to retrieve.
    /// - Categories: @read, @string, @fast
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of values at the specified keys.
    @inlinable
    public func mget(keys: [RedisKey]) async throws -> [RESPToken] {
        try await send("MGET", keys).converting()
    }

    /// Atomically creates or modifies the string values of one or more keys.
    ///
    /// - Documentation: [MSET](https:/redis.io/docs/latest/commands/mset)
    /// - Version: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Categories: @write, @string, @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): always `OK` because `MSET` can't fail.
    @inlinable
    public func mset(data: RESPCommand.MSETData) async throws {
        try await send("MSET", data)
    }

    /// Atomically creates or modifies the string values of one or more keys.
    ///
    /// - Documentation: [MSET](https:/redis.io/docs/latest/commands/mset)
    /// - Version: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Categories: @write, @string, @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): always `OK` because `MSET` can't fail.
    @inlinable
    public func mset(datas: [RESPCommand.MSETData]) async throws {
        try await send("MSET", datas)
    }

    /// Atomically modifies the string values of one or more keys only when all keys don't exist.
    ///
    /// - Documentation: [MSETNX](https:/redis.io/docs/latest/commands/msetnx)
    /// - Version: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Categories: @write, @string, @slow
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if no key was set (at least one key already existed).
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if all the keys were set.
    @inlinable
    public func msetnx(data: RESPCommand.MSETNXData) async throws -> Int {
        try await send("MSETNX", data).converting()
    }

    /// Atomically modifies the string values of one or more keys only when all keys don't exist.
    ///
    /// - Documentation: [MSETNX](https:/redis.io/docs/latest/commands/msetnx)
    /// - Version: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Categories: @write, @string, @slow
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if no key was set (at least one key already existed).
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if all the keys were set.
    @inlinable
    public func msetnx(datas: [RESPCommand.MSETNXData]) async throws -> Int {
        try await send("MSETNX", datas).converting()
    }

    /// Sets both string value and expiration time in milliseconds of a key. The key is created if it doesn't exist.
    ///
    /// - Documentation: [PSETEX](https:/redis.io/docs/latest/commands/psetex)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func psetex(key: RedisKey, milliseconds: Int, value: String) async throws {
        try await send("PSETEX", key, milliseconds, value)
    }

    /// Sets the string value of a key, ignoring its type. The key is created if it doesn't exist.
    ///
    /// - Documentation: [SET](https:/redis.io/docs/latest/commands/set)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @slow
    /// - Returns: Any of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): `GET` not given: Operation was aborted (conflict with one of the `XX`/`NX` options).
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`. `GET` not given: The key was set.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): `GET` given: The key didn't exist before the `SET`.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): `GET` given: The previous value of the key.
    @inlinable
    public func set(key: RedisKey, value: String, condition: RESPCommand.SETCondition? = nil, get: Bool = false, expiration: RESPCommand.SETExpiration? = nil) async throws -> String? {
        try await send("SET", key, value, condition, RedisPureToken("GET", get), expiration).converting()
    }

    /// Sets the string value and expiration time of a key. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETEX](https:/redis.io/docs/latest/commands/setex)
    /// - Version: 2.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func setex(key: RedisKey, seconds: Int, value: String) async throws {
        try await send("SETEX", key, seconds, value)
    }

    /// Set the string value of a key only when the key doesn't exist.
    ///
    /// - Documentation: [SETNX](https:/redis.io/docs/latest/commands/setnx)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the key was not set.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the key was set.
    @inlinable
    public func setnx(key: RedisKey, value: String) async throws -> Int {
        try await send("SETNX", key, value).converting()
    }

    /// Overwrites a part of a string value with another by an offset. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETRANGE](https:/redis.io/docs/latest/commands/setrange)
    /// - Version: 2.2.0
    /// - Complexity: O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.
    /// - Categories: @write, @string, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the string after it was modified by the command.
    @inlinable
    public func setrange(key: RedisKey, offset: Int, value: String) async throws -> Int {
        try await send("SETRANGE", key, offset, value).converting()
    }

    /// Returns the length of a string value.
    ///
    /// - Documentation: [STRLEN](https:/redis.io/docs/latest/commands/strlen)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the string stored at key, or 0 when the key does not exist.
    @inlinable
    public func strlen(key: RedisKey) async throws -> Int {
        try await send("STRLEN", key).converting()
    }

    /// Returns a substring from a string value.
    ///
    /// - Documentation: [SUBSTR](https:/redis.io/docs/latest/commands/substr)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
    /// - Categories: @read, @string, @slow
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the substring of the string value stored at key, determined by the offsets start and end (both are inclusive).
    @inlinable
    public func substr(key: RedisKey, start: Int, end: Int) async throws -> String {
        try await send("SUBSTR", key, start, end).converting()
    }

}
