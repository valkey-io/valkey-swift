//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2025 Apple Inc. and the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// A container for Access List Control commands.
public enum ACL {
    /// Lists the ACL categories, or the commands inside a category.
    public struct CAT: RESPCommand {
        public typealias Response = [String]

        public var category: String? = nil

        @inlinable public init(category: String? = nil) {
            self.category = category
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "CAT", category)
        }
    }

    /// Deletes ACL users, and terminates their connections.
    public struct DELUSER: RESPCommand {
        public typealias Response = Int

        public var username: [String]

        @inlinable public init(username: [String]) {
            self.username = username
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "DELUSER", username)
        }
    }

    /// Simulates the execution of a command by a user, without executing the command.
    public struct DRYRUN: RESPCommand {
        public typealias Response = String?

        public var username: String
        public var command: String
        public var arg: [String] = []

        @inlinable public init(username: String, command: String, arg: [String] = []) {
            self.username = username
            self.command = command
            self.arg = arg
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "DRYRUN", username, command, arg)
        }
    }

    /// Generates a pseudorandom, secure password that can be used to identify ACL users.
    public struct GENPASS: RESPCommand {
        public typealias Response = String

        public var bits: Int? = nil

        @inlinable public init(bits: Int? = nil) {
            self.bits = bits
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "GENPASS", bits)
        }
    }

    /// Lists the ACL rules of a user.
    public struct GETUSER: RESPCommand {
        public typealias Response = [String: RESPToken]?

        public var username: String

        @inlinable public init(username: String) {
            self.username = username
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "GETUSER", username)
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "HELP")
        }
    }

    /// Dumps the effective rules in ACL file format.
    public struct LIST: RESPCommand {
        public typealias Response = [String]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "LIST")
        }
    }

    /// Reloads the rules from the configured ACL file.
    public struct LOAD: RESPCommand {
        public typealias Response = RESPToken


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "LOAD")
        }
    }

    /// Lists recent security events generated due to ACL rules.
    public struct LOG: RESPCommand {
        public enum Operation: RESPRenderable {
            case count(Int)
            case reset

            @inlinable
            public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
                switch self {
                case .count(let count): count.encode(into: &commandEncoder)
                case .reset: "RESET".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = [String]?

        public var operation: Operation? = nil

        @inlinable public init(operation: Operation? = nil) {
            self.operation = operation
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "LOG", operation)
        }
    }

    /// Saves the effective ACL rules in the configured ACL file.
    public struct SAVE: RESPCommand {
        public typealias Response = RESPToken


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "SAVE")
        }
    }

    /// Creates and modifies an ACL user and its rules.
    public struct SETUSER: RESPCommand {
        public typealias Response = RESPToken

        public var username: String
        public var rule: [String] = []

        @inlinable public init(username: String, rule: [String] = []) {
            self.username = username
            self.rule = rule
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "SETUSER", username, rule)
        }
    }

    /// Lists all ACL users.
    public struct USERS: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "USERS")
        }
    }

    /// Returns the authenticated username of the current connection.
    public struct WHOAMI: RESPCommand {
        public typealias Response = String


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("ACL", "WHOAMI")
        }
    }

}

extension COMMAND {
    /// Returns a count of commands.
    public struct COUNT: RESPCommand {
        public typealias Response = Int


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("COMMAND", "COUNT")
        }
    }

    /// Returns documentary information about one, multiple or all commands.
    public struct DOCS: RESPCommand {
        public typealias Response = [String: RESPToken]

        public var commandName: [String] = []

        @inlinable public init(commandName: [String] = []) {
            self.commandName = commandName
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("COMMAND", "DOCS", commandName)
        }
    }

    /// Extracts the key names from an arbitrary command.
    public struct GETKEYS: RESPCommand {
        public typealias Response = [RESPToken]

        public var command: String
        public var arg: [String] = []

        @inlinable public init(command: String, arg: [String] = []) {
            self.command = command
            self.arg = arg
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("COMMAND", "GETKEYS", command, arg)
        }
    }

    /// Extracts the key names and access flags for an arbitrary command.
    public struct GETKEYSANDFLAGS: RESPCommand {
        public typealias Response = [RESPToken]

        public var command: String
        public var arg: [String] = []

        @inlinable public init(command: String, arg: [String] = []) {
            self.command = command
            self.arg = arg
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("COMMAND", "GETKEYSANDFLAGS", command, arg)
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("COMMAND", "HELP")
        }
    }

    /// Returns information about one, multiple or all commands.
    public struct INFO: RESPCommand {
        public typealias Response = [RESPToken]

        public var commandName: [String] = []

        @inlinable public init(commandName: [String] = []) {
            self.commandName = commandName
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("COMMAND", "INFO", commandName)
        }
    }

    /// Returns a list of command names.
    public struct LIST: RESPCommand {
        public enum Filterby: RESPRenderable {
            case moduleName(String)
            case category(String)
            case pattern(String)

            @inlinable
            public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
                switch self {
                case .moduleName(let moduleName): RESPWithToken("MODULE", moduleName).encode(into: &commandEncoder)
                case .category(let category): RESPWithToken("ACLCAT", category).encode(into: &commandEncoder)
                case .pattern(let pattern): RESPWithToken("PATTERN", pattern).encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = [RESPToken]

        public var filterby: Filterby? = nil

        @inlinable public init(filterby: Filterby? = nil) {
            self.filterby = filterby
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("COMMAND", "LIST", RESPWithToken("FILTERBY", filterby))
        }
    }

}

/// A container for server configuration commands.
public enum CONFIG {
    /// Returns the effective values of configuration parameters.
    public struct GET: RESPCommand {
        public typealias Response = [String: RESPToken]

        public var parameter: [String]

        @inlinable public init(parameter: [String]) {
            self.parameter = parameter
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("CONFIG", "GET", parameter)
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("CONFIG", "HELP")
        }
    }

    /// Resets the server's statistics.
    public struct RESETSTAT: RESPCommand {
        public typealias Response = RESPToken


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("CONFIG", "RESETSTAT")
        }
    }

    /// Persists the effective configuration to file.
    public struct REWRITE: RESPCommand {
        public typealias Response = RESPToken


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("CONFIG", "REWRITE")
        }
    }

    /// Sets configuration parameters in-flight.
    public struct SET: RESPCommand {
        public struct Data: RESPRenderable {
            @usableFromInline let parameter: String
            @usableFromInline let value: String

            @inlinable
            public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
                var count = 0
                count += parameter.encode(into: &commandEncoder)
                count += value.encode(into: &commandEncoder)
                return count
            }
        }
        public typealias Response = RESPToken

        public var data: [Data]

        @inlinable public init(data: [Data]) {
            self.data = data
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("CONFIG", "SET", data)
        }
    }

}

/// A container for latency diagnostics commands.
public enum LATENCY {
    /// Returns a human-readable latency analysis report.
    public struct DOCTOR: RESPCommand {
        public typealias Response = String


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("LATENCY", "DOCTOR")
        }
    }

    /// Returns a latency graph for an event.
    public struct GRAPH: RESPCommand {
        public typealias Response = String

        public var event: String

        @inlinable public init(event: String) {
            self.event = event
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("LATENCY", "GRAPH", event)
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("LATENCY", "HELP")
        }
    }

    /// Returns the cumulative distribution of latencies of a subset or all commands.
    public struct HISTOGRAM: RESPCommand {
        public typealias Response = [String: RESPToken]

        public var command: [String] = []

        @inlinable public init(command: [String] = []) {
            self.command = command
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("LATENCY", "HISTOGRAM", command)
        }
    }

    /// Returns timestamp-latency samples for an event.
    public struct HISTORY: RESPCommand {
        public typealias Response = [RESPToken]

        public var event: String

        @inlinable public init(event: String) {
            self.event = event
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("LATENCY", "HISTORY", event)
        }
    }

    /// Returns the latest latency samples for all events.
    public struct LATEST: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("LATENCY", "LATEST")
        }
    }

    /// Resets the latency data for one or more events.
    public struct RESET: RESPCommand {
        public typealias Response = Int

        public var event: [String] = []

        @inlinable public init(event: [String] = []) {
            self.event = event
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("LATENCY", "RESET", event)
        }
    }

}

/// A container for memory diagnostics commands.
public enum MEMORY {
    /// Outputs a memory problems report.
    public struct DOCTOR: RESPCommand {
        public typealias Response = String


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MEMORY", "DOCTOR")
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MEMORY", "HELP")
        }
    }

    /// Returns the allocator statistics.
    public struct MALLOCSTATS: RESPCommand {
        public typealias Response = String


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MEMORY", "MALLOC-STATS")
        }
    }

    /// Asks the allocator to release memory.
    public struct PURGE: RESPCommand {
        public typealias Response = RESPToken


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MEMORY", "PURGE")
        }
    }

    /// Returns details about memory usage.
    public struct STATS: RESPCommand {
        public typealias Response = [String: RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MEMORY", "STATS")
        }
    }

    /// Estimates the memory usage of a key.
    public struct USAGE: RESPCommand {
        public typealias Response = Int?

        public var key: RESPKey
        public var count: Int? = nil

        @inlinable public init(key: RESPKey, count: Int? = nil) {
            self.key = key
            self.count = count
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MEMORY", "USAGE", key, RESPWithToken("SAMPLES", count))
        }
    }

}

/// A container for module commands.
public enum MODULE {
    /// Returns helpful text about the different subcommands.
    public struct HELP: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MODULE", "HELP")
        }
    }

    /// Returns all loaded modules.
    public struct LIST: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MODULE", "LIST")
        }
    }

    /// Loads a module.
    public struct LOAD: RESPCommand {
        public typealias Response = RESPToken

        public var path: String
        public var arg: [String] = []

        @inlinable public init(path: String, arg: [String] = []) {
            self.path = path
            self.arg = arg
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MODULE", "LOAD", path, arg)
        }
    }

    /// Loads a module using extended parameters.
    public struct LOADEX: RESPCommand {
        public struct Configs: RESPRenderable {
            @usableFromInline let name: String
            @usableFromInline let value: String

            @inlinable
            public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
                var count = 0
                count += name.encode(into: &commandEncoder)
                count += value.encode(into: &commandEncoder)
                return count
            }
        }
        public typealias Response = RESPToken

        public var path: String
        public var configs: [Configs] = []
        public var args: [String] = []

        @inlinable public init(path: String, configs: [Configs] = [], args: [String] = []) {
            self.path = path
            self.configs = configs
            self.args = args
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MODULE", "LOADEX", path, RESPWithToken("CONFIG", configs), RESPWithToken("ARGS", args))
        }
    }

    /// Unloads a module.
    public struct UNLOAD: RESPCommand {
        public typealias Response = RESPToken

        public var name: String

        @inlinable public init(name: String) {
            self.name = name
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("MODULE", "UNLOAD", name)
        }
    }

}

/// A container for slow log commands.
public enum SLOWLOG {
    /// Returns the slow log's entries.
    public struct GET: RESPCommand {
        public typealias Response = [RESPToken]

        public var count: Int? = nil

        @inlinable public init(count: Int? = nil) {
            self.count = count
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("SLOWLOG", "GET", count)
        }
    }

    /// Show helpful text about the different subcommands
    public struct HELP: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("SLOWLOG", "HELP")
        }
    }

    /// Returns the number of entries in the slow log.
    public struct LEN: RESPCommand {
        public typealias Response = Int


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("SLOWLOG", "LEN")
        }
    }

    /// Clears all entries from the slow log.
    public struct RESET: RESPCommand {
        public typealias Response = RESPToken


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("SLOWLOG", "RESET")
        }
    }

}

/// Asynchronously rewrites the append-only file to disk.
public struct BGREWRITEAOF: RESPCommand {
    public typealias Response = String


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("BGREWRITEAOF")
    }
}

/// Asynchronously saves the database(s) to disk.
public struct BGSAVE: RESPCommand {
    public typealias Response = String

    public var schedule: Bool = false

    @inlinable public init(schedule: Bool = false) {
        self.schedule = schedule
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("BGSAVE", RESPPureToken("SCHEDULE", schedule))
    }
}

/// Returns detailed information about all commands.
public struct COMMAND: RESPCommand {
    public typealias Response = [RESPToken]


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("COMMAND")
    }
}

/// Returns the number of keys in the database.
public struct DBSIZE: RESPCommand {
    public typealias Response = Int


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("DBSIZE")
    }
}

/// Starts a coordinated failover from a server to one of its replicas.
public struct FAILOVER: RESPCommand {
    public struct Target: RESPRenderable {
        @usableFromInline let host: String
        @usableFromInline let port: Int
        @usableFromInline let force: Bool

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += host.encode(into: &commandEncoder)
            count += port.encode(into: &commandEncoder)
            if self.force { count += "FORCE".encode(into: &commandEncoder) }
            return count
        }
    }
    public typealias Response = RESPToken

    public var target: Target? = nil
    public var abort: Bool = false
    public var milliseconds: Int? = nil

    @inlinable public init(target: Target? = nil, abort: Bool = false, milliseconds: Int? = nil) {
        self.target = target
        self.abort = abort
        self.milliseconds = milliseconds
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("FAILOVER", RESPWithToken("TO", target), RESPPureToken("ABORT", abort), RESPWithToken("TIMEOUT", milliseconds))
    }
}

/// Removes all keys from all databases.
public struct FLUSHALL: RESPCommand {
    public enum FlushType: RESPRenderable {
        case async
        case sync

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .async: "ASYNC".encode(into: &commandEncoder)
            case .sync: "SYNC".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken

    public var flushType: FlushType? = nil

    @inlinable public init(flushType: FlushType? = nil) {
        self.flushType = flushType
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("FLUSHALL", flushType)
    }
}

/// Remove all keys from the current database.
public struct FLUSHDB: RESPCommand {
    public enum FlushType: RESPRenderable {
        case async
        case sync

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .async: "ASYNC".encode(into: &commandEncoder)
            case .sync: "SYNC".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken

    public var flushType: FlushType? = nil

    @inlinable public init(flushType: FlushType? = nil) {
        self.flushType = flushType
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("FLUSHDB", flushType)
    }
}

/// Returns information and statistics about the server.
public struct INFO: RESPCommand {
    public typealias Response = String

    public var section: [String] = []

    @inlinable public init(section: [String] = []) {
        self.section = section
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("INFO", section)
    }
}

/// Returns the Unix timestamp of the last successful save to disk.
public struct LASTSAVE: RESPCommand {
    public typealias Response = Int


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("LASTSAVE")
    }
}

/// Displays computer art and the Redis version
public struct LOLWUT: RESPCommand {
    public typealias Response = String

    public var version: Int? = nil

    @inlinable public init(version: Int? = nil) {
        self.version = version
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("LOLWUT", RESPWithToken("VERSION", version))
    }
}

/// Listens for all requests received by the server in real-time.
public struct MONITOR: RESPCommand {
    public typealias Response = RESPToken


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("MONITOR")
    }
}

/// An internal command used in replication.
public struct PSYNC: RESPCommand {
    public typealias Response = RESPToken

    public var replicationid: String
    public var offset: Int

    @inlinable public init(replicationid: String, offset: Int) {
        self.replicationid = replicationid
        self.offset = offset
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("PSYNC", replicationid, offset)
    }
}

/// An internal command for configuring the replication stream.
public struct REPLCONF: RESPCommand {
    public typealias Response = RESPToken


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("REPLCONF")
    }
}

/// Configures a server as replica of another, or promotes it to a master.
public struct REPLICAOF: RESPCommand {
    public struct ArgsHostPort: RESPRenderable {
        @usableFromInline let host: String
        @usableFromInline let port: Int

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += host.encode(into: &commandEncoder)
            count += port.encode(into: &commandEncoder)
            return count
        }
    }
    public struct ArgsNoOne: RESPRenderable {
        @usableFromInline let no: Bool
        @usableFromInline let one: Bool

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            if self.no { count += "NO".encode(into: &commandEncoder) }
            if self.one { count += "ONE".encode(into: &commandEncoder) }
            return count
        }
    }
    public enum Args: RESPRenderable {
        case hostPort(ArgsHostPort)
        case noOne(ArgsNoOne)

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .hostPort(let hostPort): hostPort.encode(into: &commandEncoder)
            case .noOne(let noOne): noOne.encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken

    public var args: Args

    @inlinable public init(args: Args) {
        self.args = args
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("REPLICAOF", args)
    }
}

/// An internal command for migrating keys in a cluster.
public struct RESTOREASKING: RESPCommand {
    public typealias Response = RESPToken

    public var key: RESPKey
    public var ttl: Int
    public var serializedValue: String
    public var replace: Bool = false
    public var absttl: Bool = false
    public var seconds: Int? = nil
    public var frequency: Int? = nil

    @inlinable public init(key: RESPKey, ttl: Int, serializedValue: String, replace: Bool = false, absttl: Bool = false, seconds: Int? = nil, frequency: Int? = nil) {
        self.key = key
        self.ttl = ttl
        self.serializedValue = serializedValue
        self.replace = replace
        self.absttl = absttl
        self.seconds = seconds
        self.frequency = frequency
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("RESTORE-ASKING", key, ttl, serializedValue, RESPPureToken("REPLACE", replace), RESPPureToken("ABSTTL", absttl), RESPWithToken("IDLETIME", seconds), RESPWithToken("FREQ", frequency))
    }
}

/// Returns the replication role.
public struct ROLE: RESPCommand {
    public typealias Response = [RESPToken]


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("ROLE")
    }
}

/// Synchronously saves the database(s) to disk.
public struct SAVE: RESPCommand {
    public typealias Response = RESPToken


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SAVE")
    }
}

/// Synchronously saves the database(s) to disk and shuts down the Redis server.
public struct SHUTDOWN: RESPCommand {
    public enum SaveSelector: RESPRenderable {
        case nosave
        case save

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .nosave: "NOSAVE".encode(into: &commandEncoder)
            case .save: "SAVE".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken

    public var saveSelector: SaveSelector? = nil
    public var now: Bool = false
    public var force: Bool = false
    public var abort: Bool = false

    @inlinable public init(saveSelector: SaveSelector? = nil, now: Bool = false, force: Bool = false, abort: Bool = false) {
        self.saveSelector = saveSelector
        self.now = now
        self.force = force
        self.abort = abort
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SHUTDOWN", saveSelector, RESPPureToken("NOW", now), RESPPureToken("FORCE", force), RESPPureToken("ABORT", abort))
    }
}

/// Sets a Redis server as a replica of another, or promotes it to being a master.
public struct SLAVEOF: RESPCommand {
    public struct ArgsHostPort: RESPRenderable {
        @usableFromInline let host: String
        @usableFromInline let port: Int

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += host.encode(into: &commandEncoder)
            count += port.encode(into: &commandEncoder)
            return count
        }
    }
    public struct ArgsNoOne: RESPRenderable {
        @usableFromInline let no: Bool
        @usableFromInline let one: Bool

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            if self.no { count += "NO".encode(into: &commandEncoder) }
            if self.one { count += "ONE".encode(into: &commandEncoder) }
            return count
        }
    }
    public enum Args: RESPRenderable {
        case hostPort(ArgsHostPort)
        case noOne(ArgsNoOne)

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .hostPort(let hostPort): hostPort.encode(into: &commandEncoder)
            case .noOne(let noOne): noOne.encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken

    public var args: Args

    @inlinable public init(args: Args) {
        self.args = args
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SLAVEOF", args)
    }
}

/// Swaps two Redis databases.
public struct SWAPDB: RESPCommand {
    public typealias Response = RESPToken

    public var index1: Int
    public var index2: Int

    @inlinable public init(index1: Int, index2: Int) {
        self.index1 = index1
        self.index2 = index2
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SWAPDB", index1, index2)
    }
}

/// An internal command used in replication.
public struct SYNC: RESPCommand {
    public typealias Response = RESPToken


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SYNC")
    }
}

/// Returns the server time.
public struct TIME: RESPCommand {
    public typealias Response = [RESPToken]


    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("TIME")
    }
}


extension RedisConnection {
    /// Lists the ACL categories, or the commands inside a category.
    ///
    /// - Documentation: [ACL CAT](https:/redis.io/docs/latest/commands/acl-cat)
    /// - Version: 6.0.0
    /// - Complexity: O(1) since the categories and commands are a fixed set.
    /// - Categories: @slow
    /// - Returns: One of the following:
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): an array of [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings) elements representing ACL categories or commands in a given category.
    ///     * [Simple error](https:/redis.io/docs/reference/protocol-spec#simple-errors): the command returns an error if an invalid category name is given.
    @inlinable
    public func aclCat(category: String? = nil) async throws -> [String] {
        try await send(command: ACL.CAT(category: category))
    }

    /// Deletes ACL users, and terminates their connections.
    ///
    /// - Documentation: [ACL DELUSER](https:/redis.io/docs/latest/commands/acl-deluser)
    /// - Version: 6.0.0
    /// - Complexity: O(1) amortized time considering the typical user.
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of users that were deleted. This number will not always match the number of arguments since certain users may not exist.
    @inlinable
    public func aclDeluser(username: [String]) async throws -> Int {
        try await send(command: ACL.DELUSER(username: username))
    }

    /// Simulates the execution of a command by a user, without executing the command.
    ///
    /// - Documentation: [ACL DRYRUN](https:/redis.io/docs/latest/commands/acl-dryrun)
    /// - Version: 7.0.0
    /// - Complexity: O(1).
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: Any of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` on success.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): an error describing why the user can't execute the command.
    @inlinable
    public func aclDryrun(username: String, command: String, arg: [String] = []) async throws -> String? {
        try await send(command: ACL.DRYRUN(username: username, command: command, arg: arg))
    }

    /// Generates a pseudorandom, secure password that can be used to identify ACL users.
    ///
    /// - Documentation: [ACL GENPASS](https:/redis.io/docs/latest/commands/acl-genpass)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): pseudorandom data. By default it contains 64 bytes, representing 256 bits of data. If `bits` was given, the output string length is the number of specified bits (rounded to the next multiple of 4) divided by 4.
    @inlinable
    public func aclGenpass(bits: Int? = nil) async throws -> String {
        try await send(command: ACL.GENPASS(bits: bits))
    }

    /// Lists the ACL rules of a user.
    ///
    /// - Documentation: [ACL GETUSER](https:/redis.io/docs/latest/commands/acl-getuser)
    /// - Version: 6.0.0
    /// - Complexity: O(N). Where N is the number of password, command and pattern rules that the user has.
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: One of the following:
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): a set of ACL rule definitions for the user
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if user does not exist.
    @inlinable
    public func aclGetuser(username: String) async throws -> [String: RESPToken]? {
        try await send(command: ACL.GETUSER(username: username))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [ACL HELP](https:/redis.io/docs/latest/commands/acl-help)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of subcommands and their descriptions.
    @inlinable
    public func aclHelp() async throws -> [RESPToken] {
        try await send(command: ACL.HELP())
    }

    /// Dumps the effective rules in ACL file format.
    ///
    /// - Documentation: [ACL LIST](https:/redis.io/docs/latest/commands/acl-list)
    /// - Version: 6.0.0
    /// - Complexity: O(N). Where N is the number of configured users.
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): an array of [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings) elements.
    @inlinable
    public func aclList() async throws -> [String] {
        try await send(command: ACL.LIST())
    }

    /// Reloads the rules from the configured ACL file.
    ///
    /// - Documentation: [ACL LOAD](https:/redis.io/docs/latest/commands/acl-load)
    /// - Version: 6.0.0
    /// - Complexity: O(N). Where N is the number of configured users.
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` on success.
    ///     
    ///     The command may fail with an error for several reasons: if the file is not readable, if there is an error inside the file, and in such cases, the error will be reported to the user in the error.
    ///     Finally, the command will fail if the server is not configured to use an external ACL file.
    @inlinable
    public func aclLoad() async throws -> RESPToken {
        try await send(command: ACL.LOAD())
    }

    /// Lists recent security events generated due to ACL rules.
    ///
    /// - Documentation: [ACL LOG](https:/redis.io/docs/latest/commands/acl-log)
    /// - Version: 6.0.0
    /// - Complexity: O(N) with N being the number of entries shown.
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: When called to show security events:
    ///     * [Array](https:/redis.io/docs/reference/protocol-spec#arrays): an array of [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings) elements representing ACL security events.
    ///     When called with `RESET`:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the security log was cleared.
    @inlinable
    public func aclLog(operation: ACL.LOG.Operation? = nil) async throws -> [String]? {
        try await send(command: ACL.LOG(operation: operation))
    }

    /// Saves the effective ACL rules in the configured ACL file.
    ///
    /// - Documentation: [ACL SAVE](https:/redis.io/docs/latest/commands/acl-save)
    /// - Version: 6.0.0
    /// - Complexity: O(N). Where N is the number of configured users.
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    ///     The command may fail with an error for several reasons: if the file cannot be written or if the server is not configured to use an external ACL file.
    @inlinable
    public func aclSave() async throws -> RESPToken {
        try await send(command: ACL.SAVE())
    }

    /// Creates and modifies an ACL user and its rules.
    ///
    /// - Documentation: [ACL SETUSER](https:/redis.io/docs/latest/commands/acl-setuser)
    /// - Version: 6.0.0
    /// - Complexity: O(N). Where N is the number of rules provided.
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    ///     If the rules contain errors, the error is returned.
    @inlinable
    public func aclSetuser(username: String, rule: [String] = []) async throws -> RESPToken {
        try await send(command: ACL.SETUSER(username: username, rule: rule))
    }

    /// Lists all ACL users.
    ///
    /// - Documentation: [ACL USERS](https:/redis.io/docs/latest/commands/acl-users)
    /// - Version: 6.0.0
    /// - Complexity: O(N). Where N is the number of configured users.
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): list of existing ACL users.
    @inlinable
    public func aclUsers() async throws -> [RESPToken] {
        try await send(command: ACL.USERS())
    }

    /// Returns the authenticated username of the current connection.
    ///
    /// - Documentation: [ACL WHOAMI](https:/redis.io/docs/latest/commands/acl-whoami)
    /// - Version: 6.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the username of the current connection.
    @inlinable
    public func aclWhoami() async throws -> String {
        try await send(command: ACL.WHOAMI())
    }

    /// Asynchronously rewrites the append-only file to disk.
    ///
    /// - Documentation: [BGREWRITEAOF](https:/redis.io/docs/latest/commands/bgrewriteaof)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): a simple string reply indicating that the rewriting started or is about to start ASAP when the call is executed with success.
    ///     
    ///     The command may reply with an error in certain cases, as documented above.
    @inlinable
    public func bgrewriteaof() async throws -> String {
        try await send(command: BGREWRITEAOF())
    }

    /// Asynchronously saves the database(s) to disk.
    ///
    /// - Documentation: [BGSAVE](https:/redis.io/docs/latest/commands/bgsave)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: One of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `Background saving started`.
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `Background saving scheduled`.
    @inlinable
    public func bgsave(schedule: Bool = false) async throws -> String {
        try await send(command: BGSAVE(schedule: schedule))
    }

    /// Returns detailed information about all commands.
    ///
    /// - Documentation: [COMMAND](https:/redis.io/docs/latest/commands/command)
    /// - Version: 2.8.13
    /// - Complexity: O(N) where N is the total number of Redis commands
    /// - Categories: @slow, @connection
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a nested list of command details. The order of the commands in the array is random.
    @inlinable
    public func command() async throws -> [RESPToken] {
        try await send(command: COMMAND())
    }

    /// Returns a count of commands.
    ///
    /// - Documentation: [COMMAND COUNT](https:/redis.io/docs/latest/commands/command-count)
    /// - Version: 2.8.13
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of commands returned by `COMMAND`.
    @inlinable
    public func commandCount() async throws -> Int {
        try await send(command: COMMAND.COUNT())
    }

    /// Returns documentary information about one, multiple or all commands.
    ///
    /// - Documentation: [COMMAND DOCS](https:/redis.io/docs/latest/commands/command-docs)
    /// - Version: 7.0.0
    /// - Complexity: O(N) where N is the number of commands to look up
    /// - Categories: @slow, @connection
    /// - Returns: [Map](https:/redis.io/docs/reference/protocol-spec#maps): a map where each key is a command name, and each value is the documentary information.
    @inlinable
    public func commandDocs(commandName: [String] = []) async throws -> [String: RESPToken] {
        try await send(command: COMMAND.DOCS(commandName: commandName))
    }

    /// Extracts the key names from an arbitrary command.
    ///
    /// - Documentation: [COMMAND GETKEYS](https:/redis.io/docs/latest/commands/command-getkeys)
    /// - Version: 2.8.13
    /// - Complexity: O(N) where N is the number of arguments to the command
    /// - Categories: @slow, @connection
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of keys from the given command.
    @inlinable
    public func commandGetkeys(command: String, arg: [String] = []) async throws -> [RESPToken] {
        try await send(command: COMMAND.GETKEYS(command: command, arg: arg))
    }

    /// Extracts the key names and access flags for an arbitrary command.
    ///
    /// - Documentation: [COMMAND GETKEYSANDFLAGS](https:/redis.io/docs/latest/commands/command-getkeysandflags)
    /// - Version: 7.0.0
    /// - Complexity: O(N) where N is the number of arguments to the command
    /// - Categories: @slow, @connection
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of keys from the given command and their usage flags.
    @inlinable
    public func commandGetkeysandflags(command: String, arg: [String] = []) async throws -> [RESPToken] {
        try await send(command: COMMAND.GETKEYSANDFLAGS(command: command, arg: arg))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [COMMAND HELP](https:/redis.io/docs/latest/commands/command-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func commandHelp() async throws -> [RESPToken] {
        try await send(command: COMMAND.HELP())
    }

    /// Returns information about one, multiple or all commands.
    ///
    /// - Documentation: [COMMAND INFO](https:/redis.io/docs/latest/commands/command-info)
    /// - Version: 2.8.13
    /// - Complexity: O(N) where N is the number of commands to look up
    /// - Categories: @slow, @connection
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a nested list of command details.
    @inlinable
    public func commandInfo(commandName: [String] = []) async throws -> [RESPToken] {
        try await send(command: COMMAND.INFO(commandName: commandName))
    }

    /// Returns a list of command names.
    ///
    /// - Documentation: [COMMAND LIST](https:/redis.io/docs/latest/commands/command-list)
    /// - Version: 7.0.0
    /// - Complexity: O(N) where N is the total number of Redis commands
    /// - Categories: @slow, @connection
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of command names.
    @inlinable
    public func commandList(filterby: COMMAND.LIST.Filterby? = nil) async throws -> [RESPToken] {
        try await send(command: COMMAND.LIST(filterby: filterby))
    }

    /// Returns the effective values of configuration parameters.
    ///
    /// - Documentation: [CONFIG GET](https:/redis.io/docs/latest/commands/config-get)
    /// - Version: 2.0.0
    /// - Complexity: O(N) when N is the number of configuration parameters provided
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Map](https:/redis.io/docs/reference/protocol-spec#maps): a list of configuration parameters matching the provided arguments.
    @inlinable
    public func configGet(parameter: [String]) async throws -> [String: RESPToken] {
        try await send(command: CONFIG.GET(parameter: parameter))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [CONFIG HELP](https:/redis.io/docs/latest/commands/config-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func configHelp() async throws -> [RESPToken] {
        try await send(command: CONFIG.HELP())
    }

    /// Resets the server's statistics.
    ///
    /// - Documentation: [CONFIG RESETSTAT](https:/redis.io/docs/latest/commands/config-resetstat)
    /// - Version: 2.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func configResetstat() async throws -> RESPToken {
        try await send(command: CONFIG.RESETSTAT())
    }

    /// Persists the effective configuration to file.
    ///
    /// - Documentation: [CONFIG REWRITE](https:/redis.io/docs/latest/commands/config-rewrite)
    /// - Version: 2.8.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` when the configuration was rewritten properly. Otherwise an error is returned.
    @inlinable
    public func configRewrite() async throws -> RESPToken {
        try await send(command: CONFIG.REWRITE())
    }

    /// Sets configuration parameters in-flight.
    ///
    /// - Documentation: [CONFIG SET](https:/redis.io/docs/latest/commands/config-set)
    /// - Version: 2.0.0
    /// - Complexity: O(N) when N is the number of configuration parameters provided
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` when the configuration was set properly. Otherwise an error is returned.
    @inlinable
    public func configSet(data: [CONFIG.SET.Data]) async throws -> RESPToken {
        try await send(command: CONFIG.SET(data: data))
    }

    /// Returns the number of keys in the database.
    ///
    /// - Documentation: [DBSIZE](https:/redis.io/docs/latest/commands/dbsize)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys in the currently-selected database.
    @inlinable
    public func dbsize() async throws -> Int {
        try await send(command: DBSIZE())
    }

    /// Starts a coordinated failover from a server to one of its replicas.
    ///
    /// - Documentation: [FAILOVER](https:/redis.io/docs/latest/commands/failover)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the command was accepted and a coordinated failover is in progress. An error if the operation cannot be executed.
    @inlinable
    public func failover(target: FAILOVER.Target? = nil, abort: Bool = false, milliseconds: Int? = nil) async throws -> RESPToken {
        try await send(command: FAILOVER(target: target, abort: abort, milliseconds: milliseconds))
    }

    /// Removes all keys from all databases.
    ///
    /// - Documentation: [FLUSHALL](https:/redis.io/docs/latest/commands/flushall)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the total number of keys in all databases
    /// - Categories: @keyspace, @write, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func flushall(flushType: FLUSHALL.FlushType? = nil) async throws -> RESPToken {
        try await send(command: FLUSHALL(flushType: flushType))
    }

    /// Remove all keys from the current database.
    ///
    /// - Documentation: [FLUSHDB](https:/redis.io/docs/latest/commands/flushdb)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys in the selected database
    /// - Categories: @keyspace, @write, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func flushdb(flushType: FLUSHDB.FlushType? = nil) async throws -> RESPToken {
        try await send(command: FLUSHDB(flushType: flushType))
    }

    /// Returns information and statistics about the server.
    ///
    /// - Documentation: [INFO](https:/redis.io/docs/latest/commands/info)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @dangerous
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): a map of info fields, one field per line in the form of `<field>:<value>` where the value can be a comma separated map like `<key>=<val>`. Also contains section header lines starting with `#` and blank lines.
    ///     
    ///     Lines can contain a section name (starting with a `#` character) or a property. All the properties are in the form of `field:value` terminated by `\r\n`.
    @inlinable
    public func info(section: [String] = []) async throws -> String {
        try await send(command: INFO(section: section))
    }

    /// Returns the Unix timestamp of the last successful save to disk.
    ///
    /// - Documentation: [LASTSAVE](https:/redis.io/docs/latest/commands/lastsave)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @fast, @dangerous
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): UNIX TIME of the last DB save executed with success.
    @inlinable
    public func lastsave() async throws -> Int {
        try await send(command: LASTSAVE())
    }

    /// Returns a human-readable latency analysis report.
    ///
    /// - Documentation: [LATENCY DOCTOR](https:/redis.io/docs/latest/commands/latency-doctor)
    /// - Version: 2.8.13
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Verbatim string](https:/redis.io/docs/reference/protocol-spec#verbatim-strings): a human readable latency analysis report.
    @inlinable
    public func latencyDoctor() async throws -> String {
        try await send(command: LATENCY.DOCTOR())
    }

    /// Returns a latency graph for an event.
    ///
    /// - Documentation: [LATENCY GRAPH](https:/redis.io/docs/latest/commands/latency-graph)
    /// - Version: 2.8.13
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): Latency graph
    @inlinable
    public func latencyGraph(event: String) async throws -> String {
        try await send(command: LATENCY.GRAPH(event: event))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [LATENCY HELP](https:/redis.io/docs/latest/commands/latency-help)
    /// - Version: 2.8.13
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func latencyHelp() async throws -> [RESPToken] {
        try await send(command: LATENCY.HELP())
    }

    /// Returns the cumulative distribution of latencies of a subset or all commands.
    ///
    /// - Documentation: [LATENCY HISTOGRAM](https:/redis.io/docs/latest/commands/latency-histogram)
    /// - Version: 7.0.0
    /// - Complexity: O(N) where N is the number of commands with latency information being retrieved.
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Map](https:/redis.io/docs/reference/protocol-spec#maps): a map where each key is a command name, and each value is a map with the total calls, and an inner map of the histogram time buckets.
    @inlinable
    public func latencyHistogram(command: [String] = []) async throws -> [String: RESPToken] {
        try await send(command: LATENCY.HISTOGRAM(command: command))
    }

    /// Returns timestamp-latency samples for an event.
    ///
    /// - Documentation: [LATENCY HISTORY](https:/redis.io/docs/latest/commands/latency-history)
    /// - Version: 2.8.13
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): an array where each element is a two elements array representing the timestamp and the latency of the event.
    @inlinable
    public func latencyHistory(event: String) async throws -> [RESPToken] {
        try await send(command: LATENCY.HISTORY(event: event))
    }

    /// Returns the latest latency samples for all events.
    ///
    /// - Documentation: [LATENCY LATEST](https:/redis.io/docs/latest/commands/latency-latest)
    /// - Version: 2.8.13
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): an array where each element is a four elements array representing the event's name, timestamp, latest and all-time latency measurements.
    @inlinable
    public func latencyLatest() async throws -> [RESPToken] {
        try await send(command: LATENCY.LATEST())
    }

    /// Resets the latency data for one or more events.
    ///
    /// - Documentation: [LATENCY RESET](https:/redis.io/docs/latest/commands/latency-reset)
    /// - Version: 2.8.13
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of event time series that were reset.
    @inlinable
    public func latencyReset(event: [String] = []) async throws -> Int {
        try await send(command: LATENCY.RESET(event: event))
    }

    /// Displays computer art and the Redis version
    ///
    /// - Documentation: [LOLWUT](https:/redis.io/docs/latest/commands/lolwut)
    /// - Version: 5.0.0
    /// - Categories: @read, @fast
    /// - Returns: [Verbatim string](https:/redis.io/docs/reference/protocol-spec#verbatim-strings): a string containing generative computer art and the Redis version.
    @inlinable
    public func lolwut(version: Int? = nil) async throws -> String {
        try await send(command: LOLWUT(version: version))
    }

    /// Outputs a memory problems report.
    ///
    /// - Documentation: [MEMORY DOCTOR](https:/redis.io/docs/latest/commands/memory-doctor)
    /// - Version: 4.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Verbatim string](https:/redis.io/docs/reference/protocol-spec#verbatim-strings): a memory problems report.
    @inlinable
    public func memoryDoctor() async throws -> String {
        try await send(command: MEMORY.DOCTOR())
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [MEMORY HELP](https:/redis.io/docs/latest/commands/memory-help)
    /// - Version: 4.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func memoryHelp() async throws -> [RESPToken] {
        try await send(command: MEMORY.HELP())
    }

    /// Returns the allocator statistics.
    ///
    /// - Documentation: [MEMORY MALLOC-STATS](https:/redis.io/docs/latest/commands/memory-malloc-stats)
    /// - Version: 4.0.0
    /// - Complexity: Depends on how much memory is allocated, could be slow
    /// - Categories: @slow
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): The memory allocator's internal statistics report.
    @inlinable
    public func memoryMallocStats() async throws -> String {
        try await send(command: MEMORY.MALLOCSTATS())
    }

    /// Asks the allocator to release memory.
    ///
    /// - Documentation: [MEMORY PURGE](https:/redis.io/docs/latest/commands/memory-purge)
    /// - Version: 4.0.0
    /// - Complexity: Depends on how much memory is allocated, could be slow
    /// - Categories: @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func memoryPurge() async throws -> RESPToken {
        try await send(command: MEMORY.PURGE())
    }

    /// Returns details about memory usage.
    ///
    /// - Documentation: [MEMORY STATS](https:/redis.io/docs/latest/commands/memory-stats)
    /// - Version: 4.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Map](https:/redis.io/docs/reference/protocol-spec#maps): memory usage metrics and their values.
    @inlinable
    public func memoryStats() async throws -> [String: RESPToken] {
        try await send(command: MEMORY.STATS())
    }

    /// Estimates the memory usage of a key.
    ///
    /// - Documentation: [MEMORY USAGE](https:/redis.io/docs/latest/commands/memory-usage)
    /// - Version: 4.0.0
    /// - Complexity: O(N) where N is the number of samples.
    /// - Categories: @read, @slow
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the memory usage in bytes.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key does not exist.
    @inlinable
    public func memoryUsage(key: RESPKey, count: Int? = nil) async throws -> Int? {
        try await send(command: MEMORY.USAGE(key: key, count: count))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [MODULE HELP](https:/redis.io/docs/latest/commands/module-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions
    @inlinable
    public func moduleHelp() async throws -> [RESPToken] {
        try await send(command: MODULE.HELP())
    }

    /// Returns all loaded modules.
    ///
    /// - Documentation: [MODULE LIST](https:/redis.io/docs/latest/commands/module-list)
    /// - Version: 4.0.0
    /// - Complexity: O(N) where N is the number of loaded modules.
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): list of loaded modules. Each element in the list represents a represents a module, and is a [Map](https:/redis.io/docs/reference/protocol-spec#maps) of property names and their values. The following properties is reported for each loaded module:
    ///     * name: the name of the module.
    ///     * ver: the version of the module.
    @inlinable
    public func moduleList() async throws -> [RESPToken] {
        try await send(command: MODULE.LIST())
    }

    /// Loads a module.
    ///
    /// - Documentation: [MODULE LOAD](https:/redis.io/docs/latest/commands/module-load)
    /// - Version: 4.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the module was loaded.
    @inlinable
    public func moduleLoad(path: String, arg: [String] = []) async throws -> RESPToken {
        try await send(command: MODULE.LOAD(path: path, arg: arg))
    }

    /// Loads a module using extended parameters.
    ///
    /// - Documentation: [MODULE LOADEX](https:/redis.io/docs/latest/commands/module-loadex)
    /// - Version: 7.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the module was loaded.
    @inlinable
    public func moduleLoadex(path: String, configs: [MODULE.LOADEX.Configs] = [], args: [String] = []) async throws -> RESPToken {
        try await send(command: MODULE.LOADEX(path: path, configs: configs, args: args))
    }

    /// Unloads a module.
    ///
    /// - Documentation: [MODULE UNLOAD](https:/redis.io/docs/latest/commands/module-unload)
    /// - Version: 4.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if the module was unloaded.
    @inlinable
    public func moduleUnload(name: String) async throws -> RESPToken {
        try await send(command: MODULE.UNLOAD(name: name))
    }

    /// Listens for all requests received by the server in real-time.
    ///
    /// - Documentation: [MONITOR](https:/redis.io/docs/latest/commands/monitor)
    /// - Version: 1.0.0
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: **Non-standard return value**. Dumps the received commands in an infinite flow.
    @inlinable
    public func monitor() async throws -> RESPToken {
        try await send(command: MONITOR())
    }

    /// An internal command used in replication.
    ///
    /// - Documentation: [PSYNC](https:/redis.io/docs/latest/commands/psync)
    /// - Version: 2.8.0
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: **Non-standard return value**, a bulk transfer of the data followed by `PING` and write requests from the master.
    @inlinable
    public func psync(replicationid: String, offset: Int) async throws -> RESPToken {
        try await send(command: PSYNC(replicationid: replicationid, offset: offset))
    }

    /// An internal command for configuring the replication stream.
    ///
    /// - Documentation: [REPLCONF](https:/redis.io/docs/latest/commands/replconf)
    /// - Version: 3.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func replconf() async throws -> RESPToken {
        try await send(command: REPLCONF())
    }

    /// Configures a server as replica of another, or promotes it to a master.
    ///
    /// - Documentation: [REPLICAOF](https:/redis.io/docs/latest/commands/replicaof)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func replicaof(args: REPLICAOF.Args) async throws -> RESPToken {
        try await send(command: REPLICAOF(args: args))
    }

    /// An internal command for migrating keys in a cluster.
    ///
    /// - Documentation: [RESTORE-ASKING](https:/redis.io/docs/latest/commands/restore-asking)
    /// - Version: 3.0.0
    /// - Complexity: O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N)).
    /// - Categories: @keyspace, @write, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func restoreAsking(key: RESPKey, ttl: Int, serializedValue: String, replace: Bool = false, absttl: Bool = false, seconds: Int? = nil, frequency: Int? = nil) async throws -> RESPToken {
        try await send(command: RESTOREASKING(key: key, ttl: ttl, serializedValue: serializedValue, replace: replace, absttl: absttl, seconds: seconds, frequency: frequency))
    }

    /// Returns the replication role.
    ///
    /// - Documentation: [ROLE](https:/redis.io/docs/latest/commands/role)
    /// - Version: 2.8.12
    /// - Complexity: O(1)
    /// - Categories: @admin, @fast, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): where the first element is one of `master`, `slave`, or `sentinel`, and the additional elements are role-specific as illustrated above.
    @inlinable
    public func role() async throws -> [RESPToken] {
        try await send(command: ROLE())
    }

    /// Synchronously saves the database(s) to disk.
    ///
    /// - Documentation: [SAVE](https:/redis.io/docs/latest/commands/save)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the total number of keys in all databases
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func save() async throws -> RESPToken {
        try await send(command: SAVE())
    }

    /// Synchronously saves the database(s) to disk and shuts down the Redis server.
    ///
    /// - Documentation: [SHUTDOWN](https:/redis.io/docs/latest/commands/shutdown)
    /// - Version: 1.0.0
    /// - Complexity: O(N) when saving, where N is the total number of keys in all databases when saving data, otherwise O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` if _ABORT_ was specified and shutdown was aborted. On successful shutdown, nothing is returned because the server quits and the connection is closed. On failure, an error is returned.
    @inlinable
    public func shutdown(saveSelector: SHUTDOWN.SaveSelector? = nil, now: Bool = false, force: Bool = false, abort: Bool = false) async throws -> RESPToken {
        try await send(command: SHUTDOWN(saveSelector: saveSelector, now: now, force: force, abort: abort))
    }

    /// Sets a Redis server as a replica of another, or promotes it to being a master.
    ///
    /// - Documentation: [SLAVEOF](https:/redis.io/docs/latest/commands/slaveof)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func slaveof(args: SLAVEOF.Args) async throws -> RESPToken {
        try await send(command: SLAVEOF(args: args))
    }

    /// Returns the slow log's entries.
    ///
    /// - Documentation: [SLOWLOG GET](https:/redis.io/docs/latest/commands/slowlog-get)
    /// - Version: 2.2.12
    /// - Complexity: O(N) where N is the number of entries returned
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of slow log entries per the above format.
    @inlinable
    public func slowlogGet(count: Int? = nil) async throws -> [RESPToken] {
        try await send(command: SLOWLOG.GET(count: count))
    }

    /// Show helpful text about the different subcommands
    ///
    /// - Documentation: [SLOWLOG HELP](https:/redis.io/docs/latest/commands/slowlog-help)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func slowlogHelp() async throws -> [RESPToken] {
        try await send(command: SLOWLOG.HELP())
    }

    /// Returns the number of entries in the slow log.
    ///
    /// - Documentation: [SLOWLOG LEN](https:/redis.io/docs/latest/commands/slowlog-len)
    /// - Version: 2.2.12
    /// - Complexity: O(1)
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of entries in the slow log.
    @inlinable
    public func slowlogLen() async throws -> Int {
        try await send(command: SLOWLOG.LEN())
    }

    /// Clears all entries from the slow log.
    ///
    /// - Documentation: [SLOWLOG RESET](https:/redis.io/docs/latest/commands/slowlog-reset)
    /// - Version: 2.2.12
    /// - Complexity: O(N) where N is the number of entries in the slowlog
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func slowlogReset() async throws -> RESPToken {
        try await send(command: SLOWLOG.RESET())
    }

    /// Swaps two Redis databases.
    ///
    /// - Documentation: [SWAPDB](https:/redis.io/docs/latest/commands/swapdb)
    /// - Version: 4.0.0
    /// - Complexity: O(N) where N is the count of clients watching or blocking on keys from both databases.
    /// - Categories: @keyspace, @write, @fast, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func swapdb(index1: Int, index2: Int) async throws -> RESPToken {
        try await send(command: SWAPDB(index1: index1, index2: index2))
    }

    /// An internal command used in replication.
    ///
    /// - Documentation: [SYNC](https:/redis.io/docs/latest/commands/sync)
    /// - Version: 1.0.0
    /// - Categories: @admin, @slow, @dangerous
    /// - Returns: **Non-standard return value**, a bulk transfer of the data followed by `PING` and write requests from the master.
    @inlinable
    public func sync() async throws -> RESPToken {
        try await send(command: SYNC())
    }

    /// Returns the server time.
    ///
    /// - Documentation: [TIME](https:/redis.io/docs/latest/commands/time)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @fast
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): specifically, a two-element array consisting of the Unix timestamp in seconds and the microseconds' count.
    @inlinable
    public func time() async throws -> [RESPToken] {
        try await send(command: TIME())
    }

}
