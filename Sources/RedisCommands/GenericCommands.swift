//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2023 Apple Inc. and the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import RESP
import Redis

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension RESPCommand {
    /// Copies the value of a key to a new key.
    ///
    /// - Documentation: [COPY](https:/redis.io/docs/latest/commands/copy)
    /// - Version: 6.2.0
    /// - Complexity: O(N) worst case for collections, where N is the number of nested items. O(1) for string values.
    /// - Categories: @keyspace, @write, @slow
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if _source_ was copied.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if _source_ was not copied.
    @inlinable
    public static func copy(source: RedisKey, destination: RedisKey, destinationDb: Int? = nil, replace: Bool = false) -> RESPCommand {
        RESPCommand("COPY", source, destination, RESPWithToken("DB", destinationDb), RedisPureToken("REPLACE", replace))
    }

    /// Deletes one or more keys.
    ///
    /// - Documentation: [DEL](https:/redis.io/docs/latest/commands/del)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).
    /// - Categories: @keyspace, @write, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that were removed.
    @inlinable
    public static func del(key: RedisKey) -> RESPCommand {
        RESPCommand("DEL", key)
    }

    /// Deletes one or more keys.
    ///
    /// - Documentation: [DEL](https:/redis.io/docs/latest/commands/del)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).
    /// - Categories: @keyspace, @write, @slow
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that were removed.
    @inlinable
    public static func del(keys: [RedisKey]) -> RESPCommand {
        RESPCommand("DEL", keys)
    }

    /// Returns a serialized representation of the value stored at a key.
    ///
    /// - Documentation: [DUMP](https:/redis.io/docs/latest/commands/dump)
    /// - Version: 2.6.0
    /// - Complexity: O(1) to access the key and additional O(N*M) to serialize it, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1).
    /// - Categories: @keyspace, @read, @slow
    /// - Response: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the serialized value of the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): the key does not exist.
    @inlinable
    public static func dump(key: RedisKey) -> RESPCommand {
        RESPCommand("DUMP", key)
    }

    /// Determines whether one or more keys exist.
    ///
    /// - Documentation: [EXISTS](https:/redis.io/docs/latest/commands/exists)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys to check.
    /// - Categories: @keyspace, @read, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that exist from those specified as arguments.
    @inlinable
    public static func exists(key: RedisKey) -> RESPCommand {
        RESPCommand("EXISTS", key)
    }

    /// Determines whether one or more keys exist.
    ///
    /// - Documentation: [EXISTS](https:/redis.io/docs/latest/commands/exists)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys to check.
    /// - Categories: @keyspace, @read, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that exist from those specified as arguments.
    @inlinable
    public static func exists(keys: [RedisKey]) -> RESPCommand {
        RESPCommand("EXISTS", keys)
    }

    public enum EXPIRECondition: RESPRenderable {
        case nx
        case xx
        case gt
        case lt

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .nx: "NX".writeToRESPBuffer(&buffer)
            case .xx: "XX".writeToRESPBuffer(&buffer)
            case .gt: "GT".writeToRESPBuffer(&buffer)
            case .lt: "LT".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Sets the expiration time of a key in seconds.
    ///
    /// - Documentation: [EXPIRE](https:/redis.io/docs/latest/commands/expire)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the timeout was not set; for example, the key doesn't exist, or the operation was skipped because of the provided arguments.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the timeout was set.
    @inlinable
    public static func expire(key: RedisKey, seconds: Int, condition: EXPIRECondition? = nil) -> RESPCommand {
        RESPCommand("EXPIRE", key, seconds, condition)
    }

    public enum EXPIREATCondition: RESPRenderable {
        case nx
        case xx
        case gt
        case lt

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .nx: "NX".writeToRESPBuffer(&buffer)
            case .xx: "XX".writeToRESPBuffer(&buffer)
            case .gt: "GT".writeToRESPBuffer(&buffer)
            case .lt: "LT".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Sets the expiration time of a key to a Unix timestamp.
    ///
    /// - Documentation: [EXPIREAT](https:/redis.io/docs/latest/commands/expireat)
    /// - Version: 1.2.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the timeout was not set; for example, the key doesn't exist, or the operation was skipped because of the provided arguments.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the timeout was set.
    @inlinable
    public static func expireat(key: RedisKey, unixTimeSeconds: Date, condition: EXPIREATCondition? = nil) -> RESPCommand {
        RESPCommand("EXPIREAT", key, Int(unixTimeSeconds.timeIntervalSince1970), condition)
    }

    /// Returns the expiration time of a key as a Unix timestamp.
    ///
    /// - Documentation: [EXPIRETIME](https:/redis.io/docs/latest/commands/expiretime)
    /// - Version: 7.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the expiration Unix timestamp in seconds.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if the key exists but has no associated expiration time.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-2` if the key does not exist.
    @inlinable
    public static func expiretime(key: RedisKey) -> RESPCommand {
        RESPCommand("EXPIRETIME", key)
    }

    /// Returns all key names that match a pattern.
    ///
    /// - Documentation: [KEYS](https:/redis.io/docs/latest/commands/keys)
    /// - Version: 1.0.0
    /// - Complexity: O(N) with N being the number of keys in the database, under the assumption that the key names in the database and the given pattern have limited length.
    /// - Categories: @keyspace, @read, @slow, @dangerous
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of keys matching _pattern_.
    @inlinable
    public static func keys(pattern: String) -> RESPCommand {
        RESPCommand("KEYS", pattern)
    }

    public enum MIGRATEKeySelector: RESPRenderable {
        case key(RedisKey)
        case emptyString

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .key(let key): key.writeToRESPBuffer(&buffer)
            case .emptyString: "".writeToRESPBuffer(&buffer)
            }
        }
    }
    public struct MIGRATEAuthenticationAuth2: RESPRenderable {
        @usableFromInline let username: String
        @usableFromInline let password: String

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += username.writeToRESPBuffer(&buffer)
            count += password.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum MIGRATEAuthentication: RESPRenderable {
        case auth(String)
        case auth2(MIGRATEAuthenticationAuth2)

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .auth(let auth): RESPWithToken("AUTH", auth).writeToRESPBuffer(&buffer)
            case .auth2(let auth2): RESPWithToken("AUTH2", auth2).writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Atomically transfers a key from one Redis instance to another.
    ///
    /// - Documentation: [MIGRATE](https:/redis.io/docs/latest/commands/migrate)
    /// - Version: 2.6.0
    /// - Complexity: This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed.
    /// - Categories: @keyspace, @write, @slow, @dangerous
    /// - Response: One of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` on success.
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `NOKEY` when no keys were found in the source instance.
    @inlinable
    public static func migrate(host: String, port: Int, keySelector: MIGRATEKeySelector, destinationDb: Int, timeout: Int, copy: Bool = false, replace: Bool = false, authentication: MIGRATEAuthentication? = nil, keys: RedisKey? = nil) -> RESPCommand {
        RESPCommand("MIGRATE", host, port, keySelector, destinationDb, timeout, RedisPureToken("COPY", copy), RedisPureToken("REPLACE", replace), authentication, RESPWithToken("KEYS", keys))
    }

    /// Atomically transfers a key from one Redis instance to another.
    ///
    /// - Documentation: [MIGRATE](https:/redis.io/docs/latest/commands/migrate)
    /// - Version: 2.6.0
    /// - Complexity: This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed.
    /// - Categories: @keyspace, @write, @slow, @dangerous
    /// - Response: One of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` on success.
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `NOKEY` when no keys were found in the source instance.
    @inlinable
    public static func migrate(host: String, port: Int, keySelector: MIGRATEKeySelector, destinationDb: Int, timeout: Int, copy: Bool = false, replace: Bool = false, authentication: MIGRATEAuthentication? = nil, keyss: [RedisKey]) -> RESPCommand {
        RESPCommand("MIGRATE", host, port, keySelector, destinationDb, timeout, RedisPureToken("COPY", copy), RedisPureToken("REPLACE", replace), authentication, RESPWithToken("KEYS", keyss))
    }

    /// Moves a key to another database.
    ///
    /// - Documentation: [MOVE](https:/redis.io/docs/latest/commands/move)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if _key_ was moved.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if _key_ wasn't moved.
    @inlinable
    public static func move(key: RedisKey, db: Int) -> RESPCommand {
        RESPCommand("MOVE", key, db)
    }

    /// Returns the internal encoding of a Redis object.
    ///
    /// - Documentation: [OBJECT ENCODING](https:/redis.io/docs/latest/commands/object-encoding)
    /// - Version: 2.2.3
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @slow
    /// - Response: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key doesn't exist.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the encoding of the object.
    @inlinable
    public static func objectEncoding(key: RedisKey) -> RESPCommand {
        RESPCommand("OBJECT", "ENCODING", key)
    }

    /// Returns the logarithmic access frequency counter of a Redis object.
    ///
    /// - Documentation: [OBJECT FREQ](https:/redis.io/docs/latest/commands/object-freq)
    /// - Version: 4.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @slow
    /// - Response: One of the following:
    ///     [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the counter's value.
    ///     [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if _key_ doesn't exist.
    @inlinable
    public static func objectFreq(key: RedisKey) -> RESPCommand {
        RESPCommand("OBJECT", "FREQ", key)
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [OBJECT HELP](https:/redis.io/docs/latest/commands/object-help)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public static func objectHelp() -> RESPCommand {
        RESPCommand("OBJECT", "HELP")
    }

    /// Returns the time since the last access to a Redis object.
    ///
    /// - Documentation: [OBJECT IDLETIME](https:/redis.io/docs/latest/commands/object-idletime)
    /// - Version: 2.2.3
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @slow
    /// - Response: One of the following:
    ///     [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the idle time in seconds.
    ///     [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if _key_ doesn't exist.
    @inlinable
    public static func objectIdletime(key: RedisKey) -> RESPCommand {
        RESPCommand("OBJECT", "IDLETIME", key)
    }

    /// Returns the reference count of a value of a key.
    ///
    /// - Documentation: [OBJECT REFCOUNT](https:/redis.io/docs/latest/commands/object-refcount)
    /// - Version: 2.2.3
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @slow
    /// - Response: One of the following:
    ///     [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of references.
    ///     [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if _key_ doesn't exist.
    @inlinable
    public static func objectRefcount(key: RedisKey) -> RESPCommand {
        RESPCommand("OBJECT", "REFCOUNT", key)
    }

    /// Removes the expiration time of a key.
    ///
    /// - Documentation: [PERSIST](https:/redis.io/docs/latest/commands/persist)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if _key_ does not exist or does not have an associated timeout.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the timeout has been removed.
    @inlinable
    public static func persist(key: RedisKey) -> RESPCommand {
        RESPCommand("PERSIST", key)
    }

    public enum PEXPIRECondition: RESPRenderable {
        case nx
        case xx
        case gt
        case lt

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .nx: "NX".writeToRESPBuffer(&buffer)
            case .xx: "XX".writeToRESPBuffer(&buffer)
            case .gt: "GT".writeToRESPBuffer(&buffer)
            case .lt: "LT".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Sets the expiration time of a key in milliseconds.
    ///
    /// - Documentation: [PEXPIRE](https:/redis.io/docs/latest/commands/pexpire)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0`if the timeout was not set. For example, if the key doesn't exist, or the operation skipped because of the provided arguments.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the timeout was set.
    @inlinable
    public static func pexpire(key: RedisKey, milliseconds: Int, condition: PEXPIRECondition? = nil) -> RESPCommand {
        RESPCommand("PEXPIRE", key, milliseconds, condition)
    }

    public enum PEXPIREATCondition: RESPRenderable {
        case nx
        case xx
        case gt
        case lt

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .nx: "NX".writeToRESPBuffer(&buffer)
            case .xx: "XX".writeToRESPBuffer(&buffer)
            case .gt: "GT".writeToRESPBuffer(&buffer)
            case .lt: "LT".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Sets the expiration time of a key to a Unix milliseconds timestamp.
    ///
    /// - Documentation: [PEXPIREAT](https:/redis.io/docs/latest/commands/pexpireat)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the timeout was set.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the timeout was not set. For example, if the key doesn't exist, or the operation was skipped due to the provided arguments.
    @inlinable
    public static func pexpireat(key: RedisKey, unixTimeMilliseconds: Date, condition: PEXPIREATCondition? = nil) -> RESPCommand {
        RESPCommand("PEXPIREAT", key, Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000), condition)
    }

    /// Returns the expiration time of a key as a Unix milliseconds timestamp.
    ///
    /// - Documentation: [PEXPIRETIME](https:/redis.io/docs/latest/commands/pexpiretime)
    /// - Version: 7.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): Expiration Unix timestamp in milliseconds.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if the key exists but has no associated expiration time.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-2` if the key does not exist.
    @inlinable
    public static func pexpiretime(key: RedisKey) -> RESPCommand {
        RESPCommand("PEXPIRETIME", key)
    }

    /// Returns the expiration time in milliseconds of a key.
    ///
    /// - Documentation: [PTTL](https:/redis.io/docs/latest/commands/pttl)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): TTL in milliseconds.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if the key exists but has no associated expiration.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-2` if the key does not exist.
    @inlinable
    public static func pttl(key: RedisKey) -> RESPCommand {
        RESPCommand("PTTL", key)
    }

    /// Returns a random key name from the database.
    ///
    /// - Documentation: [RANDOMKEY](https:/redis.io/docs/latest/commands/randomkey)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @slow
    /// - Response: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): when the database is empty.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): a random key in the database.
    @inlinable
    public static func randomkey() -> RESPCommand {
        RESPCommand("RANDOMKEY")
    }

    /// Renames a key and overwrites the destination.
    ///
    /// - Documentation: [RENAME](https:/redis.io/docs/latest/commands/rename)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @slow
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func rename(key: RedisKey, newkey: RedisKey) -> RESPCommand {
        RESPCommand("RENAME", key, newkey)
    }

    /// Renames a key only when the target key name doesn't exist.
    ///
    /// - Documentation: [RENAMENX](https:/redis.io/docs/latest/commands/renamenx)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if _key_ was renamed to _newkey_.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if _newkey_ already exists.
    @inlinable
    public static func renamenx(key: RedisKey, newkey: RedisKey) -> RESPCommand {
        RESPCommand("RENAMENX", key, newkey)
    }

    /// Creates a key from the serialized representation of a value.
    ///
    /// - Documentation: [RESTORE](https:/redis.io/docs/latest/commands/restore)
    /// - Version: 2.6.0
    /// - Complexity: O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N)).
    /// - Categories: @keyspace, @write, @slow, @dangerous
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public static func restore(key: RedisKey, ttl: Int, serializedValue: String, replace: Bool = false, absttl: Bool = false, seconds: Int? = nil, frequency: Int? = nil) -> RESPCommand {
        RESPCommand("RESTORE", key, ttl, serializedValue, RedisPureToken("REPLACE", replace), RedisPureToken("ABSTTL", absttl), RESPWithToken("IDLETIME", seconds), RESPWithToken("FREQ", frequency))
    }

    /// Iterates over the key names in the database.
    ///
    /// - Documentation: [SCAN](https:/redis.io/docs/latest/commands/scan)
    /// - Version: 2.8.0
    /// - Complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.
    /// - Categories: @keyspace, @read, @slow
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): specifically, an array with two elements.
    ///     * The first element is a [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings) that represents an unsigned 64-bit number, the cursor.
    ///     * The second element is an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) with the names of scanned keys.
    @inlinable
    public static func scan(cursor: Int, pattern: String? = nil, count: Int? = nil, type: String? = nil) -> RESPCommand {
        RESPCommand("SCAN", cursor, RESPWithToken("MATCH", pattern), RESPWithToken("COUNT", count), RESPWithToken("TYPE", type))
    }

    public struct SORTLimit: RESPRenderable {
        @usableFromInline let offset: Int
        @usableFromInline let count: Int

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += offset.writeToRESPBuffer(&buffer)
            count += count.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum SORTOrder: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .asc: "ASC".writeToRESPBuffer(&buffer)
            case .desc: "DESC".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Sorts the elements in a list, a set, or a sorted set, optionally storing the result.
    ///
    /// - Documentation: [SORT](https:/redis.io/docs/latest/commands/sort)
    /// - Version: 1.0.0
    /// - Complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
    /// - Categories: @write, @set, @sortedset, @list, @slow, @dangerous
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): without passing the _STORE_ option, the command returns a list of sorted elements.
    ///     [Integer](https:/redis.io/docs/reference/protocol-spec#integers): when the _STORE_ option is specified, the command returns the number of sorted elements in the destination list.
    @inlinable
    public static func sort(key: RedisKey, byPattern: String? = nil, limit: SORTLimit? = nil, getPattern: String? = nil, order: SORTOrder? = nil, sorting: Bool = false, destination: RedisKey? = nil) -> RESPCommand {
        RESPCommand("SORT", key, RESPWithToken("BY", byPattern), RESPWithToken("LIMIT", limit), RESPWithToken("GET", getPattern), order, RedisPureToken("ALPHA", sorting), RESPWithToken("STORE", destination))
    }

    /// Sorts the elements in a list, a set, or a sorted set, optionally storing the result.
    ///
    /// - Documentation: [SORT](https:/redis.io/docs/latest/commands/sort)
    /// - Version: 1.0.0
    /// - Complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
    /// - Categories: @write, @set, @sortedset, @list, @slow, @dangerous
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): without passing the _STORE_ option, the command returns a list of sorted elements.
    ///     [Integer](https:/redis.io/docs/reference/protocol-spec#integers): when the _STORE_ option is specified, the command returns the number of sorted elements in the destination list.
    @inlinable
    public static func sort(key: RedisKey, byPattern: String? = nil, limit: SORTLimit? = nil, getPatterns: [String], order: SORTOrder? = nil, sorting: Bool = false, destination: RedisKey? = nil) -> RESPCommand {
        RESPCommand("SORT", key, RESPWithToken("BY", byPattern), RESPWithToken("LIMIT", limit), RESPWithToken("GET", getPatterns), order, RedisPureToken("ALPHA", sorting), RESPWithToken("STORE", destination))
    }

    public struct SORTROLimit: RESPRenderable {
        @usableFromInline let offset: Int
        @usableFromInline let count: Int

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            var count = 0
            count += offset.writeToRESPBuffer(&buffer)
            count += count.writeToRESPBuffer(&buffer)
            return count
        }
    }
    public enum SORTROOrder: RESPRenderable {
        case asc
        case desc

        @inlinable
        public func writeToRESPBuffer(_ buffer: inout ByteBuffer) -> Int {
            switch self {
            case .asc: "ASC".writeToRESPBuffer(&buffer)
            case .desc: "DESC".writeToRESPBuffer(&buffer)
            }
        }
    }
    /// Returns the sorted elements of a list, a set, or a sorted set.
    ///
    /// - Documentation: [SORT_RO](https:/redis.io/docs/latest/commands/sort_ro)
    /// - Version: 7.0.0
    /// - Complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
    /// - Categories: @read, @set, @sortedset, @list, @slow, @dangerous
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sorted elements.
    @inlinable
    public static func sortRo(key: RedisKey, byPattern: String? = nil, limit: SORTROLimit? = nil, getPattern: String? = nil, order: SORTROOrder? = nil, sorting: Bool = false) -> RESPCommand {
        RESPCommand("SORT_RO", key, RESPWithToken("BY", byPattern), RESPWithToken("LIMIT", limit), RESPWithToken("GET", getPattern), order, RedisPureToken("ALPHA", sorting))
    }

    /// Returns the sorted elements of a list, a set, or a sorted set.
    ///
    /// - Documentation: [SORT_RO](https:/redis.io/docs/latest/commands/sort_ro)
    /// - Version: 7.0.0
    /// - Complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
    /// - Categories: @read, @set, @sortedset, @list, @slow, @dangerous
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sorted elements.
    @inlinable
    public static func sortRo(key: RedisKey, byPattern: String? = nil, limit: SORTROLimit? = nil, getPatterns: [String], order: SORTROOrder? = nil, sorting: Bool = false) -> RESPCommand {
        RESPCommand("SORT_RO", key, RESPWithToken("BY", byPattern), RESPWithToken("LIMIT", limit), RESPWithToken("GET", getPatterns), order, RedisPureToken("ALPHA", sorting))
    }

    /// Returns the number of existing keys out of those specified after updating the time they were last accessed.
    ///
    /// - Documentation: [TOUCH](https:/redis.io/docs/latest/commands/touch)
    /// - Version: 3.2.1
    /// - Complexity: O(N) where N is the number of keys that will be touched.
    /// - Categories: @keyspace, @read, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of touched keys.
    @inlinable
    public static func touch(key: RedisKey) -> RESPCommand {
        RESPCommand("TOUCH", key)
    }

    /// Returns the number of existing keys out of those specified after updating the time they were last accessed.
    ///
    /// - Documentation: [TOUCH](https:/redis.io/docs/latest/commands/touch)
    /// - Version: 3.2.1
    /// - Complexity: O(N) where N is the number of keys that will be touched.
    /// - Categories: @keyspace, @read, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of touched keys.
    @inlinable
    public static func touch(keys: [RedisKey]) -> RESPCommand {
        RESPCommand("TOUCH", keys)
    }

    /// Returns the expiration time in seconds of a key.
    ///
    /// - Documentation: [TTL](https:/redis.io/docs/latest/commands/ttl)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Response: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): TTL in seconds.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if the key exists but has no associated expiration.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-2` if the key does not exist.
    @inlinable
    public static func ttl(key: RedisKey) -> RESPCommand {
        RESPCommand("TTL", key)
    }

    /// Determines the type of value stored at a key.
    ///
    /// - Documentation: [TYPE](https:/redis.io/docs/latest/commands/type)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Response: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): the type of _key_, or `none` when _key_ doesn't exist.
    @inlinable
    public static func type(key: RedisKey) -> RESPCommand {
        RESPCommand("TYPE", key)
    }

    /// Asynchronously deletes one or more keys.
    ///
    /// - Documentation: [UNLINK](https:/redis.io/docs/latest/commands/unlink)
    /// - Version: 4.0.0
    /// - Complexity: O(1) for each key removed regardless of its size. Then the command does O(N) work in a different thread in order to reclaim memory, where N is the number of allocations the deleted objects where composed of.
    /// - Categories: @keyspace, @write, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that were unlinked.
    @inlinable
    public static func unlink(key: RedisKey) -> RESPCommand {
        RESPCommand("UNLINK", key)
    }

    /// Asynchronously deletes one or more keys.
    ///
    /// - Documentation: [UNLINK](https:/redis.io/docs/latest/commands/unlink)
    /// - Version: 4.0.0
    /// - Complexity: O(1) for each key removed regardless of its size. Then the command does O(N) work in a different thread in order to reclaim memory, where N is the number of allocations the deleted objects where composed of.
    /// - Categories: @keyspace, @write, @fast
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that were unlinked.
    @inlinable
    public static func unlink(keys: [RedisKey]) -> RESPCommand {
        RESPCommand("UNLINK", keys)
    }

    /// Blocks until the asynchronous replication of all preceding write commands sent by the connection is completed.
    ///
    /// - Documentation: [WAIT](https:/redis.io/docs/latest/commands/wait)
    /// - Version: 3.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of replicas reached by all the writes performed in the context of the current connection.
    @inlinable
    public static func wait(numreplicas: Int, timeout: Int) -> RESPCommand {
        RESPCommand("WAIT", numreplicas, timeout)
    }

    /// Blocks until all of the preceding write commands sent by the connection are written to the append-only file of the master and/or replicas.
    ///
    /// - Documentation: [WAITAOF](https:/redis.io/docs/latest/commands/waitaof)
    /// - Version: 7.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Response: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): The command returns an array of two integers:
    ///     1. The first is the number of local Redises (0 or 1) that have fsynced to AOF  all writes performed in the context of the current connection
    ///     2. The second is the number of replicas that have acknowledged doing the same.
    @inlinable
    public static func waitaof(numlocal: Int, numreplicas: Int, timeout: Int) -> RESPCommand {
        RESPCommand("WAITAOF", numlocal, numreplicas, timeout)
    }

}

extension RedisConnection {
    /// Copies the value of a key to a new key.
    ///
    /// - Documentation: [COPY](https:/redis.io/docs/latest/commands/copy)
    /// - Version: 6.2.0
    /// - Complexity: O(N) worst case for collections, where N is the number of nested items. O(1) for string values.
    /// - Categories: @keyspace, @write, @slow
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if _source_ was copied.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if _source_ was not copied.
    @inlinable
    public func copy(source: RedisKey, destination: RedisKey, destinationDb: Int? = nil, replace: Bool = false) async throws -> Int {
        try await send("COPY", source, destination, RESPWithToken("DB", destinationDb), RedisPureToken("REPLACE", replace)).converting()
    }

    /// Deletes one or more keys.
    ///
    /// - Documentation: [DEL](https:/redis.io/docs/latest/commands/del)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).
    /// - Categories: @keyspace, @write, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that were removed.
    @inlinable
    public func del(key: RedisKey) async throws -> Int {
        try await send("DEL", key).converting()
    }

    /// Deletes one or more keys.
    ///
    /// - Documentation: [DEL](https:/redis.io/docs/latest/commands/del)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).
    /// - Categories: @keyspace, @write, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that were removed.
    @inlinable
    public func del(keys: [RedisKey]) async throws -> Int {
        try await send("DEL", keys).converting()
    }

    /// Returns a serialized representation of the value stored at a key.
    ///
    /// - Documentation: [DUMP](https:/redis.io/docs/latest/commands/dump)
    /// - Version: 2.6.0
    /// - Complexity: O(1) to access the key and additional O(N*M) to serialize it, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1).
    /// - Categories: @keyspace, @read, @slow
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the serialized value of the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): the key does not exist.
    @inlinable
    public func dump(key: RedisKey) async throws -> String? {
        try await send("DUMP", key).converting()
    }

    /// Determines whether one or more keys exist.
    ///
    /// - Documentation: [EXISTS](https:/redis.io/docs/latest/commands/exists)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys to check.
    /// - Categories: @keyspace, @read, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that exist from those specified as arguments.
    @inlinable
    public func exists(key: RedisKey) async throws -> Int {
        try await send("EXISTS", key).converting()
    }

    /// Determines whether one or more keys exist.
    ///
    /// - Documentation: [EXISTS](https:/redis.io/docs/latest/commands/exists)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys to check.
    /// - Categories: @keyspace, @read, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that exist from those specified as arguments.
    @inlinable
    public func exists(keys: [RedisKey]) async throws -> Int {
        try await send("EXISTS", keys).converting()
    }

    /// Sets the expiration time of a key in seconds.
    ///
    /// - Documentation: [EXPIRE](https:/redis.io/docs/latest/commands/expire)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the timeout was not set; for example, the key doesn't exist, or the operation was skipped because of the provided arguments.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the timeout was set.
    @inlinable
    public func expire(key: RedisKey, seconds: Int, condition: RESPCommand.EXPIRECondition? = nil) async throws -> Int {
        try await send("EXPIRE", key, seconds, condition).converting()
    }

    /// Sets the expiration time of a key to a Unix timestamp.
    ///
    /// - Documentation: [EXPIREAT](https:/redis.io/docs/latest/commands/expireat)
    /// - Version: 1.2.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the timeout was not set; for example, the key doesn't exist, or the operation was skipped because of the provided arguments.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the timeout was set.
    @inlinable
    public func expireat(key: RedisKey, unixTimeSeconds: Date, condition: RESPCommand.EXPIREATCondition? = nil) async throws -> Int {
        try await send("EXPIREAT", key, Int(unixTimeSeconds.timeIntervalSince1970), condition).converting()
    }

    /// Returns the expiration time of a key as a Unix timestamp.
    ///
    /// - Documentation: [EXPIRETIME](https:/redis.io/docs/latest/commands/expiretime)
    /// - Version: 7.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the expiration Unix timestamp in seconds.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if the key exists but has no associated expiration time.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-2` if the key does not exist.
    @inlinable
    public func expiretime(key: RedisKey) async throws -> Int {
        try await send("EXPIRETIME", key).converting()
    }

    /// Returns all key names that match a pattern.
    ///
    /// - Documentation: [KEYS](https:/redis.io/docs/latest/commands/keys)
    /// - Version: 1.0.0
    /// - Complexity: O(N) with N being the number of keys in the database, under the assumption that the key names in the database and the given pattern have limited length.
    /// - Categories: @keyspace, @read, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of keys matching _pattern_.
    @inlinable
    public func keys(pattern: String) async throws -> [RESPToken] {
        try await send("KEYS", pattern).converting()
    }

    /// Atomically transfers a key from one Redis instance to another.
    ///
    /// - Documentation: [MIGRATE](https:/redis.io/docs/latest/commands/migrate)
    /// - Version: 2.6.0
    /// - Complexity: This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed.
    /// - Categories: @keyspace, @write, @slow, @dangerous
    /// - Returns: One of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` on success.
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `NOKEY` when no keys were found in the source instance.
    @inlinable
    public func migrate(host: String, port: Int, keySelector: RESPCommand.MIGRATEKeySelector, destinationDb: Int, timeout: Int, copy: Bool = false, replace: Bool = false, authentication: RESPCommand.MIGRATEAuthentication? = nil, keys: RedisKey? = nil) async throws -> String? {
        try await send("MIGRATE", host, port, keySelector, destinationDb, timeout, RedisPureToken("COPY", copy), RedisPureToken("REPLACE", replace), authentication, RESPWithToken("KEYS", keys)).converting()
    }

    /// Atomically transfers a key from one Redis instance to another.
    ///
    /// - Documentation: [MIGRATE](https:/redis.io/docs/latest/commands/migrate)
    /// - Version: 2.6.0
    /// - Complexity: This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed.
    /// - Categories: @keyspace, @write, @slow, @dangerous
    /// - Returns: One of the following:
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK` on success.
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `NOKEY` when no keys were found in the source instance.
    @inlinable
    public func migrate(host: String, port: Int, keySelector: RESPCommand.MIGRATEKeySelector, destinationDb: Int, timeout: Int, copy: Bool = false, replace: Bool = false, authentication: RESPCommand.MIGRATEAuthentication? = nil, keyss: [RedisKey]) async throws -> String? {
        try await send("MIGRATE", host, port, keySelector, destinationDb, timeout, RedisPureToken("COPY", copy), RedisPureToken("REPLACE", replace), authentication, RESPWithToken("KEYS", keyss)).converting()
    }

    /// Moves a key to another database.
    ///
    /// - Documentation: [MOVE](https:/redis.io/docs/latest/commands/move)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if _key_ was moved.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if _key_ wasn't moved.
    @inlinable
    public func move(key: RedisKey, db: Int) async throws -> Int {
        try await send("MOVE", key, db).converting()
    }

    /// Returns the internal encoding of a Redis object.
    ///
    /// - Documentation: [OBJECT ENCODING](https:/redis.io/docs/latest/commands/object-encoding)
    /// - Version: 2.2.3
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @slow
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key doesn't exist.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the encoding of the object.
    @inlinable
    public func objectEncoding(key: RedisKey) async throws -> String? {
        try await send("OBJECT", "ENCODING", key).converting()
    }

    /// Returns the logarithmic access frequency counter of a Redis object.
    ///
    /// - Documentation: [OBJECT FREQ](https:/redis.io/docs/latest/commands/object-freq)
    /// - Version: 4.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @slow
    /// - Returns: One of the following:
    ///     [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the counter's value.
    ///     [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if _key_ doesn't exist.
    @inlinable
    public func objectFreq(key: RedisKey) async throws -> Int? {
        try await send("OBJECT", "FREQ", key).converting()
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [OBJECT HELP](https:/redis.io/docs/latest/commands/object-help)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func objectHelp() async throws -> [RESPToken] {
        try await send("OBJECT", "HELP").converting()
    }

    /// Returns the time since the last access to a Redis object.
    ///
    /// - Documentation: [OBJECT IDLETIME](https:/redis.io/docs/latest/commands/object-idletime)
    /// - Version: 2.2.3
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @slow
    /// - Returns: One of the following:
    ///     [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the idle time in seconds.
    ///     [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if _key_ doesn't exist.
    @inlinable
    public func objectIdletime(key: RedisKey) async throws -> Int? {
        try await send("OBJECT", "IDLETIME", key).converting()
    }

    /// Returns the reference count of a value of a key.
    ///
    /// - Documentation: [OBJECT REFCOUNT](https:/redis.io/docs/latest/commands/object-refcount)
    /// - Version: 2.2.3
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @slow
    /// - Returns: One of the following:
    ///     [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of references.
    ///     [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if _key_ doesn't exist.
    @inlinable
    public func objectRefcount(key: RedisKey) async throws -> Int? {
        try await send("OBJECT", "REFCOUNT", key).converting()
    }

    /// Removes the expiration time of a key.
    ///
    /// - Documentation: [PERSIST](https:/redis.io/docs/latest/commands/persist)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if _key_ does not exist or does not have an associated timeout.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the timeout has been removed.
    @inlinable
    public func persist(key: RedisKey) async throws -> Int {
        try await send("PERSIST", key).converting()
    }

    /// Sets the expiration time of a key in milliseconds.
    ///
    /// - Documentation: [PEXPIRE](https:/redis.io/docs/latest/commands/pexpire)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0`if the timeout was not set. For example, if the key doesn't exist, or the operation skipped because of the provided arguments.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the timeout was set.
    @inlinable
    public func pexpire(key: RedisKey, milliseconds: Int, condition: RESPCommand.PEXPIRECondition? = nil) async throws -> Int {
        try await send("PEXPIRE", key, milliseconds, condition).converting()
    }

    /// Sets the expiration time of a key to a Unix milliseconds timestamp.
    ///
    /// - Documentation: [PEXPIREAT](https:/redis.io/docs/latest/commands/pexpireat)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the timeout was set.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the timeout was not set. For example, if the key doesn't exist, or the operation was skipped due to the provided arguments.
    @inlinable
    public func pexpireat(key: RedisKey, unixTimeMilliseconds: Date, condition: RESPCommand.PEXPIREATCondition? = nil) async throws -> Int {
        try await send("PEXPIREAT", key, Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000), condition).converting()
    }

    /// Returns the expiration time of a key as a Unix milliseconds timestamp.
    ///
    /// - Documentation: [PEXPIRETIME](https:/redis.io/docs/latest/commands/pexpiretime)
    /// - Version: 7.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): Expiration Unix timestamp in milliseconds.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if the key exists but has no associated expiration time.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-2` if the key does not exist.
    @inlinable
    public func pexpiretime(key: RedisKey) async throws -> Int {
        try await send("PEXPIRETIME", key).converting()
    }

    /// Returns the expiration time in milliseconds of a key.
    ///
    /// - Documentation: [PTTL](https:/redis.io/docs/latest/commands/pttl)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): TTL in milliseconds.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if the key exists but has no associated expiration.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-2` if the key does not exist.
    @inlinable
    public func pttl(key: RedisKey) async throws -> Int {
        try await send("PTTL", key).converting()
    }

    /// Returns a random key name from the database.
    ///
    /// - Documentation: [RANDOMKEY](https:/redis.io/docs/latest/commands/randomkey)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @slow
    /// - Returns: One of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): when the database is empty.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): a random key in the database.
    @inlinable
    public func randomkey() async throws -> String? {
        try await send("RANDOMKEY").converting()
    }

    /// Renames a key and overwrites the destination.
    ///
    /// - Documentation: [RENAME](https:/redis.io/docs/latest/commands/rename)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func rename(key: RedisKey, newkey: RedisKey) async throws {
        try await send("RENAME", key, newkey)
    }

    /// Renames a key only when the target key name doesn't exist.
    ///
    /// - Documentation: [RENAMENX](https:/redis.io/docs/latest/commands/renamenx)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @write, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if _key_ was renamed to _newkey_.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if _newkey_ already exists.
    @inlinable
    public func renamenx(key: RedisKey, newkey: RedisKey) async throws -> Int {
        try await send("RENAMENX", key, newkey).converting()
    }

    /// Creates a key from the serialized representation of a value.
    ///
    /// - Documentation: [RESTORE](https:/redis.io/docs/latest/commands/restore)
    /// - Version: 2.6.0
    /// - Complexity: O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N)).
    /// - Categories: @keyspace, @write, @slow, @dangerous
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func restore(key: RedisKey, ttl: Int, serializedValue: String, replace: Bool = false, absttl: Bool = false, seconds: Int? = nil, frequency: Int? = nil) async throws {
        try await send("RESTORE", key, ttl, serializedValue, RedisPureToken("REPLACE", replace), RedisPureToken("ABSTTL", absttl), RESPWithToken("IDLETIME", seconds), RESPWithToken("FREQ", frequency))
    }

    /// Iterates over the key names in the database.
    ///
    /// - Documentation: [SCAN](https:/redis.io/docs/latest/commands/scan)
    /// - Version: 2.8.0
    /// - Complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.
    /// - Categories: @keyspace, @read, @slow
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): specifically, an array with two elements.
    ///     * The first element is a [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings) that represents an unsigned 64-bit number, the cursor.
    ///     * The second element is an [Array](https:/redis.io/docs/reference/protocol-spec#arrays) with the names of scanned keys.
    @inlinable
    public func scan(cursor: Int, pattern: String? = nil, count: Int? = nil, type: String? = nil) async throws -> [RESPToken] {
        try await send("SCAN", cursor, RESPWithToken("MATCH", pattern), RESPWithToken("COUNT", count), RESPWithToken("TYPE", type)).converting()
    }

    /// Sorts the elements in a list, a set, or a sorted set, optionally storing the result.
    ///
    /// - Documentation: [SORT](https:/redis.io/docs/latest/commands/sort)
    /// - Version: 1.0.0
    /// - Complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
    /// - Categories: @write, @set, @sortedset, @list, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): without passing the _STORE_ option, the command returns a list of sorted elements.
    ///     [Integer](https:/redis.io/docs/reference/protocol-spec#integers): when the _STORE_ option is specified, the command returns the number of sorted elements in the destination list.
    @inlinable
    public func sort(key: RedisKey, byPattern: String? = nil, limit: RESPCommand.SORTLimit? = nil, getPattern: String? = nil, order: RESPCommand.SORTOrder? = nil, sorting: Bool = false, destination: RedisKey? = nil) async throws -> RESPToken {
        try await send("SORT", key, RESPWithToken("BY", byPattern), RESPWithToken("LIMIT", limit), RESPWithToken("GET", getPattern), order, RedisPureToken("ALPHA", sorting), RESPWithToken("STORE", destination))
    }

    /// Sorts the elements in a list, a set, or a sorted set, optionally storing the result.
    ///
    /// - Documentation: [SORT](https:/redis.io/docs/latest/commands/sort)
    /// - Version: 1.0.0
    /// - Complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
    /// - Categories: @write, @set, @sortedset, @list, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): without passing the _STORE_ option, the command returns a list of sorted elements.
    ///     [Integer](https:/redis.io/docs/reference/protocol-spec#integers): when the _STORE_ option is specified, the command returns the number of sorted elements in the destination list.
    @inlinable
    public func sort(key: RedisKey, byPattern: String? = nil, limit: RESPCommand.SORTLimit? = nil, getPatterns: [String], order: RESPCommand.SORTOrder? = nil, sorting: Bool = false, destination: RedisKey? = nil) async throws -> RESPToken {
        try await send("SORT", key, RESPWithToken("BY", byPattern), RESPWithToken("LIMIT", limit), RESPWithToken("GET", getPatterns), order, RedisPureToken("ALPHA", sorting), RESPWithToken("STORE", destination))
    }

    /// Returns the sorted elements of a list, a set, or a sorted set.
    ///
    /// - Documentation: [SORT_RO](https:/redis.io/docs/latest/commands/sort_ro)
    /// - Version: 7.0.0
    /// - Complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
    /// - Categories: @read, @set, @sortedset, @list, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sorted elements.
    @inlinable
    public func sortRo(key: RedisKey, byPattern: String? = nil, limit: RESPCommand.SORTROLimit? = nil, getPattern: String? = nil, order: RESPCommand.SORTROOrder? = nil, sorting: Bool = false) async throws -> [RESPToken] {
        try await send("SORT_RO", key, RESPWithToken("BY", byPattern), RESPWithToken("LIMIT", limit), RESPWithToken("GET", getPattern), order, RedisPureToken("ALPHA", sorting)).converting()
    }

    /// Returns the sorted elements of a list, a set, or a sorted set.
    ///
    /// - Documentation: [SORT_RO](https:/redis.io/docs/latest/commands/sort_ro)
    /// - Version: 7.0.0
    /// - Complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
    /// - Categories: @read, @set, @sortedset, @list, @slow, @dangerous
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of sorted elements.
    @inlinable
    public func sortRo(key: RedisKey, byPattern: String? = nil, limit: RESPCommand.SORTROLimit? = nil, getPatterns: [String], order: RESPCommand.SORTROOrder? = nil, sorting: Bool = false) async throws -> [RESPToken] {
        try await send("SORT_RO", key, RESPWithToken("BY", byPattern), RESPWithToken("LIMIT", limit), RESPWithToken("GET", getPatterns), order, RedisPureToken("ALPHA", sorting)).converting()
    }

    /// Returns the number of existing keys out of those specified after updating the time they were last accessed.
    ///
    /// - Documentation: [TOUCH](https:/redis.io/docs/latest/commands/touch)
    /// - Version: 3.2.1
    /// - Complexity: O(N) where N is the number of keys that will be touched.
    /// - Categories: @keyspace, @read, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of touched keys.
    @inlinable
    public func touch(key: RedisKey) async throws -> Int {
        try await send("TOUCH", key).converting()
    }

    /// Returns the number of existing keys out of those specified after updating the time they were last accessed.
    ///
    /// - Documentation: [TOUCH](https:/redis.io/docs/latest/commands/touch)
    /// - Version: 3.2.1
    /// - Complexity: O(N) where N is the number of keys that will be touched.
    /// - Categories: @keyspace, @read, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of touched keys.
    @inlinable
    public func touch(keys: [RedisKey]) async throws -> Int {
        try await send("TOUCH", keys).converting()
    }

    /// Returns the expiration time in seconds of a key.
    ///
    /// - Documentation: [TTL](https:/redis.io/docs/latest/commands/ttl)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): TTL in seconds.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-1` if the key exists but has no associated expiration.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `-2` if the key does not exist.
    @inlinable
    public func ttl(key: RedisKey) async throws -> Int {
        try await send("TTL", key).converting()
    }

    /// Determines the type of value stored at a key.
    ///
    /// - Documentation: [TYPE](https:/redis.io/docs/latest/commands/type)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @keyspace, @read, @fast
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): the type of _key_, or `none` when _key_ doesn't exist.
    @inlinable
    public func type(key: RedisKey) async throws -> String {
        try await send("TYPE", key).converting()
    }

    /// Asynchronously deletes one or more keys.
    ///
    /// - Documentation: [UNLINK](https:/redis.io/docs/latest/commands/unlink)
    /// - Version: 4.0.0
    /// - Complexity: O(1) for each key removed regardless of its size. Then the command does O(N) work in a different thread in order to reclaim memory, where N is the number of allocations the deleted objects where composed of.
    /// - Categories: @keyspace, @write, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that were unlinked.
    @inlinable
    public func unlink(key: RedisKey) async throws -> Int {
        try await send("UNLINK", key).converting()
    }

    /// Asynchronously deletes one or more keys.
    ///
    /// - Documentation: [UNLINK](https:/redis.io/docs/latest/commands/unlink)
    /// - Version: 4.0.0
    /// - Complexity: O(1) for each key removed regardless of its size. Then the command does O(N) work in a different thread in order to reclaim memory, where N is the number of allocations the deleted objects where composed of.
    /// - Categories: @keyspace, @write, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of keys that were unlinked.
    @inlinable
    public func unlink(keys: [RedisKey]) async throws -> Int {
        try await send("UNLINK", keys).converting()
    }

    /// Blocks until the asynchronous replication of all preceding write commands sent by the connection is completed.
    ///
    /// - Documentation: [WAIT](https:/redis.io/docs/latest/commands/wait)
    /// - Version: 3.0.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the number of replicas reached by all the writes performed in the context of the current connection.
    @inlinable
    public func wait(numreplicas: Int, timeout: Int) async throws -> Int {
        try await send("WAIT", numreplicas, timeout).converting()
    }

    /// Blocks until all of the preceding write commands sent by the connection are written to the append-only file of the master and/or replicas.
    ///
    /// - Documentation: [WAITAOF](https:/redis.io/docs/latest/commands/waitaof)
    /// - Version: 7.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow, @connection
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): The command returns an array of two integers:
    ///     1. The first is the number of local Redises (0 or 1) that have fsynced to AOF  all writes performed in the context of the current connection
    ///     2. The second is the number of replicas that have acknowledged doing the same.
    @inlinable
    public func waitaof(numlocal: Int, numreplicas: Int, timeout: Int) async throws -> [RESPToken] {
        try await send("WAITAOF", numlocal, numreplicas, timeout).converting()
    }

}
