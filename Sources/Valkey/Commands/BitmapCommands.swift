//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-valkey open source project
//
// Copyright (c) 2025 Apple Inc. and the swift-valkey project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-valkey project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// Counts the number of set bits (population counting) in a string.
public struct BITCOUNT: RESPCommand {
    public enum RangeUnit: RESPRenderable {
        case byte
        case bit

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .byte: "BYTE".encode(into: &commandEncoder)
            case .bit: "BIT".encode(into: &commandEncoder)
            }
        }
    }
    public struct Range: RESPRenderable {
        @usableFromInline let start: Int
        @usableFromInline let end: Int
        @usableFromInline let unit: RangeUnit?


        @inlinable public init(start: Int, end: Int, unit: RangeUnit? = nil) {
            self.start = start
            self.end = end
            self.unit = unit
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += start.encode(into: &commandEncoder)
            count += end.encode(into: &commandEncoder)
            count += unit.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = Int

    public var key: RESPKey
    public var range: Range? = nil

    @inlinable public init(key: RESPKey, range: Range? = nil) {
        self.key = key
        self.range = range
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("BITCOUNT", key, range)
    }
}

/// Performs arbitrary bitfield integer operations on strings.
public struct BITFIELD: RESPCommand {
    public struct OperationGetBlock: RESPRenderable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int


        @inlinable public init(encoding: String, offset: Int) {
            self.encoding = encoding
            self.offset = offset
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += encoding.encode(into: &commandEncoder)
            count += offset.encode(into: &commandEncoder)
            return count
        }
    }
    public enum OperationWriteOverflowBlock: RESPRenderable {
        case wrap
        case sat
        case fail

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .wrap: "WRAP".encode(into: &commandEncoder)
            case .sat: "SAT".encode(into: &commandEncoder)
            case .fail: "FAIL".encode(into: &commandEncoder)
            }
        }
    }
    public struct OperationWriteWriteOperationSetBlock: RESPRenderable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int
        @usableFromInline let value: Int


        @inlinable public init(encoding: String, offset: Int, value: Int) {
            self.encoding = encoding
            self.offset = offset
            self.value = value
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += encoding.encode(into: &commandEncoder)
            count += offset.encode(into: &commandEncoder)
            count += value.encode(into: &commandEncoder)
            return count
        }
    }
    public struct OperationWriteWriteOperationIncrbyBlock: RESPRenderable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int
        @usableFromInline let increment: Int


        @inlinable public init(encoding: String, offset: Int, increment: Int) {
            self.encoding = encoding
            self.offset = offset
            self.increment = increment
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += encoding.encode(into: &commandEncoder)
            count += offset.encode(into: &commandEncoder)
            count += increment.encode(into: &commandEncoder)
            return count
        }
    }
    public enum OperationWriteWriteOperation: RESPRenderable {
        case setBlock(OperationWriteWriteOperationSetBlock)
        case incrbyBlock(OperationWriteWriteOperationIncrbyBlock)

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .setBlock(let setBlock): RESPWithToken("SET", setBlock).encode(into: &commandEncoder)
            case .incrbyBlock(let incrbyBlock): RESPWithToken("INCRBY", incrbyBlock).encode(into: &commandEncoder)
            }
        }
    }
    public struct OperationWrite: RESPRenderable {
        @usableFromInline let overflowBlock: OperationWriteOverflowBlock?
        @usableFromInline let writeOperation: OperationWriteWriteOperation


        @inlinable public init(overflowBlock: OperationWriteOverflowBlock? = nil, writeOperation: OperationWriteWriteOperation) {
            self.overflowBlock = overflowBlock
            self.writeOperation = writeOperation
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += RESPWithToken("OVERFLOW", overflowBlock).encode(into: &commandEncoder)
            count += writeOperation.encode(into: &commandEncoder)
            return count
        }
    }
    public enum Operation: RESPRenderable {
        case getBlock(OperationGetBlock)
        case write(OperationWrite)

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .getBlock(let getBlock): RESPWithToken("GET", getBlock).encode(into: &commandEncoder)
            case .write(let write): write.encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = [RESPToken]?

    public var key: RESPKey
    public var operation: [Operation] = []

    @inlinable public init(key: RESPKey, operation: [Operation] = []) {
        self.key = key
        self.operation = operation
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("BITFIELD", key, operation)
    }
}

/// Performs arbitrary read-only bitfield integer operations on strings.
public struct BITFIELDRO: RESPCommand {
    public struct GetBlock: RESPRenderable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int


        @inlinable public init(encoding: String, offset: Int) {
            self.encoding = encoding
            self.offset = offset
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += encoding.encode(into: &commandEncoder)
            count += offset.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = [RESPToken]

    public var key: RESPKey
    public var getBlock: [GetBlock] = []

    @inlinable public init(key: RESPKey, getBlock: [GetBlock] = []) {
        self.key = key
        self.getBlock = getBlock
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("BITFIELD_RO", key, RESPWithToken("GET", getBlock))
    }
}

/// Performs bitwise operations on multiple strings, and stores the result.
public struct BITOP: RESPCommand {
    public enum Operation: RESPRenderable {
        case and
        case or
        case xor
        case not

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .and: "AND".encode(into: &commandEncoder)
            case .or: "OR".encode(into: &commandEncoder)
            case .xor: "XOR".encode(into: &commandEncoder)
            case .not: "NOT".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = Int

    public var operation: Operation
    public var destkey: RESPKey
    public var key: [RESPKey]

    @inlinable public init(operation: Operation, destkey: RESPKey, key: [RESPKey]) {
        self.operation = operation
        self.destkey = destkey
        self.key = key
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("BITOP", operation, destkey, key)
    }
}

/// Finds the first set (1) or clear (0) bit in a string.
public struct BITPOS: RESPCommand {
    public enum RangeEndUnitBlockUnit: RESPRenderable {
        case byte
        case bit

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .byte: "BYTE".encode(into: &commandEncoder)
            case .bit: "BIT".encode(into: &commandEncoder)
            }
        }
    }
    public struct RangeEndUnitBlock: RESPRenderable {
        @usableFromInline let end: Int
        @usableFromInline let unit: RangeEndUnitBlockUnit?


        @inlinable public init(end: Int, unit: RangeEndUnitBlockUnit? = nil) {
            self.end = end
            self.unit = unit
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += end.encode(into: &commandEncoder)
            count += unit.encode(into: &commandEncoder)
            return count
        }
    }
    public struct Range: RESPRenderable {
        @usableFromInline let start: Int
        @usableFromInline let endUnitBlock: RangeEndUnitBlock?


        @inlinable public init(start: Int, endUnitBlock: RangeEndUnitBlock? = nil) {
            self.start = start
            self.endUnitBlock = endUnitBlock
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += start.encode(into: &commandEncoder)
            count += endUnitBlock.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = Int

    public var key: RESPKey
    public var bit: Int
    public var range: Range? = nil

    @inlinable public init(key: RESPKey, bit: Int, range: Range? = nil) {
        self.key = key
        self.bit = bit
        self.range = range
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("BITPOS", key, bit, range)
    }
}

/// Returns a bit value by offset.
public struct GETBIT: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey
    public var offset: Int

    @inlinable public init(key: RESPKey, offset: Int) {
        self.key = key
        self.offset = offset
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("GETBIT", key, offset)
    }
}

/// Sets or clears the bit at offset of the string value. Creates the key if it doesn't exist.
public struct SETBIT: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey
    public var offset: Int
    public var value: Int

    @inlinable public init(key: RESPKey, offset: Int, value: Int) {
        self.key = key
        self.offset = offset
        self.value = value
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SETBIT", key, offset, value)
    }
}


extension ValkeyConnection {
    /// Counts the number of set bits (population counting) in a string.
    ///
    /// - Documentation: [BITCOUNT](https:/valkey.io/commands/bitcount)
    /// - Version: 2.6.0
    /// - Complexity: O(N)
    /// - Categories: @read, @bitmap, @slow
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the number of bits set to 1.
    @inlinable
    public func bitcount(key: RESPKey, range: BITCOUNT.Range? = nil) async throws -> Int {
        try await send(command: BITCOUNT(key: key, range: range))
    }

    /// Performs arbitrary bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD](https:/valkey.io/commands/bitfield)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Categories: @write, @bitmap, @slow
    /// - Returns: One of the following:
    ///     * [Array](https:/valkey.io/topics/protocol/#arrays): each entry being the corresponding result of the sub-command given at the same position.
    ///     * [Null](https:/valkey.io/topics/protocol/#nulls): if OVERFLOW FAIL was given and overflows or underflows are detected.
    @inlinable
    public func bitfield(key: RESPKey, operation: [BITFIELD.Operation] = []) async throws -> [RESPToken]? {
        try await send(command: BITFIELD(key: key, operation: operation))
    }

    /// Performs arbitrary read-only bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD_RO](https:/valkey.io/commands/bitfield_ro)
    /// - Version: 6.0.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Categories: @read, @bitmap, @fast
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): each entry being the corresponding result of the sub-command given at the same position.
    @inlinable
    public func bitfieldRo(key: RESPKey, getBlock: [BITFIELDRO.GetBlock] = []) async throws -> [RESPToken] {
        try await send(command: BITFIELDRO(key: key, getBlock: getBlock))
    }

    /// Performs bitwise operations on multiple strings, and stores the result.
    ///
    /// - Documentation: [BITOP](https:/valkey.io/commands/bitop)
    /// - Version: 2.6.0
    /// - Complexity: O(N)
    /// - Categories: @write, @bitmap, @slow
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the size of the string stored in the destination key is equal to the size of the longest input string.
    @inlinable
    public func bitop(operation: BITOP.Operation, destkey: RESPKey, key: [RESPKey]) async throws -> Int {
        try await send(command: BITOP(operation: operation, destkey: destkey, key: key))
    }

    /// Finds the first set (1) or clear (0) bit in a string.
    ///
    /// - Documentation: [BITPOS](https:/valkey.io/commands/bitpos)
    /// - Version: 2.8.7
    /// - Complexity: O(N)
    /// - Categories: @read, @bitmap, @slow
    /// - Returns: One of the following:
    ///     * [Integer](https:/valkey.io/topics/protocol/#integers): the position of the first bit set to 1 or 0 according to the request
    ///     * [Integer](https:/valkey.io/topics/protocol/#integers): `-1`. In case the `bit` argument is 1 and the string is empty or composed of just zero bytes
    ///     
    ///     If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.
    ///     
    ///     If we look for clear bits (the bit argument is 0) and the string only contains bits set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value `0xff` the command `BITPOS key 0` will return 24, since up to bit 23 all the bits are 1.
    ///     
    ///     The function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the _start_ argument **only**.
    ///     
    ///     However, this behavior changes if you are looking for clear bits and specify a range with both _start_ and _end_.
    ///     If a clear bit isn't found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.
    @inlinable
    public func bitpos(key: RESPKey, bit: Int, range: BITPOS.Range? = nil) async throws -> Int {
        try await send(command: BITPOS(key: key, bit: bit, range: range))
    }

    /// Returns a bit value by offset.
    ///
    /// - Documentation: [GETBIT](https:/valkey.io/commands/getbit)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @bitmap, @fast
    /// - Returns: The bit value stored at _offset_, one of the following:
    ///     * [Integer](https:/valkey.io/topics/protocol/#integers): `0`.
    ///     * [Integer](https:/valkey.io/topics/protocol/#integers): `1`.
    @inlinable
    public func getbit(key: RESPKey, offset: Int) async throws -> Int {
        try await send(command: GETBIT(key: key, offset: offset))
    }

    /// Sets or clears the bit at offset of the string value. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETBIT](https:/valkey.io/commands/setbit)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @bitmap, @slow
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the original bit value stored at _offset_.
    @inlinable
    public func setbit(key: RESPKey, offset: Int, value: Int) async throws -> Int {
        try await send(command: SETBIT(key: key, offset: offset, value: value))
    }

}
