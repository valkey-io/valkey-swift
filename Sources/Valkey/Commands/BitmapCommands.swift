//===----------------------------------------------------------------------===//
//
// This source file is part of the valkey-swift open source project
//
// Copyright (c) 2025 the valkey-swift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of valkey-swift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// Counts the number of set bits (population counting) in a string.
@_documentation(visibility: internal)
public struct BITCOUNT: ValkeyCommand {
    public enum RangeEndUnitBlockUnit: RESPRenderable, Sendable, Hashable {
        case byte
        case bit

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .byte: "BYTE".encode(into: &commandEncoder)
            case .bit: "BIT".encode(into: &commandEncoder)
            }
        }
    }
    public struct RangeEndUnitBlock: RESPRenderable, Sendable, Hashable {
        @usableFromInline let end: Int
        @usableFromInline let unit: RangeEndUnitBlockUnit?

        @inlinable public init(end: Int, unit: RangeEndUnitBlockUnit? = nil) {
            self.end = end
            self.unit = unit
        }

        @inlinable
        public var respEntries: Int {
            end.respEntries + unit.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            end.encode(into: &commandEncoder)
            unit.encode(into: &commandEncoder)
        }
    }
    public struct Range: RESPRenderable, Sendable, Hashable {
        @usableFromInline let start: Int
        @usableFromInline let endUnitBlock: RangeEndUnitBlock?

        @inlinable public init(start: Int, endUnitBlock: RangeEndUnitBlock? = nil) {
            self.start = start
            self.endUnitBlock = endUnitBlock
        }

        @inlinable
        public var respEntries: Int {
            start.respEntries + endUnitBlock.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            start.encode(into: &commandEncoder)
            endUnitBlock.encode(into: &commandEncoder)
        }
    }
    public typealias Response = Int

    public var key: ValkeyKey
    public var range: Range?

    @inlinable public init(_ key: ValkeyKey, range: Range? = nil) {
        self.key = key
        self.range = range
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("BITCOUNT", key, range)
    }
}

/// Performs arbitrary bitfield integer operations on strings.
@_documentation(visibility: internal)
public struct BITFIELD: ValkeyCommand {
    public struct OperationGetBlock: RESPRenderable, Sendable, Hashable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int

        @inlinable public init(encoding: String, offset: Int) {
            self.encoding = encoding
            self.offset = offset
        }

        @inlinable
        public var respEntries: Int {
            encoding.respEntries + offset.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            encoding.encode(into: &commandEncoder)
            offset.encode(into: &commandEncoder)
        }
    }
    public enum OperationWriteOverflowBlock: RESPRenderable, Sendable, Hashable {
        case wrap
        case sat
        case fail

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .wrap: "WRAP".encode(into: &commandEncoder)
            case .sat: "SAT".encode(into: &commandEncoder)
            case .fail: "FAIL".encode(into: &commandEncoder)
            }
        }
    }
    public struct OperationWriteWriteOperationSetBlock: RESPRenderable, Sendable, Hashable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int
        @usableFromInline let value: Int

        @inlinable public init(encoding: String, offset: Int, value: Int) {
            self.encoding = encoding
            self.offset = offset
            self.value = value
        }

        @inlinable
        public var respEntries: Int {
            encoding.respEntries + offset.respEntries + value.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            encoding.encode(into: &commandEncoder)
            offset.encode(into: &commandEncoder)
            value.encode(into: &commandEncoder)
        }
    }
    public struct OperationWriteWriteOperationIncrbyBlock: RESPRenderable, Sendable, Hashable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int
        @usableFromInline let increment: Int

        @inlinable public init(encoding: String, offset: Int, increment: Int) {
            self.encoding = encoding
            self.offset = offset
            self.increment = increment
        }

        @inlinable
        public var respEntries: Int {
            encoding.respEntries + offset.respEntries + increment.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            encoding.encode(into: &commandEncoder)
            offset.encode(into: &commandEncoder)
            increment.encode(into: &commandEncoder)
        }
    }
    public enum OperationWriteWriteOperation: RESPRenderable, Sendable, Hashable {
        case setBlock(OperationWriteWriteOperationSetBlock)
        case incrbyBlock(OperationWriteWriteOperationIncrbyBlock)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .setBlock(let setBlock): RESPWithToken("SET", setBlock).respEntries
            case .incrbyBlock(let incrbyBlock): RESPWithToken("INCRBY", incrbyBlock).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .setBlock(let setBlock): RESPWithToken("SET", setBlock).encode(into: &commandEncoder)
            case .incrbyBlock(let incrbyBlock): RESPWithToken("INCRBY", incrbyBlock).encode(into: &commandEncoder)
            }
        }
    }
    public struct OperationWrite: RESPRenderable, Sendable, Hashable {
        @usableFromInline let overflowBlock: OperationWriteOverflowBlock?
        @usableFromInline let writeOperation: OperationWriteWriteOperation

        @inlinable public init(overflowBlock: OperationWriteOverflowBlock? = nil, writeOperation: OperationWriteWriteOperation) {
            self.overflowBlock = overflowBlock
            self.writeOperation = writeOperation
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("OVERFLOW", overflowBlock).respEntries + writeOperation.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("OVERFLOW", overflowBlock).encode(into: &commandEncoder)
            writeOperation.encode(into: &commandEncoder)
        }
    }
    public enum Operation: RESPRenderable, Sendable, Hashable {
        case getBlock(OperationGetBlock)
        case write(OperationWrite)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .getBlock(let getBlock): RESPWithToken("GET", getBlock).respEntries
            case .write(let write): write.respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .getBlock(let getBlock): RESPWithToken("GET", getBlock).encode(into: &commandEncoder)
            case .write(let write): write.encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken.Array

    public var key: ValkeyKey
    public var operations: [Operation]

    @inlinable public init(_ key: ValkeyKey, operations: [Operation] = []) {
        self.key = key
        self.operations = operations
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("BITFIELD", key, operations)
    }
}

/// Performs arbitrary read-only bitfield integer operations on strings.
@_documentation(visibility: internal)
public struct BITFIELDRO: ValkeyCommand {
    public struct GetBlock: RESPRenderable, Sendable, Hashable {
        @usableFromInline let encoding: String
        @usableFromInline let offset: Int

        @inlinable public init(encoding: String, offset: Int) {
            self.encoding = encoding
            self.offset = offset
        }

        @inlinable
        public var respEntries: Int {
            encoding.respEntries + offset.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            encoding.encode(into: &commandEncoder)
            offset.encode(into: &commandEncoder)
        }
    }
    public typealias Response = [Int]

    public var key: ValkeyKey
    public var getBlocks: [GetBlock]

    @inlinable public init(_ key: ValkeyKey, getBlocks: [GetBlock] = []) {
        self.key = key
        self.getBlocks = getBlocks
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("BITFIELD_RO", key, RESPWithToken("GET", getBlocks))
    }
}

/// Performs bitwise operations on multiple strings, and stores the result.
@_documentation(visibility: internal)
public struct BITOP: ValkeyCommand {
    public enum Operation: RESPRenderable, Sendable, Hashable {
        case and
        case or
        case xor
        case not

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .and: "AND".encode(into: &commandEncoder)
            case .or: "OR".encode(into: &commandEncoder)
            case .xor: "XOR".encode(into: &commandEncoder)
            case .not: "NOT".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = Int

    public var operation: Operation
    public var destkey: ValkeyKey
    public var keys: [ValkeyKey]

    @inlinable public init(operation: Operation, destkey: ValkeyKey, keys: [ValkeyKey]) {
        self.operation = operation
        self.destkey = destkey
        self.keys = keys
    }

    public var keysAffected: [ValkeyKey] { keys + [destkey] }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("BITOP", operation, destkey, keys)
    }
}

/// Finds the first set (1) or clear (0) bit in a string.
@_documentation(visibility: internal)
public struct BITPOS: ValkeyCommand {
    public enum RangeEndUnitBlockUnit: RESPRenderable, Sendable, Hashable {
        case byte
        case bit

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .byte: "BYTE".encode(into: &commandEncoder)
            case .bit: "BIT".encode(into: &commandEncoder)
            }
        }
    }
    public struct RangeEndUnitBlock: RESPRenderable, Sendable, Hashable {
        @usableFromInline let end: Int
        @usableFromInline let unit: RangeEndUnitBlockUnit?

        @inlinable public init(end: Int, unit: RangeEndUnitBlockUnit? = nil) {
            self.end = end
            self.unit = unit
        }

        @inlinable
        public var respEntries: Int {
            end.respEntries + unit.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            end.encode(into: &commandEncoder)
            unit.encode(into: &commandEncoder)
        }
    }
    public struct Range: RESPRenderable, Sendable, Hashable {
        @usableFromInline let start: Int
        @usableFromInline let endUnitBlock: RangeEndUnitBlock?

        @inlinable public init(start: Int, endUnitBlock: RangeEndUnitBlock? = nil) {
            self.start = start
            self.endUnitBlock = endUnitBlock
        }

        @inlinable
        public var respEntries: Int {
            start.respEntries + endUnitBlock.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            start.encode(into: &commandEncoder)
            endUnitBlock.encode(into: &commandEncoder)
        }
    }
    public typealias Response = Int

    public var key: ValkeyKey
    public var bit: Int
    public var range: Range?

    @inlinable public init(_ key: ValkeyKey, bit: Int, range: Range? = nil) {
        self.key = key
        self.bit = bit
        self.range = range
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("BITPOS", key, bit, range)
    }
}

/// Returns a bit value by offset.
@_documentation(visibility: internal)
public struct GETBIT: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var offset: Int

    @inlinable public init(_ key: ValkeyKey, offset: Int) {
        self.key = key
        self.offset = offset
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GETBIT", key, offset)
    }
}

/// Sets or clears the bit at offset of the string value. Creates the key if it doesn't exist.
@_documentation(visibility: internal)
public struct SETBIT: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var offset: Int
    public var value: Int

    @inlinable public init(_ key: ValkeyKey, offset: Int, value: Int) {
        self.key = key
        self.offset = offset
        self.value = value
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("SETBIT", key, offset, value)
    }
}

extension ValkeyClientProtocol {
    /// Counts the number of set bits (population counting) in a string.
    ///
    /// - Documentation: [BITCOUNT](https://valkey.io/commands/bitcount)
    /// - Available: 2.6.0
    /// - History:
    ///     * 7.0.0: Added the `BYTE|BIT` option.
    ///     * 8.0.0: `end` made optional; when called without argument the command reports the last BYTE.
    /// - Complexity: O(N)
    /// - Response: [Integer]: The number of bits set to 1.
    @inlinable
    public func bitcount(_ key: ValkeyKey, range: BITCOUNT.Range? = nil) async throws -> Int {
        try await send(command: BITCOUNT(key, range: range))
    }

    /// Performs arbitrary bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD](https://valkey.io/commands/bitfield)
    /// - Available: 3.2.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Response: One of the following
    ///     * [Array]: The result of the subcommand at the same position
    ///     * [Array]: In case OVERFLOW FAIL was given and overflows or underflows detected
    @inlinable
    @discardableResult
    public func bitfield(_ key: ValkeyKey, operations: [BITFIELD.Operation] = []) async throws -> RESPToken.Array {
        try await send(command: BITFIELD(key, operations: operations))
    }

    /// Performs arbitrary read-only bitfield integer operations on strings.
    ///
    /// - Documentation: [BITFIELD_RO](https://valkey.io/commands/bitfield_ro)
    /// - Available: 6.0.0
    /// - Complexity: O(1) for each subcommand specified
    /// - Response: [Array]: The result of the subcommand at the same position
    @inlinable
    public func bitfieldRo(_ key: ValkeyKey, getBlocks: [BITFIELDRO.GetBlock] = []) async throws -> [Int] {
        try await send(command: BITFIELDRO(key, getBlocks: getBlocks))
    }

    /// Performs bitwise operations on multiple strings, and stores the result.
    ///
    /// - Documentation: [BITOP](https://valkey.io/commands/bitop)
    /// - Available: 2.6.0
    /// - Complexity: O(N)
    /// - Response: [Integer]: The size of the string stored in the destination key, that is equal to the size of the longest input string.
    @inlinable
    @discardableResult
    public func bitop(operation: BITOP.Operation, destkey: ValkeyKey, keys: [ValkeyKey]) async throws -> Int {
        try await send(command: BITOP(operation: operation, destkey: destkey, keys: keys))
    }

    /// Finds the first set (1) or clear (0) bit in a string.
    ///
    /// - Documentation: [BITPOS](https://valkey.io/commands/bitpos)
    /// - Available: 2.8.7
    /// - History:
    ///     * 7.0.0: Added the `BYTE|BIT` option.
    /// - Complexity: O(N)
    /// - Response: One of the following
    ///     * [Integer]: The position of the first bit set to 1 or 0 according to the request.
    ///     * -1: In case the `bit` argument is 1 and the string is empty or composed of just zero bytes.
    @inlinable
    public func bitpos(_ key: ValkeyKey, bit: Int, range: BITPOS.Range? = nil) async throws -> Int {
        try await send(command: BITPOS(key, bit: bit, range: range))
    }

    /// Returns a bit value by offset.
    ///
    /// - Documentation: [GETBIT](https://valkey.io/commands/getbit)
    /// - Available: 2.2.0
    /// - Complexity: O(1)
    /// - Response: The bit value stored at offset.
    @inlinable
    public func getbit(_ key: ValkeyKey, offset: Int) async throws -> Int {
        try await send(command: GETBIT(key, offset: offset))
    }

    /// Sets or clears the bit at offset of the string value. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETBIT](https://valkey.io/commands/setbit)
    /// - Available: 2.2.0
    /// - Complexity: O(1)
    /// - Response: The original bit value stored at offset.
    @inlinable
    @discardableResult
    public func setbit(_ key: ValkeyKey, offset: Int, value: Int) async throws -> Int {
        try await send(command: SETBIT(key, offset: offset, value: value))
    }

}
