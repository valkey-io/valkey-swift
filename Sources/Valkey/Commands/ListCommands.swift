//===----------------------------------------------------------------------===//
//
// This source file is part of the valkey-swift open source project
//
// Copyright (c) 2025 the valkey-swift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of valkey-swift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// Pops an element from a list, pushes it to another list and returns it. Blocks until an element is available otherwise. Deletes the list if the last element was moved.
@_documentation(visibility: internal)
public struct BLMOVE: ValkeyCommand {
    public enum Wherefrom: RESPRenderable, Sendable, Hashable {
        case left
        case right

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .left: "LEFT".encode(into: &commandEncoder)
            case .right: "RIGHT".encode(into: &commandEncoder)
            }
        }
    }
    public enum Whereto: RESPRenderable, Sendable, Hashable {
        case left
        case right

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .left: "LEFT".encode(into: &commandEncoder)
            case .right: "RIGHT".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = ByteBuffer?

    public var source: ValkeyKey
    public var destination: ValkeyKey
    public var wherefrom: Wherefrom
    public var whereto: Whereto
    public var timeout: Double

    @inlinable public init(source: ValkeyKey, destination: ValkeyKey, wherefrom: Wherefrom, whereto: Whereto, timeout: Double) {
        self.source = source
        self.destination = destination
        self.wherefrom = wherefrom
        self.whereto = whereto
        self.timeout = timeout
    }

    public var keysAffected: [ValkeyKey] { [source, destination] }

    public var isBlocking: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("BLMOVE", source, destination, wherefrom, whereto, timeout)
    }
}

/// Pops the first element from one of multiple lists. Blocks until an element is available otherwise. Deletes the list if the last element was popped.
@_documentation(visibility: internal)
public struct BLMPOP: ValkeyCommand {
    public enum Where: RESPRenderable, Sendable, Hashable {
        case left
        case right

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .left: "LEFT".encode(into: &commandEncoder)
            case .right: "RIGHT".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken.Array?

    public var timeout: Double
    public var keys: [ValkeyKey]
    public var `where`: Where
    public var count: Int?

    @inlinable public init(timeout: Double, keys: [ValkeyKey], `where`: Where, count: Int? = nil) {
        self.timeout = timeout
        self.keys = keys
        self.`where` = `where`
        self.count = count
    }

    public var keysAffected: [ValkeyKey] { keys }

    public var isBlocking: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("BLMPOP", timeout, RESPArrayWithCount(keys), `where`, RESPWithToken("COUNT", count))
    }
}

/// Removes and returns the first element in a list. Blocks until an element is available otherwise. Deletes the list if the last element was popped.
@_documentation(visibility: internal)
public struct BLPOP: ValkeyCommand {
    public typealias Response = RESPToken.Array?

    public var keys: [ValkeyKey]
    public var timeout: Double

    @inlinable public init(keys: [ValkeyKey], timeout: Double) {
        self.keys = keys
        self.timeout = timeout
    }

    public var keysAffected: [ValkeyKey] { keys }

    public var isBlocking: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("BLPOP", keys, timeout)
    }
}

/// Removes and returns the last element in a list. Blocks until an element is available otherwise. Deletes the list if the last element was popped.
@_documentation(visibility: internal)
public struct BRPOP: ValkeyCommand {
    public typealias Response = RESPToken.Array?

    public var keys: [ValkeyKey]
    public var timeout: Double

    @inlinable public init(keys: [ValkeyKey], timeout: Double) {
        self.keys = keys
        self.timeout = timeout
    }

    public var keysAffected: [ValkeyKey] { keys }

    public var isBlocking: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("BRPOP", keys, timeout)
    }
}

/// Pops an element from a list, pushes it to another list and returns it. Block until an element is available otherwise. Deletes the list if the last element was popped.
@_documentation(visibility: internal)
public struct BRPOPLPUSH: ValkeyCommand {
    public typealias Response = ByteBuffer?

    public var source: ValkeyKey
    public var destination: ValkeyKey
    public var timeout: Double

    @inlinable public init(source: ValkeyKey, destination: ValkeyKey, timeout: Double) {
        self.source = source
        self.destination = destination
        self.timeout = timeout
    }

    public var keysAffected: [ValkeyKey] { [source, destination] }

    public var isBlocking: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("BRPOPLPUSH", source, destination, timeout)
    }
}

/// Returns an element from a list by its index.
@_documentation(visibility: internal)
public struct LINDEX: ValkeyCommand {
    public typealias Response = ByteBuffer?

    public var key: ValkeyKey
    public var index: Int

    @inlinable public init(_ key: ValkeyKey, index: Int) {
        self.key = key
        self.index = index
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LINDEX", key, index)
    }
}

/// Inserts an element before or after another element in a list.
@_documentation(visibility: internal)
public struct LINSERT<Pivot: RESPStringRenderable, Element: RESPStringRenderable>: ValkeyCommand {
    public enum Where: RESPRenderable, Sendable, Hashable {
        case before
        case after

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .before: "BEFORE".encode(into: &commandEncoder)
            case .after: "AFTER".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = Int

    public var key: ValkeyKey
    public var `where`: Where
    public var pivot: Pivot
    public var element: Element

    @inlinable public init(_ key: ValkeyKey, `where`: Where, pivot: Pivot, element: Element) {
        self.key = key
        self.`where` = `where`
        self.pivot = pivot
        self.element = element
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LINSERT", key, `where`, RESPBulkString(pivot), RESPBulkString(element))
    }
}

/// Returns the length of a list.
@_documentation(visibility: internal)
public struct LLEN: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LLEN", key)
    }
}

/// Returns an element after popping it from one list and pushing it to another. Deletes the list if the last element was moved.
@_documentation(visibility: internal)
public struct LMOVE: ValkeyCommand {
    public enum Wherefrom: RESPRenderable, Sendable, Hashable {
        case left
        case right

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .left: "LEFT".encode(into: &commandEncoder)
            case .right: "RIGHT".encode(into: &commandEncoder)
            }
        }
    }
    public enum Whereto: RESPRenderable, Sendable, Hashable {
        case left
        case right

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .left: "LEFT".encode(into: &commandEncoder)
            case .right: "RIGHT".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = ByteBuffer

    public var source: ValkeyKey
    public var destination: ValkeyKey
    public var wherefrom: Wherefrom
    public var whereto: Whereto

    @inlinable public init(source: ValkeyKey, destination: ValkeyKey, wherefrom: Wherefrom, whereto: Whereto) {
        self.source = source
        self.destination = destination
        self.wherefrom = wherefrom
        self.whereto = whereto
    }

    public var keysAffected: [ValkeyKey] { [source, destination] }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LMOVE", source, destination, wherefrom, whereto)
    }
}

/// Returns multiple elements from a list after removing them. Deletes the list if the last element was popped.
@_documentation(visibility: internal)
public struct LMPOP: ValkeyCommand {
    public enum Where: RESPRenderable, Sendable, Hashable {
        case left
        case right

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .left: "LEFT".encode(into: &commandEncoder)
            case .right: "RIGHT".encode(into: &commandEncoder)
            }
        }
    }
    public var keys: [ValkeyKey]
    public var `where`: Where
    public var count: Int?

    @inlinable public init(keys: [ValkeyKey], `where`: Where, count: Int? = nil) {
        self.keys = keys
        self.`where` = `where`
        self.count = count
    }

    public var keysAffected: [ValkeyKey] { keys }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LMPOP", RESPArrayWithCount(keys), `where`, RESPWithToken("COUNT", count))
    }
}

/// Returns the first elements in a list after removing it. Deletes the list if the last element was popped.
@_documentation(visibility: internal)
public struct LPOP: ValkeyCommand {
    public typealias Response = RESPToken?

    public var key: ValkeyKey
    public var count: Int?

    @inlinable public init(_ key: ValkeyKey, count: Int? = nil) {
        self.key = key
        self.count = count
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LPOP", key, count)
    }
}

/// Returns the index of matching elements in a list.
@_documentation(visibility: internal)
public struct LPOS<Element: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = [Int]?

    public var key: ValkeyKey
    public var element: Element
    public var rank: Int?
    public var numMatches: Int?
    public var len: Int?

    @inlinable public init(_ key: ValkeyKey, element: Element, rank: Int? = nil, numMatches: Int? = nil, len: Int? = nil) {
        self.key = key
        self.element = element
        self.rank = rank
        self.numMatches = numMatches
        self.len = len
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "LPOS",
            key,
            RESPBulkString(element),
            RESPWithToken("RANK", rank),
            RESPWithToken("COUNT", numMatches),
            RESPWithToken("MAXLEN", len)
        )
    }
}

/// Prepends one or more elements to a list. Creates the key if it doesn't exist.
@_documentation(visibility: internal)
public struct LPUSH<Element: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var elements: [Element]

    @inlinable public init(_ key: ValkeyKey, elements: [Element]) {
        self.key = key
        self.elements = elements
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LPUSH", key, elements.map { RESPBulkString($0) })
    }
}

/// Prepends one or more elements to a list only when the list exists.
@_documentation(visibility: internal)
public struct LPUSHX<Element: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var elements: [Element]

    @inlinable public init(_ key: ValkeyKey, elements: [Element]) {
        self.key = key
        self.elements = elements
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LPUSHX", key, elements.map { RESPBulkString($0) })
    }
}

/// Returns a range of elements from a list.
@_documentation(visibility: internal)
public struct LRANGE: ValkeyCommand {
    public typealias Response = RESPToken.Array

    public var key: ValkeyKey
    public var start: Int
    public var stop: Int

    @inlinable public init(_ key: ValkeyKey, start: Int, stop: Int) {
        self.key = key
        self.start = start
        self.stop = stop
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LRANGE", key, start, stop)
    }
}

/// Removes elements from a list. Deletes the list if the last element was removed.
@_documentation(visibility: internal)
public struct LREM<Element: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var count: Int
    public var element: Element

    @inlinable public init(_ key: ValkeyKey, count: Int, element: Element) {
        self.key = key
        self.count = count
        self.element = element
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LREM", key, count, RESPBulkString(element))
    }
}

/// Sets the value of an element in a list by its index.
@_documentation(visibility: internal)
public struct LSET<Element: RESPStringRenderable>: ValkeyCommand {
    public var key: ValkeyKey
    public var index: Int
    public var element: Element

    @inlinable public init(_ key: ValkeyKey, index: Int, element: Element) {
        self.key = key
        self.index = index
        self.element = element
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LSET", key, index, RESPBulkString(element))
    }
}

/// Removes elements from both ends a list. Deletes the list if all elements were trimmed.
@_documentation(visibility: internal)
public struct LTRIM: ValkeyCommand {
    public var key: ValkeyKey
    public var start: Int
    public var stop: Int

    @inlinable public init(_ key: ValkeyKey, start: Int, stop: Int) {
        self.key = key
        self.start = start
        self.stop = stop
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("LTRIM", key, start, stop)
    }
}

/// Returns and removes the last elements of a list. Deletes the list if the last element was popped.
@_documentation(visibility: internal)
public struct RPOP: ValkeyCommand {
    public typealias Response = RESPToken?

    public var key: ValkeyKey
    public var count: Int?

    @inlinable public init(_ key: ValkeyKey, count: Int? = nil) {
        self.key = key
        self.count = count
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("RPOP", key, count)
    }
}

/// Returns the last element of a list after removing and pushing it to another list. Deletes the list if the last element was popped.
@_documentation(visibility: internal)
public struct RPOPLPUSH: ValkeyCommand {
    public typealias Response = ByteBuffer?

    public var source: ValkeyKey
    public var destination: ValkeyKey

    @inlinable public init(source: ValkeyKey, destination: ValkeyKey) {
        self.source = source
        self.destination = destination
    }

    public var keysAffected: [ValkeyKey] { [source, destination] }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("RPOPLPUSH", source, destination)
    }
}

/// Appends one or more elements to a list. Creates the key if it doesn't exist.
@_documentation(visibility: internal)
public struct RPUSH<Element: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var elements: [Element]

    @inlinable public init(_ key: ValkeyKey, elements: [Element]) {
        self.key = key
        self.elements = elements
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("RPUSH", key, elements.map { RESPBulkString($0) })
    }
}

/// Appends an element to a list only when the list exists.
@_documentation(visibility: internal)
public struct RPUSHX<Element: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var elements: [Element]

    @inlinable public init(_ key: ValkeyKey, elements: [Element]) {
        self.key = key
        self.elements = elements
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("RPUSHX", key, elements.map { RESPBulkString($0) })
    }
}

extension ValkeyConnectionProtocol {
    /// Pops an element from a list, pushes it to another list and returns it. Blocks until an element is available otherwise. Deletes the list if the last element was moved.
    ///
    /// - Documentation: [BLMOVE](https://valkey.io/commands/blmove)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [String]: The popped element.
    ///     * [Null]: Operation timed-out
    @inlinable
    public func blmove(
        source: ValkeyKey,
        destination: ValkeyKey,
        wherefrom: BLMOVE.Wherefrom,
        whereto: BLMOVE.Whereto,
        timeout: Double
    ) async throws -> ByteBuffer? {
        try await send(command: BLMOVE(source: source, destination: destination, wherefrom: wherefrom, whereto: whereto, timeout: timeout))
    }

    /// Pops the first element from one of multiple lists. Blocks until an element is available otherwise. Deletes the list if the last element was popped.
    ///
    /// - Documentation: [BLMPOP](https://valkey.io/commands/blmpop)
    /// - Available: 7.0.0
    /// - Complexity: O(N+M) where N is the number of provided keys and M is the number of elements returned.
    /// - Response: One of the following
    ///     * [Null]: Operation timed-out
    ///     * [Array]: The key from which elements were popped and the popped elements
    @inlinable
    public func blmpop(timeout: Double, keys: [ValkeyKey], where: BLMPOP.Where, count: Int? = nil) async throws -> RESPToken.Array? {
        try await send(command: BLMPOP(timeout: timeout, keys: keys, where: `where`, count: count))
    }

    /// Removes and returns the first element in a list. Blocks until an element is available otherwise. Deletes the list if the last element was popped.
    ///
    /// - Documentation: [BLPOP](https://valkey.io/commands/blpop)
    /// - Available: 2.0.0
    /// - History:
    ///     * 6.0.0: `timeout` is interpreted as a double instead of an integer.
    /// - Complexity: O(N) where N is the number of provided keys.
    /// - Response: One of the following
    ///     * [Null]: No element could be popped and timeout expired
    ///     * [Array]: The key from which the element was popped and the value of the popped element
    @inlinable
    public func blpop(keys: [ValkeyKey], timeout: Double) async throws -> RESPToken.Array? {
        try await send(command: BLPOP(keys: keys, timeout: timeout))
    }

    /// Removes and returns the last element in a list. Blocks until an element is available otherwise. Deletes the list if the last element was popped.
    ///
    /// - Documentation: [BRPOP](https://valkey.io/commands/brpop)
    /// - Available: 2.0.0
    /// - History:
    ///     * 6.0.0: `timeout` is interpreted as a double instead of an integer.
    /// - Complexity: O(N) where N is the number of provided keys.
    /// - Response: One of the following
    ///     * [Null]: No element could be popped and the timeout expired.
    ///     * [Array]: The name of the key where an element was popped
    @inlinable
    public func brpop(keys: [ValkeyKey], timeout: Double) async throws -> RESPToken.Array? {
        try await send(command: BRPOP(keys: keys, timeout: timeout))
    }

    /// Pops an element from a list, pushes it to another list and returns it. Block until an element is available otherwise. Deletes the list if the last element was popped.
    ///
    /// - Documentation: [BRPOPLPUSH](https://valkey.io/commands/brpoplpush)
    /// - Available: 2.2.0
    /// - History:
    ///     * 6.0.0: `timeout` is interpreted as a double instead of an integer.
    /// - Deprecated since: 6.2.0. Replaced by `BLMOVE` with the `RIGHT` and `LEFT` arguments.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [String]: The element being popped from source and pushed to destination.
    ///     * [Null]: Timeout is reached.
    @inlinable
    public func brpoplpush(source: ValkeyKey, destination: ValkeyKey, timeout: Double) async throws -> ByteBuffer? {
        try await send(command: BRPOPLPUSH(source: source, destination: destination, timeout: timeout))
    }

    /// Returns an element from a list by its index.
    ///
    /// - Documentation: [LINDEX](https://valkey.io/commands/lindex)
    /// - Available: 1.0.0
    /// - Complexity: O(N) where N is the number of elements to traverse to get to the element at index. This makes asking for the first or the last element of the list O(1).
    /// - Response: One of the following
    ///     * [Null]: Index is out of range
    ///     * [String]: The requested element
    @inlinable
    public func lindex(_ key: ValkeyKey, index: Int) async throws -> ByteBuffer? {
        try await send(command: LINDEX(key, index: index))
    }

    /// Inserts an element before or after another element in a list.
    ///
    /// - Documentation: [LINSERT](https://valkey.io/commands/linsert)
    /// - Available: 2.2.0
    /// - Complexity: O(N) where N is the number of elements to traverse before seeing the value pivot. This means that inserting somewhere on the left end on the list (head) can be considered O(1) and inserting somewhere on the right end (tail) is O(N).
    /// - Response: One of the following
    ///     * [Integer]: List length after a successful insert operation.
    ///     * 0: In case key doesn't exist.
    ///     * -1: When the pivot wasn't found.
    @inlinable
    public func linsert<Pivot: RESPStringRenderable, Element: RESPStringRenderable>(
        _ key: ValkeyKey,
        where: LINSERT<Pivot, Element>.Where,
        pivot: Pivot,
        element: Element
    ) async throws -> Int {
        try await send(command: LINSERT(key, where: `where`, pivot: pivot, element: element))
    }

    /// Returns the length of a list.
    ///
    /// - Documentation: [LLEN](https://valkey.io/commands/llen)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Response: [Integer]: List length.
    @inlinable
    public func llen(_ key: ValkeyKey) async throws -> Int {
        try await send(command: LLEN(key))
    }

    /// Returns an element after popping it from one list and pushing it to another. Deletes the list if the last element was moved.
    ///
    /// - Documentation: [LMOVE](https://valkey.io/commands/lmove)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    /// - Response: [String]: The element being popped and pushed.
    @inlinable
    public func lmove(source: ValkeyKey, destination: ValkeyKey, wherefrom: LMOVE.Wherefrom, whereto: LMOVE.Whereto) async throws -> ByteBuffer {
        try await send(command: LMOVE(source: source, destination: destination, wherefrom: wherefrom, whereto: whereto))
    }

    /// Returns multiple elements from a list after removing them. Deletes the list if the last element was popped.
    ///
    /// - Documentation: [LMPOP](https://valkey.io/commands/lmpop)
    /// - Available: 7.0.0
    /// - Complexity: O(N+M) where N is the number of provided keys and M is the number of elements returned.
    /// - Response: One of the following
    ///     * [Null]: If no element could be popped.
    ///     * [Array]: List key from which elements were popped.
    @inlinable
    public func lmpop(keys: [ValkeyKey], where: LMPOP.Where, count: Int? = nil) async throws -> LMPOP.Response {
        try await send(command: LMPOP(keys: keys, where: `where`, count: count))
    }

    /// Returns the first elements in a list after removing it. Deletes the list if the last element was popped.
    ///
    /// - Documentation: [LPOP](https://valkey.io/commands/lpop)
    /// - Available: 1.0.0
    /// - History:
    ///     * 6.2.0: Added the `count` argument.
    /// - Complexity: O(N) where N is the number of elements returned
    /// - Response: One of the following
    ///     * [Null]: Key does not exist.
    ///     * [String]: In case `count` argument was not given, the value of the first element.
    ///     * [Array]: In case `count` argument was given, a list of popped elements
    @inlinable
    public func lpop(_ key: ValkeyKey, count: Int? = nil) async throws -> RESPToken? {
        try await send(command: LPOP(key, count: count))
    }

    /// Returns the index of matching elements in a list.
    ///
    /// - Documentation: [LPOS](https://valkey.io/commands/lpos)
    /// - Available: 6.0.6
    /// - Complexity: O(N) where N is the number of elements in the list, for the average case. When searching for elements near the head or the tail of the list, or when the MAXLEN option is provided, the command may run in constant time.
    /// - Response: One of the following
    ///     * [Null]: In case there is no matching element
    ///     * [Integer]: An integer representing the matching element
    ///     * [Array]: If the COUNT option is given, an array of integers representing the matching elements (empty if there are no matches)
    @inlinable
    public func lpos<Element: RESPStringRenderable>(
        _ key: ValkeyKey,
        element: Element,
        rank: Int? = nil,
        numMatches: Int? = nil,
        len: Int? = nil
    ) async throws -> [Int]? {
        try await send(command: LPOS(key, element: element, rank: rank, numMatches: numMatches, len: len))
    }

    /// Prepends one or more elements to a list. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [LPUSH](https://valkey.io/commands/lpush)
    /// - Available: 1.0.0
    /// - History:
    ///     * 2.4.0: Accepts multiple `element` arguments.
    /// - Complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
    /// - Response: [Integer]: Length of the list after the push operations.
    @inlinable
    public func lpush<Element: RESPStringRenderable>(_ key: ValkeyKey, elements: [Element]) async throws -> Int {
        try await send(command: LPUSH(key, elements: elements))
    }

    /// Prepends one or more elements to a list only when the list exists.
    ///
    /// - Documentation: [LPUSHX](https://valkey.io/commands/lpushx)
    /// - Available: 2.2.0
    /// - History:
    ///     * 4.0.0: Accepts multiple `element` arguments.
    /// - Complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
    /// - Response: [Integer]: The length of the list after the push operation.
    @inlinable
    public func lpushx<Element: RESPStringRenderable>(_ key: ValkeyKey, elements: [Element]) async throws -> Int {
        try await send(command: LPUSHX(key, elements: elements))
    }

    /// Returns a range of elements from a list.
    ///
    /// - Documentation: [LRANGE](https://valkey.io/commands/lrange)
    /// - Available: 1.0.0
    /// - Complexity: O(S+N) where S is the distance of start offset from HEAD for small lists, from nearest end (HEAD or TAIL) for large lists; and N is the number of elements in the specified range.
    /// - Response: [Array]: List of elements in the specified range
    @inlinable
    public func lrange(_ key: ValkeyKey, start: Int, stop: Int) async throws -> RESPToken.Array {
        try await send(command: LRANGE(key, start: start, stop: stop))
    }

    /// Removes elements from a list. Deletes the list if the last element was removed.
    ///
    /// - Documentation: [LREM](https://valkey.io/commands/lrem)
    /// - Available: 1.0.0
    /// - Complexity: O(N+M) where N is the length of the list and M is the number of elements removed.
    /// - Response: [Integer]: The number of removed elements.
    @inlinable
    public func lrem<Element: RESPStringRenderable>(_ key: ValkeyKey, count: Int, element: Element) async throws -> Int {
        try await send(command: LREM(key, count: count, element: element))
    }

    /// Sets the value of an element in a list by its index.
    ///
    /// - Documentation: [LSET](https://valkey.io/commands/lset)
    /// - Available: 1.0.0
    /// - Complexity: O(N) where N is the length of the list. Setting either the first or the last element of the list is O(1).
    @inlinable
    public func lset<Element: RESPStringRenderable>(_ key: ValkeyKey, index: Int, element: Element) async throws {
        _ = try await send(command: LSET(key, index: index, element: element))
    }

    /// Removes elements from both ends a list. Deletes the list if all elements were trimmed.
    ///
    /// - Documentation: [LTRIM](https://valkey.io/commands/ltrim)
    /// - Available: 1.0.0
    /// - Complexity: O(N) where N is the number of elements to be removed by the operation.
    @inlinable
    public func ltrim(_ key: ValkeyKey, start: Int, stop: Int) async throws {
        _ = try await send(command: LTRIM(key, start: start, stop: stop))
    }

    /// Returns and removes the last elements of a list. Deletes the list if the last element was popped.
    ///
    /// - Documentation: [RPOP](https://valkey.io/commands/rpop)
    /// - Available: 1.0.0
    /// - History:
    ///     * 6.2.0: Added the `count` argument.
    /// - Complexity: O(N) where N is the number of elements returned
    /// - Response: One of the following
    ///     * [Null]: Key does not exist.
    ///     * [String]: When 'COUNT' was not given, the value of the last element.
    ///     * [Array]: When 'COUNT' was given, list of popped elements.
    @inlinable
    public func rpop(_ key: ValkeyKey, count: Int? = nil) async throws -> RESPToken? {
        try await send(command: RPOP(key, count: count))
    }

    /// Returns the last element of a list after removing and pushing it to another list. Deletes the list if the last element was popped.
    ///
    /// - Documentation: [RPOPLPUSH](https://valkey.io/commands/rpoplpush)
    /// - Available: 1.2.0
    /// - Deprecated since: 6.2.0. Replaced by `LMOVE` with the `RIGHT` and `LEFT` arguments.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [String]: The element being popped and pushed.
    ///     * [Null]: Source list is empty.
    @inlinable
    public func rpoplpush(source: ValkeyKey, destination: ValkeyKey) async throws -> ByteBuffer? {
        try await send(command: RPOPLPUSH(source: source, destination: destination))
    }

    /// Appends one or more elements to a list. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [RPUSH](https://valkey.io/commands/rpush)
    /// - Available: 1.0.0
    /// - History:
    ///     * 2.4.0: Accepts multiple `element` arguments.
    /// - Complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
    /// - Response: [Integer]: Length of the list after the push operations.
    @inlinable
    public func rpush<Element: RESPStringRenderable>(_ key: ValkeyKey, elements: [Element]) async throws -> Int {
        try await send(command: RPUSH(key, elements: elements))
    }

    /// Appends an element to a list only when the list exists.
    ///
    /// - Documentation: [RPUSHX](https://valkey.io/commands/rpushx)
    /// - Available: 2.2.0
    /// - History:
    ///     * 4.0.0: Accepts multiple `element` arguments.
    /// - Complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.
    /// - Response: [Integer]: Length of the list after the push operation.
    @inlinable
    public func rpushx<Element: RESPStringRenderable>(_ key: ValkeyKey, elements: [Element]) async throws -> Int {
        try await send(command: RPUSHX(key, elements: elements))
    }

}
