//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-valkey open source project
//
// Copyright (c) 2025 Apple Inc. and the swift-valkey project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-valkey project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// Adds one or more members to a geospatial index. The key is created if it doesn't exist.
public struct GEOADD<Member: RESPStringRenderable>: ValkeyCommand {
    public enum Condition: RESPRenderable, Sendable {
        case nx
        case xx

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .nx: "NX".encode(into: &commandEncoder)
            case .xx: "XX".encode(into: &commandEncoder)
            }
        }
    }
    public struct Data: RESPRenderable, Sendable {
        @usableFromInline let longitude: Double
        @usableFromInline let latitude: Double
        @usableFromInline let member: Member


        @inlinable public init(longitude: Double, latitude: Double, member: Member) {
            self.longitude = longitude
            self.latitude = latitude
            self.member = member
        }

        @inlinable
        public var respEntries: Int {
            longitude.respEntries + latitude.respEntries + RESPBulkString(member).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            longitude.encode(into: &commandEncoder)
            latitude.encode(into: &commandEncoder)
            RESPBulkString(member).encode(into: &commandEncoder)
        }
    }
    public typealias Response = Int

    public var key: ValkeyKey
    public var condition: Condition?
    public var change: Bool
    public var data: [Data]

    @inlinable public init(key: ValkeyKey, condition: Condition? = nil, change: Bool = false, data: [Data]) {
        self.key = key
        self.condition = condition
        self.change = change
        self.data = data
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEOADD", key, condition, RESPPureToken("CH", change), data)
    }
}

/// Returns the distance between two members of a geospatial index.
public struct GEODIST<Member1: RESPStringRenderable, Member2: RESPStringRenderable>: ValkeyCommand {
    public enum Unit: RESPRenderable, Sendable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken?

    public var key: ValkeyKey
    public var member1: Member1
    public var member2: Member2
    public var unit: Unit?

    @inlinable public init(key: ValkeyKey, member1: Member1, member2: Member2, unit: Unit? = nil) {
        self.key = key
        self.member1 = member1
        self.member2 = member2
        self.unit = unit
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEODIST", key, RESPBulkString(member1), RESPBulkString(member2), unit)
    }
}

/// Returns members from a geospatial index as geohash strings.
public struct GEOHASH: ValkeyCommand {
    public typealias Response = RESPToken.Array

    public var key: ValkeyKey
    public var member: [String]

    @inlinable public init(key: ValkeyKey, member: [String] = []) {
        self.key = key
        self.member = member
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEOHASH", key, member)
    }
}

/// Returns the longitude and latitude of members from a geospatial index.
public struct GEOPOS: ValkeyCommand {
    public typealias Response = RESPToken.Array

    public var key: ValkeyKey
    public var member: [String]

    @inlinable public init(key: ValkeyKey, member: [String] = []) {
        self.key = key
        self.member = member
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEOPOS", key, member)
    }
}

/// Queries a geospatial index for members within a distance from a coordinate, optionally stores the result.
@available(*, deprecated, message: "Since 6.2.0. Replaced by `GEOSEARCH` and `GEOSEARCHSTORE` with the `BYRADIUS` argument.")
public struct GEORADIUS: ValkeyCommand {
    public enum Unit: RESPRenderable, Sendable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool


        @inlinable public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + "ANY".respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            "ANY".encode(into: &commandEncoder)
        }
    }
    public enum Order: RESPRenderable, Sendable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public enum Store: RESPRenderable, Sendable {
        case storekey(ValkeyKey)
        case storedistkey(ValkeyKey)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).respEntries
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).encode(into: &commandEncoder)
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).encode(into: &commandEncoder)
            }
        }
    }
    public var key: ValkeyKey
    public var longitude: Double
    public var latitude: Double
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool
    public var withdist: Bool
    public var withhash: Bool
    public var countBlock: CountBlock?
    public var order: Order?
    public var store: Store?

    @inlinable public init(key: ValkeyKey, longitude: Double, latitude: Double, radius: Double, unit: Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: CountBlock? = nil, order: Order? = nil, store: Store? = nil) {
        self.key = key
        self.longitude = longitude
        self.latitude = latitude
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
        self.store = store
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEORADIUS", key, longitude, latitude, radius, unit, RESPPureToken("WITHCOORD", withcoord), RESPPureToken("WITHDIST", withdist), RESPPureToken("WITHHASH", withhash), countBlock, order, store)
    }
}

/// Queries a geospatial index for members within a distance from a member, optionally stores the result.
@available(*, deprecated, message: "Since 6.2.0. Replaced by `GEOSEARCH` and `GEOSEARCHSTORE` with the `BYRADIUS` and `FROMMEMBER` arguments.")
public struct GEORADIUSBYMEMBER<Member: RESPStringRenderable>: ValkeyCommand {
    public enum Unit: RESPRenderable, Sendable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool


        @inlinable public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + "ANY".respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            "ANY".encode(into: &commandEncoder)
        }
    }
    public enum Order: RESPRenderable, Sendable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public enum Store: RESPRenderable, Sendable {
        case storekey(ValkeyKey)
        case storedistkey(ValkeyKey)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).respEntries
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).encode(into: &commandEncoder)
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).encode(into: &commandEncoder)
            }
        }
    }
    public var key: ValkeyKey
    public var member: Member
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool
    public var withdist: Bool
    public var withhash: Bool
    public var countBlock: CountBlock?
    public var order: Order?
    public var store: Store?

    @inlinable public init(key: ValkeyKey, member: Member, radius: Double, unit: Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: CountBlock? = nil, order: Order? = nil, store: Store? = nil) {
        self.key = key
        self.member = member
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
        self.store = store
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEORADIUSBYMEMBER", key, RESPBulkString(member), radius, unit, RESPPureToken("WITHCOORD", withcoord), RESPPureToken("WITHDIST", withdist), RESPPureToken("WITHHASH", withhash), countBlock, order, store)
    }
}

/// Returns members from a geospatial index that are within a distance from a member.
@available(*, deprecated, message: "Since 6.2.0. Replaced by `GEOSEARCH` with the `BYRADIUS` and `FROMMEMBER` arguments.")
public struct GEORADIUSBYMEMBERRO<Member: RESPStringRenderable>: ValkeyCommand {
    public enum Unit: RESPRenderable, Sendable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool


        @inlinable public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + "ANY".respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            "ANY".encode(into: &commandEncoder)
        }
    }
    public enum Order: RESPRenderable, Sendable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public var key: ValkeyKey
    public var member: Member
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool
    public var withdist: Bool
    public var withhash: Bool
    public var countBlock: CountBlock?
    public var order: Order?

    @inlinable public init(key: ValkeyKey, member: Member, radius: Double, unit: Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: CountBlock? = nil, order: Order? = nil) {
        self.key = key
        self.member = member
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEORADIUSBYMEMBER_RO", key, RESPBulkString(member), radius, unit, RESPPureToken("WITHCOORD", withcoord), RESPPureToken("WITHDIST", withdist), RESPPureToken("WITHHASH", withhash), countBlock, order)
    }
}

/// Returns members from a geospatial index that are within a distance from a coordinate.
@available(*, deprecated, message: "Since 6.2.0. Replaced by `GEOSEARCH` with the `BYRADIUS` argument.")
public struct GEORADIUSRO: ValkeyCommand {
    public enum Unit: RESPRenderable, Sendable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool


        @inlinable public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + "ANY".respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            "ANY".encode(into: &commandEncoder)
        }
    }
    public enum Order: RESPRenderable, Sendable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public var key: ValkeyKey
    public var longitude: Double
    public var latitude: Double
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool
    public var withdist: Bool
    public var withhash: Bool
    public var countBlock: CountBlock?
    public var order: Order?

    @inlinable public init(key: ValkeyKey, longitude: Double, latitude: Double, radius: Double, unit: Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: CountBlock? = nil, order: Order? = nil) {
        self.key = key
        self.longitude = longitude
        self.latitude = latitude
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEORADIUS_RO", key, longitude, latitude, radius, unit, RESPPureToken("WITHCOORD", withcoord), RESPPureToken("WITHDIST", withdist), RESPPureToken("WITHHASH", withhash), countBlock, order)
    }
}

/// Queries a geospatial index for members inside an area of a box or a circle.
public struct GEOSEARCH: ValkeyCommand {
    public struct FromFromlonlat: RESPRenderable, Sendable {
        @usableFromInline let longitude: Double
        @usableFromInline let latitude: Double


        @inlinable public init(longitude: Double, latitude: Double) {
            self.longitude = longitude
            self.latitude = latitude
        }

        @inlinable
        public var respEntries: Int {
            longitude.respEntries + latitude.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            longitude.encode(into: &commandEncoder)
            latitude.encode(into: &commandEncoder)
        }
    }
    public enum From: RESPRenderable, Sendable {
        case member(String)
        case fromlonlat(FromFromlonlat)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).respEntries
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).encode(into: &commandEncoder)
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).encode(into: &commandEncoder)
            }
        }
    }
    public enum ByCircleUnit: RESPRenderable, Sendable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByCircle: RESPRenderable, Sendable {
        @usableFromInline let radius: Double
        @usableFromInline let unit: ByCircleUnit


        @inlinable public init(radius: Double, unit: ByCircleUnit) {
            self.radius = radius
            self.unit = unit
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("BYRADIUS", radius).respEntries + unit.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("BYRADIUS", radius).encode(into: &commandEncoder)
            unit.encode(into: &commandEncoder)
        }
    }
    public enum ByBoxUnit: RESPRenderable, Sendable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByBox: RESPRenderable, Sendable {
        @usableFromInline let width: Double
        @usableFromInline let height: Double
        @usableFromInline let unit: ByBoxUnit


        @inlinable public init(width: Double, height: Double, unit: ByBoxUnit) {
            self.width = width
            self.height = height
            self.unit = unit
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("BYBOX", width).respEntries + height.respEntries + unit.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("BYBOX", width).encode(into: &commandEncoder)
            height.encode(into: &commandEncoder)
            unit.encode(into: &commandEncoder)
        }
    }
    public enum By: RESPRenderable, Sendable {
        case circle(ByCircle)
        case box(ByBox)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .circle(let circle): circle.respEntries
            case .box(let box): box.respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .circle(let circle): circle.encode(into: &commandEncoder)
            case .box(let box): box.encode(into: &commandEncoder)
            }
        }
    }
    public enum Order: RESPRenderable, Sendable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool


        @inlinable public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + "ANY".respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            "ANY".encode(into: &commandEncoder)
        }
    }
    public var key: ValkeyKey
    public var from: From
    public var by: By
    public var order: Order?
    public var countBlock: CountBlock?
    public var withcoord: Bool
    public var withdist: Bool
    public var withhash: Bool

    @inlinable public init(key: ValkeyKey, from: From, by: By, order: Order? = nil, countBlock: CountBlock? = nil, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false) {
        self.key = key
        self.from = from
        self.by = by
        self.order = order
        self.countBlock = countBlock
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEOSEARCH", key, from, by, order, countBlock, RESPPureToken("WITHCOORD", withcoord), RESPPureToken("WITHDIST", withdist), RESPPureToken("WITHHASH", withhash))
    }
}

/// Queries a geospatial index for members inside an area of a box or a circle, optionally stores the result.
public struct GEOSEARCHSTORE: ValkeyCommand {
    public struct FromFromlonlat: RESPRenderable, Sendable {
        @usableFromInline let longitude: Double
        @usableFromInline let latitude: Double


        @inlinable public init(longitude: Double, latitude: Double) {
            self.longitude = longitude
            self.latitude = latitude
        }

        @inlinable
        public var respEntries: Int {
            longitude.respEntries + latitude.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            longitude.encode(into: &commandEncoder)
            latitude.encode(into: &commandEncoder)
        }
    }
    public enum From: RESPRenderable, Sendable {
        case member(String)
        case fromlonlat(FromFromlonlat)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).respEntries
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).encode(into: &commandEncoder)
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).encode(into: &commandEncoder)
            }
        }
    }
    public enum ByCircleUnit: RESPRenderable, Sendable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByCircle: RESPRenderable, Sendable {
        @usableFromInline let radius: Double
        @usableFromInline let unit: ByCircleUnit


        @inlinable public init(radius: Double, unit: ByCircleUnit) {
            self.radius = radius
            self.unit = unit
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("BYRADIUS", radius).respEntries + unit.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("BYRADIUS", radius).encode(into: &commandEncoder)
            unit.encode(into: &commandEncoder)
        }
    }
    public enum ByBoxUnit: RESPRenderable, Sendable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "M".encode(into: &commandEncoder)
            case .km: "KM".encode(into: &commandEncoder)
            case .ft: "FT".encode(into: &commandEncoder)
            case .mi: "MI".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByBox: RESPRenderable, Sendable {
        @usableFromInline let width: Double
        @usableFromInline let height: Double
        @usableFromInline let unit: ByBoxUnit


        @inlinable public init(width: Double, height: Double, unit: ByBoxUnit) {
            self.width = width
            self.height = height
            self.unit = unit
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("BYBOX", width).respEntries + height.respEntries + unit.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("BYBOX", width).encode(into: &commandEncoder)
            height.encode(into: &commandEncoder)
            unit.encode(into: &commandEncoder)
        }
    }
    public enum By: RESPRenderable, Sendable {
        case circle(ByCircle)
        case box(ByBox)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .circle(let circle): circle.respEntries
            case .box(let box): box.respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .circle(let circle): circle.encode(into: &commandEncoder)
            case .box(let box): box.encode(into: &commandEncoder)
            }
        }
    }
    public enum Order: RESPRenderable, Sendable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable {
        @usableFromInline let count: Int
        @usableFromInline let any: Bool


        @inlinable public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + "ANY".respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            "ANY".encode(into: &commandEncoder)
        }
    }
    public typealias Response = Int

    public var destination: ValkeyKey
    public var source: ValkeyKey
    public var from: From
    public var by: By
    public var order: Order?
    public var countBlock: CountBlock?
    public var storedist: Bool

    @inlinable public init(destination: ValkeyKey, source: ValkeyKey, from: From, by: By, order: Order? = nil, countBlock: CountBlock? = nil, storedist: Bool = false) {
        self.destination = destination
        self.source = source
        self.from = from
        self.by = by
        self.order = order
        self.countBlock = countBlock
        self.storedist = storedist
    }

    public var keysAffected: [ValkeyKey] { [destination, source] }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEOSEARCHSTORE", destination, source, from, by, order, countBlock, RESPPureToken("STOREDIST", storedist))
    }
}

extension ValkeyConnection {
    /// Adds one or more members to a geospatial index. The key is created if it doesn't exist.
    ///
    /// - Documentation: [GEOADD](https:/valkey.io/commands/geoadd)
    /// - Version: 3.2.0
    /// - Complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
    /// - Categories: @write, @geo, @slow
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): When used without optional arguments, the number of elements added to the sorted set (excluding score updates).  If the CH option is specified, the number of elements that were changed (added or updated).
    @inlinable
    public func geoadd<Member: RESPStringRenderable>(key: ValkeyKey, condition: GEOADD<Member>.Condition? = nil, change: Bool = false, data: [GEOADD<Member>.Data]) async throws -> Int {
        try await send(command: GEOADD(key: key, condition: condition, change: change, data: data))
    }

    /// Returns the distance between two members of a geospatial index.
    ///
    /// - Documentation: [GEODIST](https:/valkey.io/commands/geodist)
    /// - Version: 3.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * [Null](https:/valkey.io/topics/protocol/#nulls): one or both of the elements are missing.
    ///     * [Bulk string](https:/valkey.io/topics/protocol/#bulk-strings): distance as a double (represented as a string) in the specified units.
    @inlinable
    public func geodist<Member1: RESPStringRenderable, Member2: RESPStringRenderable>(key: ValkeyKey, member1: Member1, member2: Member2, unit: GEODIST<Member1, Member2>.Unit? = nil) async throws -> RESPToken? {
        try await send(command: GEODIST(key: key, member1: member1, member2: member2, unit: unit))
    }

    /// Returns members from a geospatial index as geohash strings.
    ///
    /// - Documentation: [GEOHASH](https:/valkey.io/commands/geohash)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): an array where each element is the Geohash corresponding to each member name passed as an argument to the command.
    @inlinable
    public func geohash(key: ValkeyKey, member: [String] = []) async throws -> RESPToken.Array {
        try await send(command: GEOHASH(key: key, member: member))
    }

    /// Returns the longitude and latitude of members from a geospatial index.
    ///
    /// - Documentation: [GEOPOS](https:/valkey.io/commands/geopos)
    /// - Version: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Categories: @read, @geo, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): an array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command. Non-existing elements are reported as [Null](https:/valkey.io/topics/protocol/#nulls) elements of the array.
    @inlinable
    public func geopos(key: ValkeyKey, member: [String] = []) async throws -> RESPToken.Array {
        try await send(command: GEOPOS(key: key, member: member))
    }

    /// Queries a geospatial index for members within a distance from a coordinate, optionally stores the result.
    ///
    /// - Documentation: [GEORADIUS](https:/valkey.io/commands/georadius)
    /// - Version: 3.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @write, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/valkey.io/topics/protocol/#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/valkey.io/topics/protocol/#arrays) of arrays, where each sub-array represents a single item:
    ///         1. The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         1. The Geohash integer.
    ///         1. The coordinates as a two items x,y array (longitude,latitude).
    ///     
    ///     For example, the command `GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST` will return each item in the following way:
    ///     
    ///     `["Palermo","190.4424",["13.361389338970184","38.115556395496299"]]`
    @inlinable
    @available(*, deprecated, message: "Since 6.2.0. Replaced by `GEOSEARCH` and `GEOSEARCHSTORE` with the `BYRADIUS` argument.")
    public func georadius(key: ValkeyKey, longitude: Double, latitude: Double, radius: Double, unit: GEORADIUS.Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUS.CountBlock? = nil, order: GEORADIUS.Order? = nil, store: GEORADIUS.Store? = nil) async throws -> GEORADIUS.Response {
        try await send(command: GEORADIUS(key: key, longitude: longitude, latitude: latitude, radius: radius, unit: unit, withcoord: withcoord, withdist: withdist, withhash: withhash, countBlock: countBlock, order: order, store: store))
    }

    /// Queries a geospatial index for members within a distance from a member, optionally stores the result.
    ///
    /// - Documentation: [GEORADIUSBYMEMBER](https:/valkey.io/commands/georadiusbymember)
    /// - Version: 3.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @write, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/valkey.io/topics/protocol/#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/valkey.io/topics/protocol/#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    @available(*, deprecated, message: "Since 6.2.0. Replaced by `GEOSEARCH` and `GEOSEARCHSTORE` with the `BYRADIUS` and `FROMMEMBER` arguments.")
    public func georadiusbymember<Member: RESPStringRenderable>(key: ValkeyKey, member: Member, radius: Double, unit: GEORADIUSBYMEMBER<Member>.Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUSBYMEMBER<Member>.CountBlock? = nil, order: GEORADIUSBYMEMBER<Member>.Order? = nil, store: GEORADIUSBYMEMBER<Member>.Store? = nil) async throws -> GEORADIUSBYMEMBER.Response {
        try await send(command: GEORADIUSBYMEMBER(key: key, member: member, radius: radius, unit: unit, withcoord: withcoord, withdist: withdist, withhash: withhash, countBlock: countBlock, order: order, store: store))
    }

    /// Returns members from a geospatial index that are within a distance from a member.
    ///
    /// - Documentation: [GEORADIUSBYMEMBER_RO](https:/valkey.io/commands/georadiusbymember_ro)
    /// - Version: 3.2.10
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/valkey.io/topics/protocol/#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/valkey.io/topics/protocol/#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    @available(*, deprecated, message: "Since 6.2.0. Replaced by `GEOSEARCH` with the `BYRADIUS` and `FROMMEMBER` arguments.")
    public func georadiusbymemberRo<Member: RESPStringRenderable>(key: ValkeyKey, member: Member, radius: Double, unit: GEORADIUSBYMEMBERRO<Member>.Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUSBYMEMBERRO<Member>.CountBlock? = nil, order: GEORADIUSBYMEMBERRO<Member>.Order? = nil) async throws -> GEORADIUSBYMEMBERRO.Response {
        try await send(command: GEORADIUSBYMEMBERRO(key: key, member: member, radius: radius, unit: unit, withcoord: withcoord, withdist: withdist, withhash: withhash, countBlock: countBlock, order: order))
    }

    /// Returns members from a geospatial index that are within a distance from a coordinate.
    ///
    /// - Documentation: [GEORADIUS_RO](https:/valkey.io/commands/georadius_ro)
    /// - Version: 3.2.10
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/valkey.io/topics/protocol/#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/valkey.io/topics/protocol/#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    @available(*, deprecated, message: "Since 6.2.0. Replaced by `GEOSEARCH` with the `BYRADIUS` argument.")
    public func georadiusRo(key: ValkeyKey, longitude: Double, latitude: Double, radius: Double, unit: GEORADIUSRO.Unit, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false, countBlock: GEORADIUSRO.CountBlock? = nil, order: GEORADIUSRO.Order? = nil) async throws -> GEORADIUSRO.Response {
        try await send(command: GEORADIUSRO(key: key, longitude: longitude, latitude: latitude, radius: radius, unit: unit, withcoord: withcoord, withdist: withdist, withhash: withhash, countBlock: countBlock, order: order))
    }

    /// Queries a geospatial index for members inside an area of a box or a circle.
    ///
    /// - Documentation: [GEOSEARCH](https:/valkey.io/commands/geosearch)
    /// - Version: 6.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
    /// - Categories: @read, @geo, @slow
    /// - Returns: One of the following:
    ///     * If no `WITH*` option is specified, an [Array](https:/valkey.io/topics/protocol/#arrays) of matched member names
    ///     * If `WITHCOORD`, `WITHDIST`, or `WITHHASH` options are specified, the command returns an [Array](https:/valkey.io/topics/protocol/#arrays) of arrays, where each sub-array represents a single item:
    ///         * The distance from the center as a floating point number, in the same unit specified in the radius.
    ///         * The Geohash integer.
    ///         * The coordinates as a two items x,y array (longitude,latitude).
    @inlinable
    public func geosearch(key: ValkeyKey, from: GEOSEARCH.From, by: GEOSEARCH.By, order: GEOSEARCH.Order? = nil, countBlock: GEOSEARCH.CountBlock? = nil, withcoord: Bool = false, withdist: Bool = false, withhash: Bool = false) async throws -> GEOSEARCH.Response {
        try await send(command: GEOSEARCH(key: key, from: from, by: by, order: order, countBlock: countBlock, withcoord: withcoord, withdist: withdist, withhash: withhash))
    }

    /// Queries a geospatial index for members inside an area of a box or a circle, optionally stores the result.
    ///
    /// - Documentation: [GEOSEARCHSTORE](https:/valkey.io/commands/geosearchstore)
    /// - Version: 6.2.0
    /// - Complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
    /// - Categories: @write, @geo, @slow
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the number of elements in the resulting set
    @inlinable
    public func geosearchstore(destination: ValkeyKey, source: ValkeyKey, from: GEOSEARCHSTORE.From, by: GEOSEARCHSTORE.By, order: GEOSEARCHSTORE.Order? = nil, countBlock: GEOSEARCHSTORE.CountBlock? = nil, storedist: Bool = false) async throws -> Int {
        try await send(command: GEOSEARCHSTORE(destination: destination, source: source, from: from, by: by, order: order, countBlock: countBlock, storedist: storedist))
    }

}
