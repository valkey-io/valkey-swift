//
// This source file is part of the valkey-swift project
// Copyright (c) 2025-2026 the valkey-swift project authors
//
// See LICENSE.txt for license information
// SPDX-License-Identifier: Apache-2.0
//
// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// Adds one or more members to a geospatial index. The key is created if it doesn't exist.
@_documentation(visibility: internal)
public struct GEOADD<Member: RESPStringRenderable>: ValkeyCommand {
    public enum Condition: RESPRenderable, Sendable, Hashable {
        case nx
        case xx

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .nx: "NX".encode(into: &commandEncoder)
            case .xx: "XX".encode(into: &commandEncoder)
            }
        }
    }
    public struct Data: RESPRenderable, Sendable, Hashable {
        public var longitude: Double
        public var latitude: Double
        public var member: Member

        @inlinable
        public init(longitude: Double, latitude: Double, member: Member) {
            self.longitude = longitude
            self.latitude = latitude
            self.member = member
        }

        @inlinable
        public var respEntries: Int {
            longitude.respEntries + latitude.respEntries + RESPRenderableBulkString(member).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            longitude.encode(into: &commandEncoder)
            latitude.encode(into: &commandEncoder)
            RESPRenderableBulkString(member).encode(into: &commandEncoder)
        }
    }
    public typealias Response = Int

    @inlinable public static var name: String { "GEOADD" }

    public var key: ValkeyKey
    public var condition: Condition?
    public var change: Bool
    public var data: [Data]

    @inlinable public init(_ key: ValkeyKey, condition: Condition? = nil, change: Bool = false, data: [Data]) {
        self.key = key
        self.condition = condition
        self.change = change
        self.data = data
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEOADD", key, condition, RESPPureToken("CH", change), data)
    }
}

/// Returns the distance between two members of a geospatial index.
@_documentation(visibility: internal)
public struct GEODIST<Member1: RESPStringRenderable, Member2: RESPStringRenderable>: ValkeyCommand {
    public enum Unit: RESPRenderable, Sendable, Hashable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "m".encode(into: &commandEncoder)
            case .km: "km".encode(into: &commandEncoder)
            case .ft: "ft".encode(into: &commandEncoder)
            case .mi: "mi".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = Double?

    @inlinable public static var name: String { "GEODIST" }

    public var key: ValkeyKey
    public var member1: Member1
    public var member2: Member2
    public var unit: Unit?

    @inlinable public init(_ key: ValkeyKey, member1: Member1, member2: Member2, unit: Unit? = nil) {
        self.key = key
        self.member1 = member1
        self.member2 = member2
        self.unit = unit
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEODIST", key, RESPRenderableBulkString(member1), RESPRenderableBulkString(member2), unit)
    }
}

/// Returns members from a geospatial index as geohash strings.
@_documentation(visibility: internal)
public struct GEOHASH: ValkeyCommand {
    public typealias Response = RESPToken.Array

    @inlinable public static var name: String { "GEOHASH" }

    public var key: ValkeyKey
    public var members: [String]

    @inlinable public init(_ key: ValkeyKey, members: [String] = []) {
        self.key = key
        self.members = members
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEOHASH", key, members)
    }
}

/// Returns the longitude and latitude of members from a geospatial index.
@_documentation(visibility: internal)
public struct GEOPOS: ValkeyCommand {
    @inlinable public static var name: String { "GEOPOS" }

    public var key: ValkeyKey
    public var members: [String]

    @inlinable public init(_ key: ValkeyKey, members: [String] = []) {
        self.key = key
        self.members = members
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEOPOS", key, members)
    }
}

/// Queries a geospatial index for members within a distance from a coordinate, optionally stores the result.
@_documentation(visibility: internal)
public struct GEORADIUS: ValkeyCommand {
    public enum Unit: RESPRenderable, Sendable, Hashable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "m".encode(into: &commandEncoder)
            case .km: "km".encode(into: &commandEncoder)
            case .ft: "ft".encode(into: &commandEncoder)
            case .mi: "mi".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable, Hashable {
        public var count: Int
        public var any: Bool

        @inlinable
        public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + RESPPureToken("ANY", any).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            RESPPureToken("ANY", any).encode(into: &commandEncoder)
        }
    }
    public enum Order: RESPRenderable, Sendable, Hashable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public enum Store: RESPRenderable, Sendable, Hashable {
        case storekey(ValkeyKey)
        case storedistkey(ValkeyKey)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).respEntries
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).encode(into: &commandEncoder)
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).encode(into: &commandEncoder)
            }
        }
    }
    @inlinable public static var name: String { "GEORADIUS" }

    public var key: ValkeyKey
    public var longitude: Double
    public var latitude: Double
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool
    public var withdist: Bool
    public var withhash: Bool
    public var countBlock: CountBlock?
    public var order: Order?
    public var store: Store?

    @inlinable public init(
        _ key: ValkeyKey,
        longitude: Double,
        latitude: Double,
        radius: Double,
        unit: Unit,
        withcoord: Bool = false,
        withdist: Bool = false,
        withhash: Bool = false,
        countBlock: CountBlock? = nil,
        order: Order? = nil,
        store: Store? = nil
    ) {
        self.key = key
        self.longitude = longitude
        self.latitude = latitude
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
        self.store = store
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "GEORADIUS",
            key,
            longitude,
            latitude,
            radius,
            unit,
            RESPPureToken("WITHCOORD", withcoord),
            RESPPureToken("WITHDIST", withdist),
            RESPPureToken("WITHHASH", withhash),
            countBlock,
            order,
            store
        )
    }
}

/// Queries a geospatial index for members within a distance from a member, optionally stores the result.
@_documentation(visibility: internal)
public struct GEORADIUSBYMEMBER<Member: RESPStringRenderable>: ValkeyCommand {
    public enum Unit: RESPRenderable, Sendable, Hashable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "m".encode(into: &commandEncoder)
            case .km: "km".encode(into: &commandEncoder)
            case .ft: "ft".encode(into: &commandEncoder)
            case .mi: "mi".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable, Hashable {
        public var count: Int
        public var any: Bool

        @inlinable
        public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + RESPPureToken("ANY", any).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            RESPPureToken("ANY", any).encode(into: &commandEncoder)
        }
    }
    public enum Order: RESPRenderable, Sendable, Hashable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public enum Store: RESPRenderable, Sendable, Hashable {
        case storekey(ValkeyKey)
        case storedistkey(ValkeyKey)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).respEntries
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .storekey(let storekey): RESPWithToken("STORE", storekey).encode(into: &commandEncoder)
            case .storedistkey(let storedistkey): RESPWithToken("STOREDIST", storedistkey).encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = GeoSearchEntries

    @inlinable public static var name: String { "GEORADIUSBYMEMBER" }

    public var key: ValkeyKey
    public var member: Member
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool
    public var withdist: Bool
    public var withhash: Bool
    public var countBlock: CountBlock?
    public var order: Order?
    public var store: Store?

    @inlinable public init(
        _ key: ValkeyKey,
        member: Member,
        radius: Double,
        unit: Unit,
        withcoord: Bool = false,
        withdist: Bool = false,
        withhash: Bool = false,
        countBlock: CountBlock? = nil,
        order: Order? = nil,
        store: Store? = nil
    ) {
        self.key = key
        self.member = member
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
        self.store = store
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "GEORADIUSBYMEMBER",
            key,
            RESPRenderableBulkString(member),
            radius,
            unit,
            RESPPureToken("WITHCOORD", withcoord),
            RESPPureToken("WITHDIST", withdist),
            RESPPureToken("WITHHASH", withhash),
            countBlock,
            order,
            store
        )
    }
}

/// Returns members from a geospatial index that are within a distance from a member.
@_documentation(visibility: internal)
public struct GEORADIUSBYMEMBERRO<Member: RESPStringRenderable>: ValkeyCommand {
    public enum Unit: RESPRenderable, Sendable, Hashable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "m".encode(into: &commandEncoder)
            case .km: "km".encode(into: &commandEncoder)
            case .ft: "ft".encode(into: &commandEncoder)
            case .mi: "mi".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable, Hashable {
        public var count: Int
        public var any: Bool

        @inlinable
        public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + RESPPureToken("ANY", any).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            RESPPureToken("ANY", any).encode(into: &commandEncoder)
        }
    }
    public enum Order: RESPRenderable, Sendable, Hashable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = GeoSearchEntries

    @inlinable public static var name: String { "GEORADIUSBYMEMBER_RO" }

    public var key: ValkeyKey
    public var member: Member
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool
    public var withdist: Bool
    public var withhash: Bool
    public var countBlock: CountBlock?
    public var order: Order?

    @inlinable public init(
        _ key: ValkeyKey,
        member: Member,
        radius: Double,
        unit: Unit,
        withcoord: Bool = false,
        withdist: Bool = false,
        withhash: Bool = false,
        countBlock: CountBlock? = nil,
        order: Order? = nil
    ) {
        self.key = key
        self.member = member
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "GEORADIUSBYMEMBER_RO",
            key,
            RESPRenderableBulkString(member),
            radius,
            unit,
            RESPPureToken("WITHCOORD", withcoord),
            RESPPureToken("WITHDIST", withdist),
            RESPPureToken("WITHHASH", withhash),
            countBlock,
            order
        )
    }
}

/// Returns members from a geospatial index that are within a distance from a coordinate.
@_documentation(visibility: internal)
public struct GEORADIUSRO: ValkeyCommand {
    public enum Unit: RESPRenderable, Sendable, Hashable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "m".encode(into: &commandEncoder)
            case .km: "km".encode(into: &commandEncoder)
            case .ft: "ft".encode(into: &commandEncoder)
            case .mi: "mi".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable, Hashable {
        public var count: Int
        public var any: Bool

        @inlinable
        public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + RESPPureToken("ANY", any).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            RESPPureToken("ANY", any).encode(into: &commandEncoder)
        }
    }
    public enum Order: RESPRenderable, Sendable, Hashable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    @inlinable public static var name: String { "GEORADIUS_RO" }

    public var key: ValkeyKey
    public var longitude: Double
    public var latitude: Double
    public var radius: Double
    public var unit: Unit
    public var withcoord: Bool
    public var withdist: Bool
    public var withhash: Bool
    public var countBlock: CountBlock?
    public var order: Order?

    @inlinable public init(
        _ key: ValkeyKey,
        longitude: Double,
        latitude: Double,
        radius: Double,
        unit: Unit,
        withcoord: Bool = false,
        withdist: Bool = false,
        withhash: Bool = false,
        countBlock: CountBlock? = nil,
        order: Order? = nil
    ) {
        self.key = key
        self.longitude = longitude
        self.latitude = latitude
        self.radius = radius
        self.unit = unit
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
        self.countBlock = countBlock
        self.order = order
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "GEORADIUS_RO",
            key,
            longitude,
            latitude,
            radius,
            unit,
            RESPPureToken("WITHCOORD", withcoord),
            RESPPureToken("WITHDIST", withdist),
            RESPPureToken("WITHHASH", withhash),
            countBlock,
            order
        )
    }
}

/// Queries a geospatial index for members inside an area of a box, circle, or a polygon.
@_documentation(visibility: internal)
public struct GEOSEARCH: ValkeyCommand {
    public struct FromFromlonlat: RESPRenderable, Sendable, Hashable {
        public var longitude: Double
        public var latitude: Double

        @inlinable
        public init(longitude: Double, latitude: Double) {
            self.longitude = longitude
            self.latitude = latitude
        }

        @inlinable
        public var respEntries: Int {
            longitude.respEntries + latitude.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            longitude.encode(into: &commandEncoder)
            latitude.encode(into: &commandEncoder)
        }
    }
    public enum From: RESPRenderable, Sendable, Hashable {
        case member(String)
        case fromlonlat(FromFromlonlat)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).respEntries
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).encode(into: &commandEncoder)
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).encode(into: &commandEncoder)
            }
        }
    }
    public enum ByCircleUnit: RESPRenderable, Sendable, Hashable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "m".encode(into: &commandEncoder)
            case .km: "km".encode(into: &commandEncoder)
            case .ft: "ft".encode(into: &commandEncoder)
            case .mi: "mi".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByCircle: RESPRenderable, Sendable, Hashable {
        public var radius: Double
        public var unit: ByCircleUnit

        @inlinable
        public init(radius: Double, unit: ByCircleUnit) {
            self.radius = radius
            self.unit = unit
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("BYRADIUS", radius).respEntries + unit.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("BYRADIUS", radius).encode(into: &commandEncoder)
            unit.encode(into: &commandEncoder)
        }
    }
    public enum ByBoxUnit: RESPRenderable, Sendable, Hashable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "m".encode(into: &commandEncoder)
            case .km: "km".encode(into: &commandEncoder)
            case .ft: "ft".encode(into: &commandEncoder)
            case .mi: "mi".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByBox: RESPRenderable, Sendable, Hashable {
        public var width: Double
        public var height: Double
        public var unit: ByBoxUnit

        @inlinable
        public init(width: Double, height: Double, unit: ByBoxUnit) {
            self.width = width
            self.height = height
            self.unit = unit
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("BYBOX", width).respEntries + height.respEntries + unit.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("BYBOX", width).encode(into: &commandEncoder)
            height.encode(into: &commandEncoder)
            unit.encode(into: &commandEncoder)
        }
    }
    public struct ByPolygonVertices: RESPRenderable, Sendable, Hashable {
        public var longitude: Double
        public var latitude: Double

        @inlinable
        public init(longitude: Double, latitude: Double) {
            self.longitude = longitude
            self.latitude = latitude
        }

        @inlinable
        public var respEntries: Int {
            longitude.respEntries + latitude.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            longitude.encode(into: &commandEncoder)
            latitude.encode(into: &commandEncoder)
        }
    }
    public struct ByPolygon: RESPRenderable, Sendable, Hashable {
        public var numVertices: Int
        public var vertices: [ByPolygonVertices]

        @inlinable
        public init(numVertices: Int, vertices: [ByPolygonVertices]) {
            self.numVertices = numVertices
            self.vertices = vertices
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("BYPOLYGON", numVertices).respEntries + vertices.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("BYPOLYGON", numVertices).encode(into: &commandEncoder)
            vertices.encode(into: &commandEncoder)
        }
    }
    public enum By: RESPRenderable, Sendable, Hashable {
        case circle(ByCircle)
        case box(ByBox)
        case polygon(ByPolygon)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .circle(let circle): circle.respEntries
            case .box(let box): box.respEntries
            case .polygon(let polygon): polygon.respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .circle(let circle): circle.encode(into: &commandEncoder)
            case .box(let box): box.encode(into: &commandEncoder)
            case .polygon(let polygon): polygon.encode(into: &commandEncoder)
            }
        }
    }
    public enum Order: RESPRenderable, Sendable, Hashable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable, Hashable {
        public var count: Int
        public var any: Bool

        @inlinable
        public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + RESPPureToken("ANY", any).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            RESPPureToken("ANY", any).encode(into: &commandEncoder)
        }
    }
    @inlinable public static var name: String { "GEOSEARCH" }

    public var key: ValkeyKey
    public var from: From?
    public var by: By
    public var order: Order?
    public var countBlock: CountBlock?
    public var withcoord: Bool
    public var withdist: Bool
    public var withhash: Bool

    @inlinable public init(
        _ key: ValkeyKey,
        from: From? = nil,
        by: By,
        order: Order? = nil,
        countBlock: CountBlock? = nil,
        withcoord: Bool = false,
        withdist: Bool = false,
        withhash: Bool = false
    ) {
        self.key = key
        self.from = from
        self.by = by
        self.order = order
        self.countBlock = countBlock
        self.withcoord = withcoord
        self.withdist = withdist
        self.withhash = withhash
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "GEOSEARCH",
            key,
            from,
            by,
            order,
            countBlock,
            RESPPureToken("WITHCOORD", withcoord),
            RESPPureToken("WITHDIST", withdist),
            RESPPureToken("WITHHASH", withhash)
        )
    }
}

/// Queries a geospatial index for members inside an area of a box, a circle, or a polygon, optionally stores the result.
@_documentation(visibility: internal)
public struct GEOSEARCHSTORE: ValkeyCommand {
    public struct FromFromlonlat: RESPRenderable, Sendable, Hashable {
        public var longitude: Double
        public var latitude: Double

        @inlinable
        public init(longitude: Double, latitude: Double) {
            self.longitude = longitude
            self.latitude = latitude
        }

        @inlinable
        public var respEntries: Int {
            longitude.respEntries + latitude.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            longitude.encode(into: &commandEncoder)
            latitude.encode(into: &commandEncoder)
        }
    }
    public enum From: RESPRenderable, Sendable, Hashable {
        case member(String)
        case fromlonlat(FromFromlonlat)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).respEntries
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .member(let member): RESPWithToken("FROMMEMBER", member).encode(into: &commandEncoder)
            case .fromlonlat(let fromlonlat): RESPWithToken("FROMLONLAT", fromlonlat).encode(into: &commandEncoder)
            }
        }
    }
    public enum ByCircleUnit: RESPRenderable, Sendable, Hashable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "m".encode(into: &commandEncoder)
            case .km: "km".encode(into: &commandEncoder)
            case .ft: "ft".encode(into: &commandEncoder)
            case .mi: "mi".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByCircle: RESPRenderable, Sendable, Hashable {
        public var radius: Double
        public var unit: ByCircleUnit

        @inlinable
        public init(radius: Double, unit: ByCircleUnit) {
            self.radius = radius
            self.unit = unit
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("BYRADIUS", radius).respEntries + unit.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("BYRADIUS", radius).encode(into: &commandEncoder)
            unit.encode(into: &commandEncoder)
        }
    }
    public enum ByBoxUnit: RESPRenderable, Sendable, Hashable {
        case m
        case km
        case ft
        case mi

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .m: "m".encode(into: &commandEncoder)
            case .km: "km".encode(into: &commandEncoder)
            case .ft: "ft".encode(into: &commandEncoder)
            case .mi: "mi".encode(into: &commandEncoder)
            }
        }
    }
    public struct ByBox: RESPRenderable, Sendable, Hashable {
        public var width: Double
        public var height: Double
        public var unit: ByBoxUnit

        @inlinable
        public init(width: Double, height: Double, unit: ByBoxUnit) {
            self.width = width
            self.height = height
            self.unit = unit
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("BYBOX", width).respEntries + height.respEntries + unit.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("BYBOX", width).encode(into: &commandEncoder)
            height.encode(into: &commandEncoder)
            unit.encode(into: &commandEncoder)
        }
    }
    public struct ByPolygonVertices: RESPRenderable, Sendable, Hashable {
        public var longitude: Double
        public var latitude: Double

        @inlinable
        public init(longitude: Double, latitude: Double) {
            self.longitude = longitude
            self.latitude = latitude
        }

        @inlinable
        public var respEntries: Int {
            longitude.respEntries + latitude.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            longitude.encode(into: &commandEncoder)
            latitude.encode(into: &commandEncoder)
        }
    }
    public struct ByPolygon: RESPRenderable, Sendable, Hashable {
        public var numVertices: Int
        public var vertices: [ByPolygonVertices]

        @inlinable
        public init(numVertices: Int, vertices: [ByPolygonVertices]) {
            self.numVertices = numVertices
            self.vertices = vertices
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("BYPOLYGON", numVertices).respEntries + vertices.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("BYPOLYGON", numVertices).encode(into: &commandEncoder)
            vertices.encode(into: &commandEncoder)
        }
    }
    public enum By: RESPRenderable, Sendable, Hashable {
        case circle(ByCircle)
        case box(ByBox)
        case polygon(ByPolygon)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .circle(let circle): circle.respEntries
            case .box(let box): box.respEntries
            case .polygon(let polygon): polygon.respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .circle(let circle): circle.encode(into: &commandEncoder)
            case .box(let box): box.encode(into: &commandEncoder)
            case .polygon(let polygon): polygon.encode(into: &commandEncoder)
            }
        }
    }
    public enum Order: RESPRenderable, Sendable, Hashable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public struct CountBlock: RESPRenderable, Sendable, Hashable {
        public var count: Int
        public var any: Bool

        @inlinable
        public init(count: Int, any: Bool = false) {
            self.count = count
            self.any = any
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("COUNT", count).respEntries + RESPPureToken("ANY", any).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            RESPPureToken("ANY", any).encode(into: &commandEncoder)
        }
    }
    public typealias Response = Int

    @inlinable public static var name: String { "GEOSEARCHSTORE" }

    public var destination: ValkeyKey
    public var source: ValkeyKey
    public var from: From?
    public var by: By
    public var order: Order?
    public var countBlock: CountBlock?
    public var storedist: Bool

    @inlinable public init(
        destination: ValkeyKey,
        source: ValkeyKey,
        from: From? = nil,
        by: By,
        order: Order? = nil,
        countBlock: CountBlock? = nil,
        storedist: Bool = false
    ) {
        self.destination = destination
        self.source = source
        self.from = from
        self.by = by
        self.order = order
        self.countBlock = countBlock
        self.storedist = storedist
    }

    public var keysAffected: [ValkeyKey] { [destination, source] }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GEOSEARCHSTORE", destination, source, from, by, order, countBlock, RESPPureToken("STOREDIST", storedist))
    }
}

@available(valkeySwift 1.0, *)
extension ValkeyClientProtocol {
    /// Adds one or more members to a geospatial index. The key is created if it doesn't exist.
    ///
    /// - Documentation: [GEOADD](https://valkey.io/commands/geoadd)
    /// - Available: 3.2.0
    /// - History:
    ///     * 6.2.0: Added the `CH`, `NX` and `XX` options.
    /// - Complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set.
    /// - Response: When used without optional arguments, the number of elements added to the sorted set (excluding score updates).  If the CH option is specified, the number of elements that were changed (added or updated).
    @inlinable
    @discardableResult
    public func geoadd<Member: RESPStringRenderable>(
        _ key: ValkeyKey,
        condition: GEOADD<Member>.Condition? = nil,
        change: Bool = false,
        data: [GEOADD<Member>.Data]
    ) async throws(ValkeyClientError) -> Int {
        try await execute(GEOADD(key, condition: condition, change: change, data: data))
    }

    /// Returns the distance between two members of a geospatial index.
    ///
    /// - Documentation: [GEODIST](https://valkey.io/commands/geodist)
    /// - Available: 3.2.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * (nil): One or both of elements are missing.
    ///     * Distance as a double (represented as a string) in the specified units.
    @inlinable
    public func geodist<Member1: RESPStringRenderable, Member2: RESPStringRenderable>(
        _ key: ValkeyKey,
        member1: Member1,
        member2: Member2,
        unit: GEODIST<Member1, Member2>.Unit? = nil
    ) async throws(ValkeyClientError) -> Double? {
        try await execute(GEODIST(key, member1: member1, member2: member2, unit: unit))
    }

    /// Returns members from a geospatial index as geohash strings.
    ///
    /// - Documentation: [GEOHASH](https://valkey.io/commands/geohash)
    /// - Available: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Response: An array where each element is the Geohash corresponding to each member name passed as argument to the command.
    @inlinable
    public func geohash(_ key: ValkeyKey, members: [String] = []) async throws(ValkeyClientError) -> RESPToken.Array {
        try await execute(GEOHASH(key, members: members))
    }

    /// Returns the longitude and latitude of members from a geospatial index.
    ///
    /// - Documentation: [GEOPOS](https://valkey.io/commands/geopos)
    /// - Available: 3.2.0
    /// - Complexity: O(1) for each member requested.
    /// - Response: An array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command
    @inlinable
    public func geopos(_ key: ValkeyKey, members: [String] = []) async throws(ValkeyClientError) -> GEOPOS.Response {
        try await execute(GEOPOS(key, members: members))
    }

    /// Queries a geospatial index for members within a distance from a coordinate, optionally stores the result.
    ///
    /// - Documentation: [GEORADIUS](https://valkey.io/commands/georadius)
    /// - Available: 3.2.0
    /// - History:
    ///     * 6.2.0: Added the `ANY` option for `COUNT`.
    ///     * 7.0.0: Added support for uppercase unit names.
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Response: Array of matched members information.
    @inlinable
    @discardableResult
    public func georadius(
        _ key: ValkeyKey,
        longitude: Double,
        latitude: Double,
        radius: Double,
        unit: GEORADIUS.Unit,
        withcoord: Bool = false,
        withdist: Bool = false,
        withhash: Bool = false,
        countBlock: GEORADIUS.CountBlock? = nil,
        order: GEORADIUS.Order? = nil,
        store: GEORADIUS.Store? = nil
    ) async throws(ValkeyClientError) -> GEORADIUS.Response {
        try await execute(
            GEORADIUS(
                key,
                longitude: longitude,
                latitude: latitude,
                radius: radius,
                unit: unit,
                withcoord: withcoord,
                withdist: withdist,
                withhash: withhash,
                countBlock: countBlock,
                order: order,
                store: store
            )
        )
    }

    /// Queries a geospatial index for members within a distance from a member, optionally stores the result.
    ///
    /// - Documentation: [GEORADIUSBYMEMBER](https://valkey.io/commands/georadiusbymember)
    /// - Available: 3.2.0
    /// - History:
    ///     * 6.2.0: Added the `ANY` option for `COUNT`.
    ///     * 7.0.0: Added support for uppercase unit names.
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Response: Array of matched members information.
    @inlinable
    @discardableResult
    public func georadiusbymember<Member: RESPStringRenderable>(
        _ key: ValkeyKey,
        member: Member,
        radius: Double,
        unit: GEORADIUSBYMEMBER<Member>.Unit,
        withcoord: Bool = false,
        withdist: Bool = false,
        withhash: Bool = false,
        countBlock: GEORADIUSBYMEMBER<Member>.CountBlock? = nil,
        order: GEORADIUSBYMEMBER<Member>.Order? = nil,
        store: GEORADIUSBYMEMBER<Member>.Store? = nil
    ) async throws(ValkeyClientError) -> GeoSearchEntries {
        try await execute(
            GEORADIUSBYMEMBER(
                key,
                member: member,
                radius: radius,
                unit: unit,
                withcoord: withcoord,
                withdist: withdist,
                withhash: withhash,
                countBlock: countBlock,
                order: order,
                store: store
            )
        )
    }

    /// Returns members from a geospatial index that are within a distance from a member.
    ///
    /// - Documentation: [GEORADIUSBYMEMBER_RO](https://valkey.io/commands/georadiusbymember_ro)
    /// - Available: 3.2.10
    /// - History:
    ///     * 6.2.0: Added the `ANY` option for `COUNT`.
    ///     * 7.0.0: Added support for uppercase unit names.
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Response: Array of matched members information.
    @inlinable
    public func georadiusbymemberRo<Member: RESPStringRenderable>(
        _ key: ValkeyKey,
        member: Member,
        radius: Double,
        unit: GEORADIUSBYMEMBERRO<Member>.Unit,
        withcoord: Bool = false,
        withdist: Bool = false,
        withhash: Bool = false,
        countBlock: GEORADIUSBYMEMBERRO<Member>.CountBlock? = nil,
        order: GEORADIUSBYMEMBERRO<Member>.Order? = nil
    ) async throws(ValkeyClientError) -> GeoSearchEntries {
        try await execute(
            GEORADIUSBYMEMBERRO(
                key,
                member: member,
                radius: radius,
                unit: unit,
                withcoord: withcoord,
                withdist: withdist,
                withhash: withhash,
                countBlock: countBlock,
                order: order
            )
        )
    }

    /// Returns members from a geospatial index that are within a distance from a coordinate.
    ///
    /// - Documentation: [GEORADIUS_RO](https://valkey.io/commands/georadius_ro)
    /// - Available: 3.2.10
    /// - History:
    ///     * 6.2.0: Added the `ANY` option for `COUNT`.
    ///     * 7.0.0: Added support for uppercase unit names.
    /// - Complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.
    /// - Response: Array of matched members information.
    @inlinable
    public func georadiusRo(
        _ key: ValkeyKey,
        longitude: Double,
        latitude: Double,
        radius: Double,
        unit: GEORADIUSRO.Unit,
        withcoord: Bool = false,
        withdist: Bool = false,
        withhash: Bool = false,
        countBlock: GEORADIUSRO.CountBlock? = nil,
        order: GEORADIUSRO.Order? = nil
    ) async throws(ValkeyClientError) -> GEORADIUSRO.Response {
        try await execute(
            GEORADIUSRO(
                key,
                longitude: longitude,
                latitude: latitude,
                radius: radius,
                unit: unit,
                withcoord: withcoord,
                withdist: withdist,
                withhash: withhash,
                countBlock: countBlock,
                order: order
            )
        )
    }

    /// Queries a geospatial index for members inside an area of a box, circle, or a polygon.
    ///
    /// - Documentation: [GEOSEARCH](https://valkey.io/commands/geosearch)
    /// - Available: 6.2.0
    /// - History:
    ///     * 7.0.0: Added support for uppercase unit names.
    ///     * 9.0.0: Added support for the BYPOLYGON option.
    /// - Complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
    /// - Response: Array of matched members information.
    @inlinable
    public func geosearch(
        _ key: ValkeyKey,
        from: GEOSEARCH.From? = nil,
        by: GEOSEARCH.By,
        order: GEOSEARCH.Order? = nil,
        countBlock: GEOSEARCH.CountBlock? = nil,
        withcoord: Bool = false,
        withdist: Bool = false,
        withhash: Bool = false
    ) async throws(ValkeyClientError) -> GEOSEARCH.Response {
        try await execute(
            GEOSEARCH(key, from: from, by: by, order: order, countBlock: countBlock, withcoord: withcoord, withdist: withdist, withhash: withhash)
        )
    }

    /// Queries a geospatial index for members inside an area of a box, a circle, or a polygon, optionally stores the result.
    ///
    /// - Documentation: [GEOSEARCHSTORE](https://valkey.io/commands/geosearchstore)
    /// - Available: 6.2.0
    /// - History:
    ///     * 7.0.0: Added support for uppercase unit names.
    ///     * 9.0.0: Added support for the BYPOLYGON option.
    /// - Complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape
    /// - Response: The number of elements in the resulting set.
    @inlinable
    @discardableResult
    public func geosearchstore(
        destination: ValkeyKey,
        source: ValkeyKey,
        from: GEOSEARCHSTORE.From? = nil,
        by: GEOSEARCHSTORE.By,
        order: GEOSEARCHSTORE.Order? = nil,
        countBlock: GEOSEARCHSTORE.CountBlock? = nil,
        storedist: Bool = false
    ) async throws(ValkeyClientError) -> Int {
        try await execute(
            GEOSEARCHSTORE(destination: destination, source: source, from: from, by: by, order: order, countBlock: countBlock, storedist: storedist)
        )
    }

}
