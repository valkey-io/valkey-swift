//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-valkey open source project
//
// Copyright (c) 2025 Apple Inc. and the swift-valkey project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-valkey project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension CLIENT {
    /// Instructs the server whether to track the keys in the next request.
    public struct CACHING: ValkeyCommand {
        public enum Mode: RESPRenderable, Sendable {
            case yes
            case no

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        public var mode: Mode

        @inlinable public init(mode: Mode) {
            self.mode = mode
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "CACHING", mode)
        }
    }

    /// A client claims its capability.
    public struct CAPA<Capability: RESPStringRenderable>: ValkeyCommand {
        public var capability: [Capability]

        @inlinable public init(capability: [Capability]) {
            self.capability = capability
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "CAPA", capability.map { RESPBulkString($0) })
        }
    }

    /// Returns the name of the connection.
    public struct GETNAME: ValkeyCommand {
        public typealias Response = RESPToken?

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "GETNAME")
        }
    }

    /// Returns the client ID to which the connection's tracking notifications are redirected.
    public struct GETREDIR: ValkeyCommand {
        public typealias Response = Int

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "GETREDIR")
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: ValkeyCommand {
        public typealias Response = RESPToken.Array

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "HELP")
        }
    }

    /// Returns the unique client ID of the connection.
    public struct ID: ValkeyCommand {
        public typealias Response = Int

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "ID")
        }
    }

    /// Mark this client as an import source when server is in import mode.
    public struct IMPORTSOURCE: ValkeyCommand {
        public enum Enabled: RESPRenderable, Sendable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "IMPORT-SOURCE", enabled)
        }
    }

    /// Returns information about the connection.
    public struct INFO: ValkeyCommand {
        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "INFO")
        }
    }

    /// Terminates open connections.
    public struct KILL: ValkeyCommand {
        public enum FilterNewFormatClientType: RESPRenderable, Sendable {
            case normal
            case master
            case primary
            case slave
            case replica
            case pubsub

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .normal: "normal".encode(into: &commandEncoder)
                case .master: "master".encode(into: &commandEncoder)
                case .primary: "primary".encode(into: &commandEncoder)
                case .slave: "slave".encode(into: &commandEncoder)
                case .replica: "replica".encode(into: &commandEncoder)
                case .pubsub: "pubsub".encode(into: &commandEncoder)
                }
            }
        }
        public enum FilterNewFormatSkipme: RESPRenderable, Sendable {
            case yes
            case no

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        public enum FilterNewFormat: RESPRenderable, Sendable {
            case clientId([Int])
            case clientType(FilterNewFormatClientType?)
            case username(String?)
            case addr(String?)
            case laddr(String?)
            case skipme(FilterNewFormatSkipme?)
            case maxage(Int?)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .clientId(let clientId): RESPWithToken("ID", clientId).respEntries
                case .clientType(let clientType): RESPWithToken("TYPE", clientType).respEntries
                case .username(let username): RESPWithToken("USER", username).respEntries
                case .addr(let addr): RESPWithToken("ADDR", addr).respEntries
                case .laddr(let laddr): RESPWithToken("LADDR", laddr).respEntries
                case .skipme(let skipme): RESPWithToken("SKIPME", skipme).respEntries
                case .maxage(let maxage): RESPWithToken("MAXAGE", maxage).respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .clientId(let clientId): RESPWithToken("ID", clientId).encode(into: &commandEncoder)
                case .clientType(let clientType): RESPWithToken("TYPE", clientType).encode(into: &commandEncoder)
                case .username(let username): RESPWithToken("USER", username).encode(into: &commandEncoder)
                case .addr(let addr): RESPWithToken("ADDR", addr).encode(into: &commandEncoder)
                case .laddr(let laddr): RESPWithToken("LADDR", laddr).encode(into: &commandEncoder)
                case .skipme(let skipme): RESPWithToken("SKIPME", skipme).encode(into: &commandEncoder)
                case .maxage(let maxage): RESPWithToken("MAXAGE", maxage).encode(into: &commandEncoder)
                }
            }
        }
        public enum Filter: RESPRenderable, Sendable {
            case oldFormat(String)
            case newFormat([FilterNewFormat])

            @inlinable
            public var respEntries: Int {
                switch self {
                case .oldFormat(let oldFormat): oldFormat.respEntries
                case .newFormat(let newFormat): newFormat.respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .oldFormat(let oldFormat): oldFormat.encode(into: &commandEncoder)
                case .newFormat(let newFormat): newFormat.encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = Int?

        public var filter: Filter

        @inlinable public init(filter: Filter) {
            self.filter = filter
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "KILL", filter)
        }
    }

    /// Lists open connections.
    public struct LIST: ValkeyCommand {
        public enum ClientType: RESPRenderable, Sendable {
            case normal
            case master
            case replica
            case pubsub

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .normal: "normal".encode(into: &commandEncoder)
                case .master: "master".encode(into: &commandEncoder)
                case .replica: "replica".encode(into: &commandEncoder)
                case .pubsub: "pubsub".encode(into: &commandEncoder)
                }
            }
        }
        public enum Skipme: RESPRenderable, Sendable {
            case yes
            case no

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        public var clientType: ClientType?
        public var clientId: [Int]
        public var username: String?
        public var addr: String?
        public var laddr: String?
        public var skipme: Skipme?
        public var maxage: Int?

        @inlinable public init(clientType: ClientType? = nil, clientId: [Int] = [], username: String? = nil, addr: String? = nil, laddr: String? = nil, skipme: Skipme? = nil, maxage: Int? = nil) {
            self.clientType = clientType
            self.clientId = clientId
            self.username = username
            self.addr = addr
            self.laddr = laddr
            self.skipme = skipme
            self.maxage = maxage
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "LIST", RESPWithToken("TYPE", clientType), RESPWithToken("ID", clientId), RESPWithToken("USER", username), RESPWithToken("ADDR", addr), RESPWithToken("LADDR", laddr), RESPWithToken("SKIPME", skipme), RESPWithToken("MAXAGE", maxage))
        }
    }

    /// Sets the client eviction mode of the connection.
    public struct NOEVICT: ValkeyCommand {
        public enum Enabled: RESPRenderable, Sendable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "NO-EVICT", enabled)
        }
    }

    /// Controls whether commands sent by the client affect the LRU/LFU of accessed keys.
    public struct NOTOUCH: ValkeyCommand {
        public enum Enabled: RESPRenderable, Sendable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "NO-TOUCH", enabled)
        }
    }

    /// Suspends commands processing.
    public struct PAUSE: ValkeyCommand {
        public enum Mode: RESPRenderable, Sendable {
            case write
            case all

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .write: "WRITE".encode(into: &commandEncoder)
                case .all: "ALL".encode(into: &commandEncoder)
                }
            }
        }
        public var timeout: Int
        public var mode: Mode?

        @inlinable public init(timeout: Int, mode: Mode? = nil) {
            self.timeout = timeout
            self.mode = mode
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "PAUSE", timeout, mode)
        }
    }

    /// Instructs the server whether to reply to commands.
    public struct REPLY: ValkeyCommand {
        public enum Action: RESPRenderable, Sendable {
            case on
            case off
            case skip

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                case .skip: "SKIP".encode(into: &commandEncoder)
                }
            }
        }
        public var action: Action

        @inlinable public init(action: Action) {
            self.action = action
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "REPLY", action)
        }
    }

    /// Sets information specific to the client or connection.
    public struct SETINFO: ValkeyCommand {
        public enum Attr: RESPRenderable, Sendable {
            case libname(String)
            case libver(String)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .libname(let libname): RESPWithToken("lib-name", libname).respEntries
                case .libver(let libver): RESPWithToken("lib-ver", libver).respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .libname(let libname): RESPWithToken("lib-name", libname).encode(into: &commandEncoder)
                case .libver(let libver): RESPWithToken("lib-ver", libver).encode(into: &commandEncoder)
                }
            }
        }
        public var attr: Attr

        @inlinable public init(attr: Attr) {
            self.attr = attr
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "SETINFO", attr)
        }
    }

    /// Sets the connection name.
    public struct SETNAME<ConnectionName: RESPStringRenderable>: ValkeyCommand {
        public var connectionName: ConnectionName

        @inlinable public init(connectionName: ConnectionName) {
            self.connectionName = connectionName
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "SETNAME", RESPBulkString(connectionName))
        }
    }

    /// Controls server-assisted client-side caching for the connection.
    public struct TRACKING: ValkeyCommand {
        public enum Status: RESPRenderable, Sendable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public var status: Status
        public var clientId: Int?
        public var prefix: [String]
        public var bcast: Bool
        public var optin: Bool
        public var optout: Bool
        public var noloop: Bool

        @inlinable public init(status: Status, clientId: Int? = nil, prefix: [String] = [], bcast: Bool = false, optin: Bool = false, optout: Bool = false, noloop: Bool = false) {
            self.status = status
            self.clientId = clientId
            self.prefix = prefix
            self.bcast = bcast
            self.optin = optin
            self.optout = optout
            self.noloop = noloop
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "TRACKING", status, RESPWithToken("REDIRECT", clientId), RESPWithToken("PREFIX", prefix), RESPPureToken("BCAST", bcast), RESPPureToken("OPTIN", optin), RESPPureToken("OPTOUT", optout), RESPPureToken("NOLOOP", noloop))
        }
    }

    /// Returns information about server-assisted client-side caching for the connection.
    public struct TRACKINGINFO: ValkeyCommand {
        public typealias Response = RESPToken.Map

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "TRACKINGINFO")
        }
    }

    /// Unblocks a client blocked by a blocking command from a different connection.
    public struct UNBLOCK: ValkeyCommand {
        public enum UnblockType: RESPRenderable, Sendable {
            case timeout
            case error

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .timeout: "TIMEOUT".encode(into: &commandEncoder)
                case .error: "ERROR".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = Int

        public var clientId: Int
        public var unblockType: UnblockType?

        @inlinable public init(clientId: Int, unblockType: UnblockType? = nil) {
            self.clientId = clientId
            self.unblockType = unblockType
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "UNBLOCK", clientId, unblockType)
        }
    }

    /// Resumes processing commands from paused clients.
    public struct UNPAUSE: ValkeyCommand {
        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "UNPAUSE")
        }
    }

}

/// Authenticates the connection.
public struct AUTH<Password: RESPStringRenderable>: ValkeyCommand {
    public var username: String?
    public var password: Password

    @inlinable public init(username: String? = nil, password: Password) {
        self.username = username
        self.password = password
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("AUTH", username, RESPBulkString(password))
    }
}

/// A container for client connection commands.
public struct CLIENT: ValkeyCommand {
    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("CLIENT")
    }
}

/// Returns the given string.
public struct ECHO<Message: RESPStringRenderable>: ValkeyCommand {
    public var message: Message

    @inlinable public init(message: Message) {
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("ECHO", RESPBulkString(message))
    }
}

/// Handshakes with the server.
public struct HELLO: ValkeyCommand {
    public struct ArgumentsAuth: RESPRenderable, Sendable {
        @usableFromInline let username: String
        @usableFromInline let password: String


        @inlinable public init(username: String, password: String) {
            self.username = username
            self.password = password
        }

        @inlinable
        public var respEntries: Int {
            username.respEntries + password.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            username.encode(into: &commandEncoder)
            password.encode(into: &commandEncoder)
        }
    }
    public struct Arguments: RESPRenderable, Sendable {
        @usableFromInline let protover: Int
        @usableFromInline let auth: ArgumentsAuth?
        @usableFromInline let clientname: String?


        @inlinable public init(protover: Int, auth: ArgumentsAuth? = nil, clientname: String? = nil) {
            self.protover = protover
            self.auth = auth
            self.clientname = clientname
        }

        @inlinable
        public var respEntries: Int {
            protover.respEntries + RESPWithToken("AUTH", auth).respEntries + RESPWithToken("SETNAME", clientname).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            protover.encode(into: &commandEncoder)
            RESPWithToken("AUTH", auth).encode(into: &commandEncoder)
            RESPWithToken("SETNAME", clientname).encode(into: &commandEncoder)
        }
    }
    public typealias Response = RESPToken.Map

    public var arguments: Arguments?

    @inlinable public init(arguments: Arguments? = nil) {
        self.arguments = arguments
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("HELLO", arguments)
    }
}

/// Returns the server's liveliness response.
public struct PING: ValkeyCommand {
    public var message: String?

    @inlinable public init(message: String? = nil) {
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("PING", message)
    }
}

/// Closes the connection.
@available(*, deprecated, message: "Since 7.2.0. Replaced by just closing the connection.")
public struct QUIT: ValkeyCommand {
    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("QUIT")
    }
}

/// Resets the connection.
public struct RESET: ValkeyCommand {
    public typealias Response = String

    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("RESET")
    }
}

/// Changes the selected database.
public struct SELECT: ValkeyCommand {
    public var index: Int

    @inlinable public init(index: Int) {
        self.index = index
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("SELECT", index)
    }
}

extension ValkeyConnectionProtocol {
    /// Authenticates the connection.
    ///
    /// - Documentation: [AUTH](https:/valkey.io/commands/auth)
    /// - Available: 1.0.0
    /// - History:
    ///     * 6.0.0: Added ACL style (username and password).
    /// - Complexity: O(N) where N is the number of passwords defined for the user
    @inlinable
    public func auth<Password: RESPStringRenderable>(username: String? = nil, password: Password) async throws {
        _ = try await send(command: AUTH(username: username, password: password))
    }

    /// A container for client connection commands.
    ///
    /// - Documentation: [CLIENT](https:/valkey.io/commands/client)
    /// - Available: 2.4.0
    /// - Complexity: Depends on subcommand.
    @inlinable
    public func client() async throws -> CLIENT.Response {
        try await send(command: CLIENT())
    }

    /// Instructs the server whether to track the keys in the next request.
    ///
    /// - Documentation: [CLIENT CACHING](https:/valkey.io/commands/client-caching)
    /// - Available: 6.0.0
    /// - Complexity: O(1)
    @inlinable
    public func clientCaching(mode: CLIENT.CACHING.Mode) async throws {
        _ = try await send(command: CLIENT.CACHING(mode: mode))
    }

    /// A client claims its capability.
    ///
    /// - Documentation: [CLIENT CAPA](https:/valkey.io/commands/client-capa)
    /// - Available: 8.0.0
    /// - Complexity: O(1)
    @inlinable
    public func clientCapa<Capability: RESPStringRenderable>(capability: [Capability]) async throws {
        _ = try await send(command: CLIENT.CAPA(capability: capability))
    }

    /// Returns the name of the connection.
    ///
    /// - Documentation: [CLIENT GETNAME](https:/valkey.io/commands/client-getname)
    /// - Available: 2.6.9
    /// - Complexity: O(1)
    /// - Returns: One of the following
    ///     * [String]: The connection name of the current connection
    ///     * [Null]: Connection name was not set
    @inlinable
    public func clientGetname() async throws -> RESPToken? {
        try await send(command: CLIENT.GETNAME())
    }

    /// Returns the client ID to which the connection's tracking notifications are redirected.
    ///
    /// - Documentation: [CLIENT GETREDIR](https:/valkey.io/commands/client-getredir)
    /// - Available: 6.0.0
    /// - Complexity: O(1)
    /// - Returns: One of the following
    ///     * 0: Not redirecting notifications to any client.
    ///     * -1: Client tracking is not enabled.
    ///     * [Integer]: ID of the client we are redirecting the notifications to.
    @inlinable
    public func clientGetredir() async throws -> Int {
        try await send(command: CLIENT.GETREDIR())
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [CLIENT HELP](https:/valkey.io/commands/client-help)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Returns: [Array]: Helpful text about subcommands.
    @inlinable
    public func clientHelp() async throws -> RESPToken.Array {
        try await send(command: CLIENT.HELP())
    }

    /// Returns the unique client ID of the connection.
    ///
    /// - Documentation: [CLIENT ID](https:/valkey.io/commands/client-id)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Returns: [Integer]: The id of the client
    @inlinable
    public func clientId() async throws -> Int {
        try await send(command: CLIENT.ID())
    }

    /// Mark this client as an import source when server is in import mode.
    ///
    /// - Documentation: [CLIENT IMPORT-SOURCE](https:/valkey.io/commands/client-import-source)
    /// - Available: 8.1.0
    /// - Complexity: O(1)
    @inlinable
    public func clientImportSource(enabled: CLIENT.IMPORTSOURCE.Enabled) async throws {
        _ = try await send(command: CLIENT.IMPORTSOURCE(enabled: enabled))
    }

    /// Returns information about the connection.
    ///
    /// - Documentation: [CLIENT INFO](https:/valkey.io/commands/client-info)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    /// - Returns: [String]: A unique string, as described at the CLIENT LIST page, for the current client.
    @inlinable
    public func clientInfo() async throws -> CLIENT.INFO.Response {
        try await send(command: CLIENT.INFO())
    }

    /// Terminates open connections.
    ///
    /// - Documentation: [CLIENT KILL](https:/valkey.io/commands/client-kill)
    /// - Available: 2.4.0
    /// - History:
    ///     * 2.8.12: Added new filter format.
    ///     * 2.8.12: `ID` option.
    ///     * 3.2.0: Added `master` type in for `TYPE` option.
    ///     * 5.0.0: Replaced `slave` `TYPE` with `replica`. `slave` still supported for backward compatibility.
    ///     * 6.2.0: `LADDR` option.
    ///     * 8.0.0: `MAXAGE` option.
    ///     * 8.0.0: Replaced `master` `TYPE` with `primary`. `master` still supported for backward compatibility.
    ///     * 8.1.0: `ID` option accepts multiple IDs.
    /// - Complexity: O(N) where N is the number of client connections
    /// - Returns: One of the following
    ///     * "OK": When called in 3 argument format.
    ///     * [Integer]: When called in filter/value format, the number of clients killed.
    @inlinable
    public func clientKill(filter: CLIENT.KILL.Filter) async throws -> Int? {
        try await send(command: CLIENT.KILL(filter: filter))
    }

    /// Lists open connections.
    ///
    /// - Documentation: [CLIENT LIST](https:/valkey.io/commands/client-list)
    /// - Available: 2.4.0
    /// - History:
    ///     * 2.8.12: Added unique client `id` field.
    ///     * 5.0.0: Added optional `TYPE` filter.
    ///     * 6.0.0: Added `user` field.
    ///     * 6.2.0: Added `argv-mem`, `tot-mem`, `laddr` and `redir` fields and the optional `ID` filter.
    ///     * 7.0.0: Added `resp`, `multi-mem`, `rbs` and `rbp` fields.
    ///     * 7.0.3: Added `ssub` field.
    ///     * 8.0.0: Replaced `master` `TYPE` with `primary`. `master` still supported for backward compatibility.
    ///     * 8.1.0: Added filters USER, ADDR, LADDR, SKIPME, and MAXAGE
    /// - Complexity: O(N) where N is the number of client connections
    /// - Returns: [String]: Information and statistics about client connections
    @inlinable
    public func clientList(clientType: CLIENT.LIST.ClientType? = nil, clientId: [Int] = [], username: String? = nil, addr: String? = nil, laddr: String? = nil, skipme: CLIENT.LIST.Skipme? = nil, maxage: Int? = nil) async throws -> CLIENT.LIST.Response {
        try await send(command: CLIENT.LIST(clientType: clientType, clientId: clientId, username: username, addr: addr, laddr: laddr, skipme: skipme, maxage: maxage))
    }

    /// Sets the client eviction mode of the connection.
    ///
    /// - Documentation: [CLIENT NO-EVICT](https:/valkey.io/commands/client-no-evict)
    /// - Available: 7.0.0
    /// - Complexity: O(1)
    @inlinable
    public func clientNoEvict(enabled: CLIENT.NOEVICT.Enabled) async throws {
        _ = try await send(command: CLIENT.NOEVICT(enabled: enabled))
    }

    /// Controls whether commands sent by the client affect the LRU/LFU of accessed keys.
    ///
    /// - Documentation: [CLIENT NO-TOUCH](https:/valkey.io/commands/client-no-touch)
    /// - Available: 7.2.0
    /// - Complexity: O(1)
    @inlinable
    public func clientNoTouch(enabled: CLIENT.NOTOUCH.Enabled) async throws {
        _ = try await send(command: CLIENT.NOTOUCH(enabled: enabled))
    }

    /// Suspends commands processing.
    ///
    /// - Documentation: [CLIENT PAUSE](https:/valkey.io/commands/client-pause)
    /// - Available: 3.0.0
    /// - History:
    ///     * 6.2.0: `CLIENT PAUSE WRITE` mode added along with the `mode` option.
    /// - Complexity: O(1)
    @inlinable
    public func clientPause(timeout: Int, mode: CLIENT.PAUSE.Mode? = nil) async throws {
        _ = try await send(command: CLIENT.PAUSE(timeout: timeout, mode: mode))
    }

    /// Instructs the server whether to reply to commands.
    ///
    /// - Documentation: [CLIENT REPLY](https:/valkey.io/commands/client-reply)
    /// - Available: 3.2.0
    /// - Complexity: O(1)
    /// - Returns: "OK": When called with either OFF or SKIP subcommands, no reply is made. When called with ON, reply is OK.
    @inlinable
    public func clientReply(action: CLIENT.REPLY.Action) async throws {
        _ = try await send(command: CLIENT.REPLY(action: action))
    }

    /// Sets information specific to the client or connection.
    ///
    /// - Documentation: [CLIENT SETINFO](https:/valkey.io/commands/client-setinfo)
    /// - Available: 7.2.0
    /// - Complexity: O(1)
    @inlinable
    public func clientSetinfo(attr: CLIENT.SETINFO.Attr) async throws {
        _ = try await send(command: CLIENT.SETINFO(attr: attr))
    }

    /// Sets the connection name.
    ///
    /// - Documentation: [CLIENT SETNAME](https:/valkey.io/commands/client-setname)
    /// - Available: 2.6.9
    /// - Complexity: O(1)
    @inlinable
    public func clientSetname<ConnectionName: RESPStringRenderable>(connectionName: ConnectionName) async throws {
        _ = try await send(command: CLIENT.SETNAME(connectionName: connectionName))
    }

    /// Controls server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKING](https:/valkey.io/commands/client-tracking)
    /// - Available: 6.0.0
    /// - Complexity: O(1). Some options may introduce additional complexity.
    /// - Returns: "OK": If the client was successfully put into or taken out of tracking mode.
    @inlinable
    public func clientTracking(status: CLIENT.TRACKING.Status, clientId: Int? = nil, prefix: [String] = [], bcast: Bool = false, optin: Bool = false, optout: Bool = false, noloop: Bool = false) async throws {
        _ = try await send(command: CLIENT.TRACKING(status: status, clientId: clientId, prefix: prefix, bcast: bcast, optin: optin, optout: optout, noloop: noloop))
    }

    /// Returns information about server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKINGINFO](https:/valkey.io/commands/client-trackinginfo)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    @inlinable
    public func clientTrackinginfo() async throws -> RESPToken.Map {
        try await send(command: CLIENT.TRACKINGINFO())
    }

    /// Unblocks a client blocked by a blocking command from a different connection.
    ///
    /// - Documentation: [CLIENT UNBLOCK](https:/valkey.io/commands/client-unblock)
    /// - Available: 5.0.0
    /// - Complexity: O(log N) where N is the number of client connections
    /// - Returns: One of the following
    ///     * 0: If the client was unblocked successfully.
    ///     * 1: If the client wasn't unblocked.
    @inlinable
    public func clientUnblock(clientId: Int, unblockType: CLIENT.UNBLOCK.UnblockType? = nil) async throws -> Int {
        try await send(command: CLIENT.UNBLOCK(clientId: clientId, unblockType: unblockType))
    }

    /// Resumes processing commands from paused clients.
    ///
    /// - Documentation: [CLIENT UNPAUSE](https:/valkey.io/commands/client-unpause)
    /// - Available: 6.2.0
    /// - Complexity: O(N) Where N is the number of paused clients
    @inlinable
    public func clientUnpause() async throws {
        _ = try await send(command: CLIENT.UNPAUSE())
    }

    /// Returns the given string.
    ///
    /// - Documentation: [ECHO](https:/valkey.io/commands/echo)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Returns: [String]: The given string
    @inlinable
    public func echo<Message: RESPStringRenderable>(message: Message) async throws -> ECHO.Response {
        try await send(command: ECHO(message: message))
    }

    /// Handshakes with the server.
    ///
    /// - Documentation: [HELLO](https:/valkey.io/commands/hello)
    /// - Available: 6.0.0
    /// - History:
    ///     * 8.1.0: A new `availability_zone` field is added to the response if the `availability-zone` config is set.
    ///     * 6.2.0: `protover` made optional; when called without arguments the command reports the current connection's context.
    /// - Complexity: O(1)
    @inlinable
    public func hello(arguments: HELLO.Arguments? = nil) async throws -> RESPToken.Map {
        try await send(command: HELLO(arguments: arguments))
    }

    /// Returns the server's liveliness response.
    ///
    /// - Documentation: [PING](https:/valkey.io/commands/ping)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Returns: One of the following
    ///     * "PONG": Default reply.
    ///     * [String]: Relay of given `message`.
    @inlinable
    public func ping(message: String? = nil) async throws -> PING.Response {
        try await send(command: PING(message: message))
    }

    /// Closes the connection.
    ///
    /// - Documentation: [QUIT](https:/valkey.io/commands/quit)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    @inlinable
    @available(*, deprecated, message: "Since 7.2.0. Replaced by just closing the connection.")
    public func quit() async throws {
        _ = try await send(command: QUIT())
    }

    /// Resets the connection.
    ///
    /// - Documentation: [RESET](https:/valkey.io/commands/reset)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    @inlinable
    public func reset() async throws -> String {
        try await send(command: RESET())
    }

    /// Changes the selected database.
    ///
    /// - Documentation: [SELECT](https:/valkey.io/commands/select)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    @inlinable
    public func select(index: Int) async throws {
        _ = try await send(command: SELECT(index: index))
    }

}
