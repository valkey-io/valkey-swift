//===----------------------------------------------------------------------===//
//
// This source file is part of the valkey-swift open source project
//
// Copyright (c) 2025 the valkey-swift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of valkey-swift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension CLIENT {
    /// Instructs the server whether to track the keys in the next request.
    @_documentation(visibility: internal)
    public struct CACHING: ValkeyCommand {
        public enum Mode: RESPRenderable, Sendable, Hashable {
            case yes
            case no

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        public var mode: Mode

        @inlinable public init(mode: Mode) {
            self.mode = mode
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "CACHING", mode)
        }
    }

    /// A client claims its capability.
    @_documentation(visibility: internal)
    public struct CAPA<Capability: RESPStringRenderable>: ValkeyCommand {
        public var capabilities: [Capability]

        @inlinable public init(capabilities: [Capability]) {
            self.capabilities = capabilities
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "CAPA", capabilities.map { RESPBulkString($0) })
        }
    }

    /// Returns the name of the connection.
    @_documentation(visibility: internal)
    public struct GETNAME: ValkeyCommand {
        public typealias Response = ByteBuffer?

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "GETNAME")
        }
    }

    /// Returns the client ID to which the connection's tracking notifications are redirected.
    @_documentation(visibility: internal)
    public struct GETREDIR: ValkeyCommand {
        public typealias Response = Int

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "GETREDIR")
        }
    }

    /// Returns helpful text about the different subcommands.
    @_documentation(visibility: internal)
    public struct HELP: ValkeyCommand {
        public typealias Response = RESPToken.Array

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "HELP")
        }
    }

    /// Returns the unique client ID of the connection.
    @_documentation(visibility: internal)
    public struct ID: ValkeyCommand {
        public typealias Response = Int

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "ID")
        }
    }

    /// Mark this client as an import source when server is in import mode.
    @_documentation(visibility: internal)
    public struct IMPORTSOURCE: ValkeyCommand {
        public enum Enabled: RESPRenderable, Sendable, Hashable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "IMPORT-SOURCE", enabled)
        }
    }

    /// Returns information about the connection.
    @_documentation(visibility: internal)
    public struct INFO: ValkeyCommand {
        public typealias Response = ByteBuffer

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "INFO")
        }
    }

    /// Terminates open connections.
    @_documentation(visibility: internal)
    public struct KILL: ValkeyCommand {
        public enum FilterNewFormatClientType: RESPRenderable, Sendable, Hashable {
            case normal
            case master
            case primary
            case slave
            case replica
            case pubsub

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .normal: "normal".encode(into: &commandEncoder)
                case .master: "master".encode(into: &commandEncoder)
                case .primary: "primary".encode(into: &commandEncoder)
                case .slave: "slave".encode(into: &commandEncoder)
                case .replica: "replica".encode(into: &commandEncoder)
                case .pubsub: "pubsub".encode(into: &commandEncoder)
                }
            }
        }
        public enum FilterNewFormatSkipme: RESPRenderable, Sendable, Hashable {
            case yes
            case no

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        public enum FilterNewFormat: RESPRenderable, Sendable, Hashable {
            case clientIds([Int])
            case clientType(FilterNewFormatClientType?)
            case username(String?)
            case addr(String?)
            case laddr(String?)
            case skipme(FilterNewFormatSkipme?)
            case maxage(Int?)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .clientIds(let clientIds): RESPWithToken("ID", clientIds).respEntries
                case .clientType(let clientType): RESPWithToken("TYPE", clientType).respEntries
                case .username(let username): RESPWithToken("USER", username).respEntries
                case .addr(let addr): RESPWithToken("ADDR", addr).respEntries
                case .laddr(let laddr): RESPWithToken("LADDR", laddr).respEntries
                case .skipme(let skipme): RESPWithToken("SKIPME", skipme).respEntries
                case .maxage(let maxage): RESPWithToken("MAXAGE", maxage).respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .clientIds(let clientIds): RESPWithToken("ID", clientIds).encode(into: &commandEncoder)
                case .clientType(let clientType): RESPWithToken("TYPE", clientType).encode(into: &commandEncoder)
                case .username(let username): RESPWithToken("USER", username).encode(into: &commandEncoder)
                case .addr(let addr): RESPWithToken("ADDR", addr).encode(into: &commandEncoder)
                case .laddr(let laddr): RESPWithToken("LADDR", laddr).encode(into: &commandEncoder)
                case .skipme(let skipme): RESPWithToken("SKIPME", skipme).encode(into: &commandEncoder)
                case .maxage(let maxage): RESPWithToken("MAXAGE", maxage).encode(into: &commandEncoder)
                }
            }
        }
        public enum Filter: RESPRenderable, Sendable, Hashable {
            case oldFormat(String)
            case newFormats([FilterNewFormat])

            @inlinable
            public var respEntries: Int {
                switch self {
                case .oldFormat(let oldFormat): oldFormat.respEntries
                case .newFormats(let newFormats): newFormats.respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .oldFormat(let oldFormat): oldFormat.encode(into: &commandEncoder)
                case .newFormats(let newFormats): newFormats.encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = Int?

        public var filter: Filter

        @inlinable public init(filter: Filter) {
            self.filter = filter
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "KILL", filter)
        }
    }

    /// Lists open connections.
    @_documentation(visibility: internal)
    public struct LIST: ValkeyCommand {
        public enum ClientType: RESPRenderable, Sendable, Hashable {
            case normal
            case master
            case replica
            case pubsub

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .normal: "normal".encode(into: &commandEncoder)
                case .master: "master".encode(into: &commandEncoder)
                case .replica: "replica".encode(into: &commandEncoder)
                case .pubsub: "pubsub".encode(into: &commandEncoder)
                }
            }
        }
        public enum Skipme: RESPRenderable, Sendable, Hashable {
            case yes
            case no

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = ByteBuffer

        public var clientType: ClientType?
        public var clientIds: [Int]
        public var username: String?
        public var addr: String?
        public var laddr: String?
        public var skipme: Skipme?
        public var maxage: Int?

        @inlinable public init(
            clientType: ClientType? = nil,
            clientIds: [Int] = [],
            username: String? = nil,
            addr: String? = nil,
            laddr: String? = nil,
            skipme: Skipme? = nil,
            maxage: Int? = nil
        ) {
            self.clientType = clientType
            self.clientIds = clientIds
            self.username = username
            self.addr = addr
            self.laddr = laddr
            self.skipme = skipme
            self.maxage = maxage
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "CLIENT",
                "LIST",
                RESPWithToken("TYPE", clientType),
                RESPWithToken("ID", clientIds),
                RESPWithToken("USER", username),
                RESPWithToken("ADDR", addr),
                RESPWithToken("LADDR", laddr),
                RESPWithToken("SKIPME", skipme),
                RESPWithToken("MAXAGE", maxage)
            )
        }
    }

    /// Sets the client eviction mode of the connection.
    @_documentation(visibility: internal)
    public struct NOEVICT: ValkeyCommand {
        public enum Enabled: RESPRenderable, Sendable, Hashable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "NO-EVICT", enabled)
        }
    }

    /// Controls whether commands sent by the client affect the LRU/LFU of accessed keys.
    @_documentation(visibility: internal)
    public struct NOTOUCH: ValkeyCommand {
        public enum Enabled: RESPRenderable, Sendable, Hashable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "NO-TOUCH", enabled)
        }
    }

    /// Suspends commands processing.
    @_documentation(visibility: internal)
    public struct PAUSE: ValkeyCommand {
        public enum Mode: RESPRenderable, Sendable, Hashable {
            case write
            case all

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .write: "WRITE".encode(into: &commandEncoder)
                case .all: "ALL".encode(into: &commandEncoder)
                }
            }
        }
        public var timeout: Int
        public var mode: Mode?

        @inlinable public init(timeout: Int, mode: Mode? = nil) {
            self.timeout = timeout
            self.mode = mode
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "PAUSE", timeout, mode)
        }
    }

    /// Instructs the server whether to reply to commands.
    @_documentation(visibility: internal)
    public struct REPLY: ValkeyCommand {
        public enum Action: RESPRenderable, Sendable, Hashable {
            case on
            case off
            case skip

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                case .skip: "SKIP".encode(into: &commandEncoder)
                }
            }
        }
        public var action: Action

        @inlinable public init(action: Action) {
            self.action = action
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "REPLY", action)
        }
    }

    /// Sets information specific to the client or connection.
    @_documentation(visibility: internal)
    public struct SETINFO: ValkeyCommand {
        public enum Attr: RESPRenderable, Sendable, Hashable {
            case libname(String)
            case libver(String)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .libname(let libname): RESPWithToken("lib-name", libname).respEntries
                case .libver(let libver): RESPWithToken("lib-ver", libver).respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .libname(let libname): RESPWithToken("lib-name", libname).encode(into: &commandEncoder)
                case .libver(let libver): RESPWithToken("lib-ver", libver).encode(into: &commandEncoder)
                }
            }
        }
        public var attr: Attr

        @inlinable public init(attr: Attr) {
            self.attr = attr
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "SETINFO", attr)
        }
    }

    /// Sets the connection name.
    @_documentation(visibility: internal)
    public struct SETNAME<ConnectionName: RESPStringRenderable>: ValkeyCommand {
        public var connectionName: ConnectionName

        @inlinable public init(connectionName: ConnectionName) {
            self.connectionName = connectionName
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "SETNAME", RESPBulkString(connectionName))
        }
    }

    /// Controls server-assisted client-side caching for the connection.
    @_documentation(visibility: internal)
    public struct TRACKING: ValkeyCommand {
        public enum Status: RESPRenderable, Sendable, Hashable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        public var status: Status
        public var clientId: Int?
        public var prefixes: [String]
        public var bcast: Bool
        public var optin: Bool
        public var optout: Bool
        public var noloop: Bool

        @inlinable public init(
            status: Status,
            clientId: Int? = nil,
            prefixes: [String] = [],
            bcast: Bool = false,
            optin: Bool = false,
            optout: Bool = false,
            noloop: Bool = false
        ) {
            self.status = status
            self.clientId = clientId
            self.prefixes = prefixes
            self.bcast = bcast
            self.optin = optin
            self.optout = optout
            self.noloop = noloop
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "CLIENT",
                "TRACKING",
                status,
                RESPWithToken("REDIRECT", clientId),
                RESPWithToken("PREFIX", prefixes),
                RESPPureToken("BCAST", bcast),
                RESPPureToken("OPTIN", optin),
                RESPPureToken("OPTOUT", optout),
                RESPPureToken("NOLOOP", noloop)
            )
        }
    }

    /// Returns information about server-assisted client-side caching for the connection.
    @_documentation(visibility: internal)
    public struct TRACKINGINFO: ValkeyCommand {
        public typealias Response = RESPToken.Map

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "TRACKINGINFO")
        }
    }

    /// Unblocks a client blocked by a blocking command from a different connection.
    @_documentation(visibility: internal)
    public struct UNBLOCK: ValkeyCommand {
        public enum UnblockType: RESPRenderable, Sendable, Hashable {
            case timeout
            case error

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .timeout: "TIMEOUT".encode(into: &commandEncoder)
                case .error: "ERROR".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = Int

        public var clientId: Int
        public var unblockType: UnblockType?

        @inlinable public init(clientId: Int, unblockType: UnblockType? = nil) {
            self.clientId = clientId
            self.unblockType = unblockType
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "UNBLOCK", clientId, unblockType)
        }
    }

    /// Resumes processing commands from paused clients.
    @_documentation(visibility: internal)
    public struct UNPAUSE: ValkeyCommand {
        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "UNPAUSE")
        }
    }

}

/// Authenticates the connection.
@_documentation(visibility: internal)
public struct AUTH<Password: RESPStringRenderable>: ValkeyCommand {
    public var username: String?
    public var password: Password

    @inlinable public init(username: String? = nil, password: Password) {
        self.username = username
        self.password = password
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("AUTH", username, RESPBulkString(password))
    }
}

/// A container for client connection commands.
@_documentation(visibility: internal)
public struct CLIENT: ValkeyCommand {
    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("CLIENT")
    }
}

/// Returns the given string.
@_documentation(visibility: internal)
public struct ECHO<Message: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = ByteBuffer

    public var message: Message

    @inlinable public init(message: Message) {
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("ECHO", RESPBulkString(message))
    }
}

/// Handshakes with the server.
@_documentation(visibility: internal)
public struct HELLO: ValkeyCommand {
    public struct ArgumentsAuth: RESPRenderable, Sendable, Hashable {
        @usableFromInline let username: String
        @usableFromInline let password: String

        @inlinable public init(username: String, password: String) {
            self.username = username
            self.password = password
        }

        @inlinable
        public var respEntries: Int {
            username.respEntries + password.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            username.encode(into: &commandEncoder)
            password.encode(into: &commandEncoder)
        }
    }
    public struct Arguments: RESPRenderable, Sendable, Hashable {
        @usableFromInline let protover: Int
        @usableFromInline let auth: ArgumentsAuth?
        @usableFromInline let clientname: String?

        @inlinable public init(protover: Int, auth: ArgumentsAuth? = nil, clientname: String? = nil) {
            self.protover = protover
            self.auth = auth
            self.clientname = clientname
        }

        @inlinable
        public var respEntries: Int {
            protover.respEntries + RESPWithToken("AUTH", auth).respEntries + RESPWithToken("SETNAME", clientname).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            protover.encode(into: &commandEncoder)
            RESPWithToken("AUTH", auth).encode(into: &commandEncoder)
            RESPWithToken("SETNAME", clientname).encode(into: &commandEncoder)
        }
    }
    public typealias Response = RESPToken.Map

    public var arguments: Arguments?

    @inlinable public init(arguments: Arguments? = nil) {
        self.arguments = arguments
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("HELLO", arguments)
    }
}

/// Returns the server's liveliness response.
@_documentation(visibility: internal)
public struct PING: ValkeyCommand {
    public var message: String?

    @inlinable public init(message: String? = nil) {
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("PING", message)
    }
}

/// Closes the connection.
@_documentation(visibility: internal)
public struct QUIT: ValkeyCommand {
    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("QUIT")
    }
}

/// Resets the connection.
@_documentation(visibility: internal)
public struct RESET: ValkeyCommand {
    public typealias Response = String

    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("RESET")
    }
}

/// Changes the selected database.
@_documentation(visibility: internal)
public struct SELECT: ValkeyCommand {
    public var index: Int

    @inlinable public init(index: Int) {
        self.index = index
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("SELECT", index)
    }
}

extension ValkeyClientProtocol {
    /// Authenticates the connection.
    ///
    /// - Documentation: [AUTH](https://valkey.io/commands/auth)
    /// - Available: 1.0.0
    /// - History:
    ///     * 6.0.0: Added ACL style (username and password).
    /// - Complexity: O(N) where N is the number of passwords defined for the user
    @inlinable
    public func auth<Password: RESPStringRenderable>(username: String? = nil, password: Password) async throws {
        _ = try await execute(AUTH(username: username, password: password))
    }

    /// A container for client connection commands.
    ///
    /// - Documentation: [CLIENT](https://valkey.io/commands/client)
    /// - Available: 2.4.0
    /// - Complexity: Depends on subcommand.
    @inlinable
    @discardableResult
    public func client() async throws -> CLIENT.Response {
        try await execute(CLIENT())
    }

    /// Instructs the server whether to track the keys in the next request.
    ///
    /// - Documentation: [CLIENT CACHING](https://valkey.io/commands/client-caching)
    /// - Available: 6.0.0
    /// - Complexity: O(1)
    @inlinable
    public func clientCaching(mode: CLIENT.CACHING.Mode) async throws {
        _ = try await execute(CLIENT.CACHING(mode: mode))
    }

    /// A client claims its capability.
    ///
    /// - Documentation: [CLIENT CAPA](https://valkey.io/commands/client-capa)
    /// - Available: 8.0.0
    /// - Complexity: O(1)
    @inlinable
    public func clientCapa<Capability: RESPStringRenderable>(capabilities: [Capability]) async throws {
        _ = try await execute(CLIENT.CAPA(capabilities: capabilities))
    }

    /// Returns the name of the connection.
    ///
    /// - Documentation: [CLIENT GETNAME](https://valkey.io/commands/client-getname)
    /// - Available: 2.6.9
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [String]: The connection name of the current connection
    ///     * [Null]: Connection name was not set
    @inlinable
    @discardableResult
    public func clientGetname() async throws -> ByteBuffer? {
        try await execute(CLIENT.GETNAME())
    }

    /// Returns the client ID to which the connection's tracking notifications are redirected.
    ///
    /// - Documentation: [CLIENT GETREDIR](https://valkey.io/commands/client-getredir)
    /// - Available: 6.0.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * 0: Not redirecting notifications to any client.
    ///     * -1: Client tracking is not enabled.
    ///     * [Integer]: ID of the client we are redirecting the notifications to.
    @inlinable
    @discardableResult
    public func clientGetredir() async throws -> Int {
        try await execute(CLIENT.GETREDIR())
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [CLIENT HELP](https://valkey.io/commands/client-help)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Array]: Helpful text about subcommands.
    @inlinable
    @discardableResult
    public func clientHelp() async throws -> RESPToken.Array {
        try await execute(CLIENT.HELP())
    }

    /// Returns the unique client ID of the connection.
    ///
    /// - Documentation: [CLIENT ID](https://valkey.io/commands/client-id)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Integer]: The id of the client
    @inlinable
    @discardableResult
    public func clientId() async throws -> Int {
        try await execute(CLIENT.ID())
    }

    /// Mark this client as an import source when server is in import mode.
    ///
    /// - Documentation: [CLIENT IMPORT-SOURCE](https://valkey.io/commands/client-import-source)
    /// - Available: 8.1.0
    /// - Complexity: O(1)
    @inlinable
    public func clientImportSource(enabled: CLIENT.IMPORTSOURCE.Enabled) async throws {
        _ = try await execute(CLIENT.IMPORTSOURCE(enabled: enabled))
    }

    /// Returns information about the connection.
    ///
    /// - Documentation: [CLIENT INFO](https://valkey.io/commands/client-info)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    /// - Response: [String]: A unique string, as described at the CLIENT LIST page, for the current client.
    @inlinable
    @discardableResult
    public func clientInfo() async throws -> ByteBuffer {
        try await execute(CLIENT.INFO())
    }

    /// Terminates open connections.
    ///
    /// - Documentation: [CLIENT KILL](https://valkey.io/commands/client-kill)
    /// - Available: 2.4.0
    /// - History:
    ///     * 2.8.12: Added new filter format.
    ///     * 2.8.12: `ID` option.
    ///     * 3.2.0: Added `master` type in for `TYPE` option.
    ///     * 5.0.0: Replaced `slave` `TYPE` with `replica`. `slave` still supported for backward compatibility.
    ///     * 6.2.0: `LADDR` option.
    ///     * 8.0.0: `MAXAGE` option.
    ///     * 8.0.0: Replaced `master` `TYPE` with `primary`. `master` still supported for backward compatibility.
    ///     * 8.1.0: `ID` option accepts multiple IDs.
    /// - Complexity: O(N) where N is the number of client connections
    /// - Response: One of the following
    ///     * "OK": When called in 3 argument format.
    ///     * [Integer]: When called in filter/value format, the number of clients killed.
    @inlinable
    @discardableResult
    public func clientKill(filter: CLIENT.KILL.Filter) async throws -> Int? {
        try await execute(CLIENT.KILL(filter: filter))
    }

    /// Lists open connections.
    ///
    /// - Documentation: [CLIENT LIST](https://valkey.io/commands/client-list)
    /// - Available: 2.4.0
    /// - History:
    ///     * 2.8.12: Added unique client `id` field.
    ///     * 5.0.0: Added optional `TYPE` filter.
    ///     * 6.0.0: Added `user` field.
    ///     * 6.2.0: Added `argv-mem`, `tot-mem`, `laddr` and `redir` fields and the optional `ID` filter.
    ///     * 7.0.0: Added `resp`, `multi-mem`, `rbs` and `rbp` fields.
    ///     * 7.0.3: Added `ssub` field.
    ///     * 8.0.0: Replaced `master` `TYPE` with `primary`. `master` still supported for backward compatibility.
    ///     * 8.1.0: Added filters USER, ADDR, LADDR, SKIPME, and MAXAGE
    /// - Complexity: O(N) where N is the number of client connections
    /// - Response: [String]: Information and statistics about client connections
    @inlinable
    @discardableResult
    public func clientList(
        clientType: CLIENT.LIST.ClientType? = nil,
        clientIds: [Int] = [],
        username: String? = nil,
        addr: String? = nil,
        laddr: String? = nil,
        skipme: CLIENT.LIST.Skipme? = nil,
        maxage: Int? = nil
    ) async throws -> ByteBuffer {
        try await execute(
            CLIENT.LIST(clientType: clientType, clientIds: clientIds, username: username, addr: addr, laddr: laddr, skipme: skipme, maxage: maxage)
        )
    }

    /// Sets the client eviction mode of the connection.
    ///
    /// - Documentation: [CLIENT NO-EVICT](https://valkey.io/commands/client-no-evict)
    /// - Available: 7.0.0
    /// - Complexity: O(1)
    @inlinable
    public func clientNoEvict(enabled: CLIENT.NOEVICT.Enabled) async throws {
        _ = try await execute(CLIENT.NOEVICT(enabled: enabled))
    }

    /// Controls whether commands sent by the client affect the LRU/LFU of accessed keys.
    ///
    /// - Documentation: [CLIENT NO-TOUCH](https://valkey.io/commands/client-no-touch)
    /// - Available: 7.2.0
    /// - Complexity: O(1)
    @inlinable
    public func clientNoTouch(enabled: CLIENT.NOTOUCH.Enabled) async throws {
        _ = try await execute(CLIENT.NOTOUCH(enabled: enabled))
    }

    /// Suspends commands processing.
    ///
    /// - Documentation: [CLIENT PAUSE](https://valkey.io/commands/client-pause)
    /// - Available: 3.0.0
    /// - History:
    ///     * 6.2.0: `CLIENT PAUSE WRITE` mode added along with the `mode` option.
    /// - Complexity: O(1)
    @inlinable
    public func clientPause(timeout: Int, mode: CLIENT.PAUSE.Mode? = nil) async throws {
        _ = try await execute(CLIENT.PAUSE(timeout: timeout, mode: mode))
    }

    /// Instructs the server whether to reply to commands.
    ///
    /// - Documentation: [CLIENT REPLY](https://valkey.io/commands/client-reply)
    /// - Available: 3.2.0
    /// - Complexity: O(1)
    /// - Response: "OK": When called with either OFF or SKIP subcommands, no reply is made. When called with ON, reply is OK.
    @inlinable
    public func clientReply(action: CLIENT.REPLY.Action) async throws {
        _ = try await execute(CLIENT.REPLY(action: action))
    }

    /// Sets information specific to the client or connection.
    ///
    /// - Documentation: [CLIENT SETINFO](https://valkey.io/commands/client-setinfo)
    /// - Available: 7.2.0
    /// - Complexity: O(1)
    @inlinable
    public func clientSetinfo(attr: CLIENT.SETINFO.Attr) async throws {
        _ = try await execute(CLIENT.SETINFO(attr: attr))
    }

    /// Sets the connection name.
    ///
    /// - Documentation: [CLIENT SETNAME](https://valkey.io/commands/client-setname)
    /// - Available: 2.6.9
    /// - Complexity: O(1)
    @inlinable
    public func clientSetname<ConnectionName: RESPStringRenderable>(connectionName: ConnectionName) async throws {
        _ = try await execute(CLIENT.SETNAME(connectionName: connectionName))
    }

    /// Controls server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKING](https://valkey.io/commands/client-tracking)
    /// - Available: 6.0.0
    /// - Complexity: O(1). Some options may introduce additional complexity.
    /// - Response: "OK": If the client was successfully put into or taken out of tracking mode.
    @inlinable
    public func clientTracking(
        status: CLIENT.TRACKING.Status,
        clientId: Int? = nil,
        prefixes: [String] = [],
        bcast: Bool = false,
        optin: Bool = false,
        optout: Bool = false,
        noloop: Bool = false
    ) async throws {
        _ = try await execute(
            CLIENT.TRACKING(status: status, clientId: clientId, prefixes: prefixes, bcast: bcast, optin: optin, optout: optout, noloop: noloop)
        )
    }

    /// Returns information about server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKINGINFO](https://valkey.io/commands/client-trackinginfo)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func clientTrackinginfo() async throws -> RESPToken.Map {
        try await execute(CLIENT.TRACKINGINFO())
    }

    /// Unblocks a client blocked by a blocking command from a different connection.
    ///
    /// - Documentation: [CLIENT UNBLOCK](https://valkey.io/commands/client-unblock)
    /// - Available: 5.0.0
    /// - Complexity: O(log N) where N is the number of client connections
    /// - Response: One of the following
    ///     * 0: If the client was unblocked successfully.
    ///     * 1: If the client wasn't unblocked.
    @inlinable
    @discardableResult
    public func clientUnblock(clientId: Int, unblockType: CLIENT.UNBLOCK.UnblockType? = nil) async throws -> Int {
        try await execute(CLIENT.UNBLOCK(clientId: clientId, unblockType: unblockType))
    }

    /// Resumes processing commands from paused clients.
    ///
    /// - Documentation: [CLIENT UNPAUSE](https://valkey.io/commands/client-unpause)
    /// - Available: 6.2.0
    /// - Complexity: O(N) Where N is the number of paused clients
    @inlinable
    public func clientUnpause() async throws {
        _ = try await execute(CLIENT.UNPAUSE())
    }

    /// Returns the given string.
    ///
    /// - Documentation: [ECHO](https://valkey.io/commands/echo)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Response: [String]: The given string
    @inlinable
    @discardableResult
    public func echo<Message: RESPStringRenderable>(message: Message) async throws -> ByteBuffer {
        try await execute(ECHO(message: message))
    }

    /// Handshakes with the server.
    ///
    /// - Documentation: [HELLO](https://valkey.io/commands/hello)
    /// - Available: 6.0.0
    /// - History:
    ///     * 8.1.0: A new `availability_zone` field is added to the response if the `availability-zone` config is set.
    ///     * 6.2.0: `protover` made optional; when called without arguments the command reports the current connection's context.
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func hello(arguments: HELLO.Arguments? = nil) async throws -> RESPToken.Map {
        try await execute(HELLO(arguments: arguments))
    }

    /// Returns the server's liveliness response.
    ///
    /// - Documentation: [PING](https://valkey.io/commands/ping)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * "PONG": Default reply.
    ///     * [String]: Relay of given `message`.
    @inlinable
    @discardableResult
    public func ping(message: String? = nil) async throws -> PING.Response {
        try await execute(PING(message: message))
    }

    /// Closes the connection.
    ///
    /// - Documentation: [QUIT](https://valkey.io/commands/quit)
    /// - Available: 1.0.0
    /// - Deprecated since: 7.2.0. Replaced by just closing the connection.
    /// - Complexity: O(1)
    @inlinable
    public func quit() async throws {
        _ = try await execute(QUIT())
    }

    /// Resets the connection.
    ///
    /// - Documentation: [RESET](https://valkey.io/commands/reset)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func reset() async throws -> String {
        try await execute(RESET())
    }

    /// Changes the selected database.
    ///
    /// - Documentation: [SELECT](https://valkey.io/commands/select)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    @inlinable
    public func select(index: Int) async throws {
        _ = try await execute(SELECT(index: index))
    }

}
