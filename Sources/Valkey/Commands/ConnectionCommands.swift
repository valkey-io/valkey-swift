//===----------------------------------------------------------------------===//
//
// This source file is part of the valkey-swift open source project
//
// Copyright (c) 2025 the valkey-swift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of valkey-swift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension CLIENT {
    /// Instructs the server whether to track the keys in the next request.
    @_documentation(visibility: internal)
    public struct CACHING: ValkeyCommand {
        public enum Mode: RESPRenderable, Sendable, Hashable {
            case yes
            case no

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "CLIENT CACHING" }

        public var mode: Mode

        @inlinable public init(mode: Mode) {
            self.mode = mode
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "CACHING", mode)
        }
    }

    /// A client claims its capability.
    @_documentation(visibility: internal)
    public struct CAPA<Capability: RESPStringRenderable>: ValkeyCommand {
        @inlinable public static var name: String { "CLIENT CAPA" }

        public var capabilities: [Capability]

        @inlinable public init(capabilities: [Capability]) {
            self.capabilities = capabilities
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "CAPA", capabilities.map { RESPBulkString($0) })
        }
    }

    /// Returns the name of the connection.
    @_documentation(visibility: internal)
    public struct GETNAME: ValkeyCommand {
        public typealias Response = ByteBuffer?

        @inlinable public static var name: String { "CLIENT GETNAME" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "GETNAME")
        }
    }

    /// Returns the client ID to which the connection's tracking notifications are redirected.
    @_documentation(visibility: internal)
    public struct GETREDIR: ValkeyCommand {
        public typealias Response = Int

        @inlinable public static var name: String { "CLIENT GETREDIR" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "GETREDIR")
        }
    }

    /// Returns helpful text about the different subcommands.
    @_documentation(visibility: internal)
    public struct HELP: ValkeyCommand {
        public typealias Response = RESPToken.Array

        @inlinable public static var name: String { "CLIENT HELP" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "HELP")
        }
    }

    /// Returns the unique client ID of the connection.
    @_documentation(visibility: internal)
    public struct ID: ValkeyCommand {
        public typealias Response = Int

        @inlinable public static var name: String { "CLIENT ID" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "ID")
        }
    }

    /// Mark this client as an import source when server is in import mode.
    @_documentation(visibility: internal)
    public struct IMPORTSOURCE: ValkeyCommand {
        public enum Enabled: RESPRenderable, Sendable, Hashable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "CLIENT IMPORT-SOURCE" }

        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "IMPORT-SOURCE", enabled)
        }
    }

    /// Returns information about the connection.
    @_documentation(visibility: internal)
    public struct INFO: ValkeyCommand {
        public typealias Response = ByteBuffer

        @inlinable public static var name: String { "CLIENT INFO" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "INFO")
        }
    }

    /// Terminates open connections.
    @_documentation(visibility: internal)
    public struct KILL: ValkeyCommand {
        public enum FilterNewFormatClientType: RESPRenderable, Sendable, Hashable {
            case normal
            case master
            case primary
            case slave
            case replica
            case pubsub

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .normal: "normal".encode(into: &commandEncoder)
                case .master: "master".encode(into: &commandEncoder)
                case .primary: "primary".encode(into: &commandEncoder)
                case .slave: "slave".encode(into: &commandEncoder)
                case .replica: "replica".encode(into: &commandEncoder)
                case .pubsub: "pubsub".encode(into: &commandEncoder)
                }
            }
        }
        public enum FilterNewFormatSkipme: RESPRenderable, Sendable, Hashable {
            case yes
            case no

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        public enum FilterNewFormatNotClientType: RESPRenderable, Sendable, Hashable {
            case normal
            case master
            case primary
            case slave
            case replica
            case pubsub

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .normal: "normal".encode(into: &commandEncoder)
                case .master: "master".encode(into: &commandEncoder)
                case .primary: "primary".encode(into: &commandEncoder)
                case .slave: "slave".encode(into: &commandEncoder)
                case .replica: "replica".encode(into: &commandEncoder)
                case .pubsub: "pubsub".encode(into: &commandEncoder)
                }
            }
        }
        public enum FilterNewFormat: RESPRenderable, Sendable, Hashable {
            case clientIds([Int])
            case clientType(FilterNewFormatClientType?)
            case username(String?)
            case addr(String?)
            case laddr(String?)
            case skipme(FilterNewFormatSkipme?)
            case maxage(Int?)
            case name(String?)
            case idle(Int?)
            case flags(String?)
            case libName(String?)
            case libVer(String?)
            case db(Int?)
            case capa(String?)
            case ip(String?)
            case notClientType(FilterNewFormatNotClientType?)
            case notClientIds([Int])
            case notUsername(String?)
            case notAddr(String?)
            case notLaddr(String?)
            case notName(String?)
            case notFlags(String?)
            case notLibName(String?)
            case notLibVer(String?)
            case notDb(Int?)
            case notCapa(String?)
            case notIp(String?)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .clientIds(let clientIds): RESPWithToken("ID", clientIds).respEntries
                case .clientType(let clientType): RESPWithToken("TYPE", clientType).respEntries
                case .username(let username): RESPWithToken("USER", username).respEntries
                case .addr(let addr): RESPWithToken("ADDR", addr).respEntries
                case .laddr(let laddr): RESPWithToken("LADDR", laddr).respEntries
                case .skipme(let skipme): RESPWithToken("SKIPME", skipme).respEntries
                case .maxage(let maxage): RESPWithToken("MAXAGE", maxage).respEntries
                case .name(let name): RESPWithToken("NAME", name).respEntries
                case .idle(let idle): RESPWithToken("IDLE", idle).respEntries
                case .flags(let flags): RESPWithToken("FLAGS", flags).respEntries
                case .libName(let libName): RESPWithToken("LIB-NAME", libName).respEntries
                case .libVer(let libVer): RESPWithToken("LIB-VER", libVer).respEntries
                case .db(let db): RESPWithToken("DB", db).respEntries
                case .capa(let capa): RESPWithToken("CAPA", capa).respEntries
                case .ip(let ip): RESPWithToken("IP", ip).respEntries
                case .notClientType(let notClientType): RESPWithToken("NOT-TYPE", notClientType).respEntries
                case .notClientIds(let notClientIds): RESPWithToken("NOT-ID", notClientIds).respEntries
                case .notUsername(let notUsername): RESPWithToken("NOT-USER", notUsername).respEntries
                case .notAddr(let notAddr): RESPWithToken("NOT-ADDR", notAddr).respEntries
                case .notLaddr(let notLaddr): RESPWithToken("NOT-LADDR", notLaddr).respEntries
                case .notName(let notName): RESPWithToken("NOT-NAME", notName).respEntries
                case .notFlags(let notFlags): RESPWithToken("NOT-FLAGS", notFlags).respEntries
                case .notLibName(let notLibName): RESPWithToken("NOT-LIB-NAME", notLibName).respEntries
                case .notLibVer(let notLibVer): RESPWithToken("NOT-LIB-VER", notLibVer).respEntries
                case .notDb(let notDb): RESPWithToken("NOT-DB", notDb).respEntries
                case .notCapa(let notCapa): RESPWithToken("NOT-CAPA", notCapa).respEntries
                case .notIp(let notIp): RESPWithToken("NOT-IP", notIp).respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .clientIds(let clientIds): RESPWithToken("ID", clientIds).encode(into: &commandEncoder)
                case .clientType(let clientType): RESPWithToken("TYPE", clientType).encode(into: &commandEncoder)
                case .username(let username): RESPWithToken("USER", username).encode(into: &commandEncoder)
                case .addr(let addr): RESPWithToken("ADDR", addr).encode(into: &commandEncoder)
                case .laddr(let laddr): RESPWithToken("LADDR", laddr).encode(into: &commandEncoder)
                case .skipme(let skipme): RESPWithToken("SKIPME", skipme).encode(into: &commandEncoder)
                case .maxage(let maxage): RESPWithToken("MAXAGE", maxage).encode(into: &commandEncoder)
                case .name(let name): RESPWithToken("NAME", name).encode(into: &commandEncoder)
                case .idle(let idle): RESPWithToken("IDLE", idle).encode(into: &commandEncoder)
                case .flags(let flags): RESPWithToken("FLAGS", flags).encode(into: &commandEncoder)
                case .libName(let libName): RESPWithToken("LIB-NAME", libName).encode(into: &commandEncoder)
                case .libVer(let libVer): RESPWithToken("LIB-VER", libVer).encode(into: &commandEncoder)
                case .db(let db): RESPWithToken("DB", db).encode(into: &commandEncoder)
                case .capa(let capa): RESPWithToken("CAPA", capa).encode(into: &commandEncoder)
                case .ip(let ip): RESPWithToken("IP", ip).encode(into: &commandEncoder)
                case .notClientType(let notClientType): RESPWithToken("NOT-TYPE", notClientType).encode(into: &commandEncoder)
                case .notClientIds(let notClientIds): RESPWithToken("NOT-ID", notClientIds).encode(into: &commandEncoder)
                case .notUsername(let notUsername): RESPWithToken("NOT-USER", notUsername).encode(into: &commandEncoder)
                case .notAddr(let notAddr): RESPWithToken("NOT-ADDR", notAddr).encode(into: &commandEncoder)
                case .notLaddr(let notLaddr): RESPWithToken("NOT-LADDR", notLaddr).encode(into: &commandEncoder)
                case .notName(let notName): RESPWithToken("NOT-NAME", notName).encode(into: &commandEncoder)
                case .notFlags(let notFlags): RESPWithToken("NOT-FLAGS", notFlags).encode(into: &commandEncoder)
                case .notLibName(let notLibName): RESPWithToken("NOT-LIB-NAME", notLibName).encode(into: &commandEncoder)
                case .notLibVer(let notLibVer): RESPWithToken("NOT-LIB-VER", notLibVer).encode(into: &commandEncoder)
                case .notDb(let notDb): RESPWithToken("NOT-DB", notDb).encode(into: &commandEncoder)
                case .notCapa(let notCapa): RESPWithToken("NOT-CAPA", notCapa).encode(into: &commandEncoder)
                case .notIp(let notIp): RESPWithToken("NOT-IP", notIp).encode(into: &commandEncoder)
                }
            }
        }
        public enum Filter: RESPRenderable, Sendable, Hashable {
            case oldFormat(String)
            case newFormats([FilterNewFormat])

            @inlinable
            public var respEntries: Int {
                switch self {
                case .oldFormat(let oldFormat): oldFormat.respEntries
                case .newFormats(let newFormats): newFormats.respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .oldFormat(let oldFormat): oldFormat.encode(into: &commandEncoder)
                case .newFormats(let newFormats): newFormats.encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = Int?

        @inlinable public static var name: String { "CLIENT KILL" }

        public var filter: Filter

        @inlinable public init(filter: Filter) {
            self.filter = filter
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "KILL", filter)
        }
    }

    /// Lists open connections.
    @_documentation(visibility: internal)
    public struct LIST: ValkeyCommand {
        public enum ClientType: RESPRenderable, Sendable, Hashable {
            case normal
            case master
            case replica
            case pubsub

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .normal: "normal".encode(into: &commandEncoder)
                case .master: "master".encode(into: &commandEncoder)
                case .replica: "replica".encode(into: &commandEncoder)
                case .pubsub: "pubsub".encode(into: &commandEncoder)
                }
            }
        }
        public enum Skipme: RESPRenderable, Sendable, Hashable {
            case yes
            case no

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .yes: "YES".encode(into: &commandEncoder)
                case .no: "NO".encode(into: &commandEncoder)
                }
            }
        }
        public enum NotClientType: RESPRenderable, Sendable, Hashable {
            case normal
            case master
            case replica
            case pubsub

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .normal: "normal".encode(into: &commandEncoder)
                case .master: "master".encode(into: &commandEncoder)
                case .replica: "replica".encode(into: &commandEncoder)
                case .pubsub: "pubsub".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = ByteBuffer

        @inlinable public static var name: String { "CLIENT LIST" }

        public var clientType: ClientType?
        public var clientIds: [Int]
        public var username: String?
        public var addr: String?
        public var laddr: String?
        public var skipme: Skipme?
        public var maxage: Int?
        public var name: String?
        public var idle: Int?
        public var flags: String?
        public var libName: String?
        public var libVer: String?
        public var db: Int?
        public var capa: String?
        public var ip: String?
        public var notClientType: NotClientType?
        public var notClientIds: [Int]
        public var notUsername: String?
        public var notAddr: String?
        public var notLaddr: String?
        public var notName: String?
        public var notFlags: String?
        public var notLibName: String?
        public var notLibVer: String?
        public var notDb: Int?
        public var notCapa: String?
        public var notIp: String?

        @inlinable public init(
            clientType: ClientType? = nil,
            clientIds: [Int] = [],
            username: String? = nil,
            addr: String? = nil,
            laddr: String? = nil,
            skipme: Skipme? = nil,
            maxage: Int? = nil,
            name: String? = nil,
            idle: Int? = nil,
            flags: String? = nil,
            libName: String? = nil,
            libVer: String? = nil,
            db: Int? = nil,
            capa: String? = nil,
            ip: String? = nil,
            notClientType: NotClientType? = nil,
            notClientIds: [Int] = [],
            notUsername: String? = nil,
            notAddr: String? = nil,
            notLaddr: String? = nil,
            notName: String? = nil,
            notFlags: String? = nil,
            notLibName: String? = nil,
            notLibVer: String? = nil,
            notDb: Int? = nil,
            notCapa: String? = nil,
            notIp: String? = nil
        ) {
            self.clientType = clientType
            self.clientIds = clientIds
            self.username = username
            self.addr = addr
            self.laddr = laddr
            self.skipme = skipme
            self.maxage = maxage
            self.name = name
            self.idle = idle
            self.flags = flags
            self.libName = libName
            self.libVer = libVer
            self.db = db
            self.capa = capa
            self.ip = ip
            self.notClientType = notClientType
            self.notClientIds = notClientIds
            self.notUsername = notUsername
            self.notAddr = notAddr
            self.notLaddr = notLaddr
            self.notName = notName
            self.notFlags = notFlags
            self.notLibName = notLibName
            self.notLibVer = notLibVer
            self.notDb = notDb
            self.notCapa = notCapa
            self.notIp = notIp
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "CLIENT",
                "LIST",
                RESPWithToken("TYPE", clientType),
                RESPWithToken("ID", clientIds),
                RESPWithToken("USER", username),
                RESPWithToken("ADDR", addr),
                RESPWithToken("LADDR", laddr),
                RESPWithToken("SKIPME", skipme),
                RESPWithToken("MAXAGE", maxage),
                RESPWithToken("NAME", name),
                RESPWithToken("IDLE", idle),
                RESPWithToken("FLAGS", flags),
                RESPWithToken("LIB-NAME", libName),
                RESPWithToken("LIB-VER", libVer),
                RESPWithToken("DB", db),
                RESPWithToken("CAPA", capa),
                RESPWithToken("IP", ip),
                RESPWithToken("NOT-TYPE", notClientType),
                RESPWithToken("NOT-ID", notClientIds),
                RESPWithToken("NOT-USER", notUsername),
                RESPWithToken("NOT-ADDR", notAddr),
                RESPWithToken("NOT-LADDR", notLaddr),
                RESPWithToken("NOT-NAME", notName),
                RESPWithToken("NOT-FLAGS", notFlags),
                RESPWithToken("NOT-LIB-NAME", notLibName),
                RESPWithToken("NOT-LIB-VER", notLibVer),
                RESPWithToken("NOT-DB", notDb),
                RESPWithToken("NOT-CAPA", notCapa),
                RESPWithToken("NOT-IP", notIp)
            )
        }
    }

    /// Sets the client eviction mode of the connection.
    @_documentation(visibility: internal)
    public struct NOEVICT: ValkeyCommand {
        public enum Enabled: RESPRenderable, Sendable, Hashable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "CLIENT NO-EVICT" }

        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "NO-EVICT", enabled)
        }
    }

    /// Controls whether commands sent by the client affect the LRU/LFU of accessed keys.
    @_documentation(visibility: internal)
    public struct NOTOUCH: ValkeyCommand {
        public enum Enabled: RESPRenderable, Sendable, Hashable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "CLIENT NO-TOUCH" }

        public var enabled: Enabled

        @inlinable public init(enabled: Enabled) {
            self.enabled = enabled
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "NO-TOUCH", enabled)
        }
    }

    /// Suspends commands processing.
    @_documentation(visibility: internal)
    public struct PAUSE: ValkeyCommand {
        public enum Mode: RESPRenderable, Sendable, Hashable {
            case write
            case all

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .write: "WRITE".encode(into: &commandEncoder)
                case .all: "ALL".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "CLIENT PAUSE" }

        public var timeout: Int
        public var mode: Mode?

        @inlinable public init(timeout: Int, mode: Mode? = nil) {
            self.timeout = timeout
            self.mode = mode
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "PAUSE", timeout, mode)
        }
    }

    /// Instructs the server whether to reply to commands.
    @_documentation(visibility: internal)
    public struct REPLY: ValkeyCommand {
        public enum Action: RESPRenderable, Sendable, Hashable {
            case on
            case off
            case skip

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                case .skip: "SKIP".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "CLIENT REPLY" }

        public var action: Action

        @inlinable public init(action: Action) {
            self.action = action
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "REPLY", action)
        }
    }

    /// Sets information specific to the client or connection.
    @_documentation(visibility: internal)
    public struct SETINFO: ValkeyCommand {
        public enum Attr: RESPRenderable, Sendable, Hashable {
            case libname(String)
            case libver(String)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .libname(let libname): RESPWithToken("lib-name", libname).respEntries
                case .libver(let libver): RESPWithToken("lib-ver", libver).respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .libname(let libname): RESPWithToken("lib-name", libname).encode(into: &commandEncoder)
                case .libver(let libver): RESPWithToken("lib-ver", libver).encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "CLIENT SETINFO" }

        public var attr: Attr

        @inlinable public init(attr: Attr) {
            self.attr = attr
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "SETINFO", attr)
        }
    }

    /// Sets the connection name.
    @_documentation(visibility: internal)
    public struct SETNAME<ConnectionName: RESPStringRenderable>: ValkeyCommand {
        @inlinable public static var name: String { "CLIENT SETNAME" }

        public var connectionName: ConnectionName

        @inlinable public init(connectionName: ConnectionName) {
            self.connectionName = connectionName
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "SETNAME", RESPBulkString(connectionName))
        }
    }

    /// Controls server-assisted client-side caching for the connection.
    @_documentation(visibility: internal)
    public struct TRACKING: ValkeyCommand {
        public enum Status: RESPRenderable, Sendable, Hashable {
            case on
            case off

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .on: "ON".encode(into: &commandEncoder)
                case .off: "OFF".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "CLIENT TRACKING" }

        public var status: Status
        public var clientId: Int?
        public var prefixes: [String]
        public var bcast: Bool
        public var optin: Bool
        public var optout: Bool
        public var noloop: Bool

        @inlinable public init(
            status: Status,
            clientId: Int? = nil,
            prefixes: [String] = [],
            bcast: Bool = false,
            optin: Bool = false,
            optout: Bool = false,
            noloop: Bool = false
        ) {
            self.status = status
            self.clientId = clientId
            self.prefixes = prefixes
            self.bcast = bcast
            self.optin = optin
            self.optout = optout
            self.noloop = noloop
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "CLIENT",
                "TRACKING",
                status,
                RESPWithToken("REDIRECT", clientId),
                RESPWithToken("PREFIX", prefixes),
                RESPPureToken("BCAST", bcast),
                RESPPureToken("OPTIN", optin),
                RESPPureToken("OPTOUT", optout),
                RESPPureToken("NOLOOP", noloop)
            )
        }
    }

    /// Returns information about server-assisted client-side caching for the connection.
    @_documentation(visibility: internal)
    public struct TRACKINGINFO: ValkeyCommand {
        public typealias Response = RESPToken.Map

        @inlinable public static var name: String { "CLIENT TRACKINGINFO" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "TRACKINGINFO")
        }
    }

    /// Unblocks a client blocked by a blocking command from a different connection.
    @_documentation(visibility: internal)
    public struct UNBLOCK: ValkeyCommand {
        public enum UnblockType: RESPRenderable, Sendable, Hashable {
            case timeout
            case error

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .timeout: "TIMEOUT".encode(into: &commandEncoder)
                case .error: "ERROR".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = Int

        @inlinable public static var name: String { "CLIENT UNBLOCK" }

        public var clientId: Int
        public var unblockType: UnblockType?

        @inlinable public init(clientId: Int, unblockType: UnblockType? = nil) {
            self.clientId = clientId
            self.unblockType = unblockType
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "UNBLOCK", clientId, unblockType)
        }
    }

    /// Resumes processing commands from paused clients.
    @_documentation(visibility: internal)
    public struct UNPAUSE: ValkeyCommand {
        @inlinable public static var name: String { "CLIENT UNPAUSE" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("CLIENT", "UNPAUSE")
        }
    }

}

/// Authenticates the connection.
@_documentation(visibility: internal)
public struct AUTH<Password: RESPStringRenderable>: ValkeyCommand {
    @inlinable public static var name: String { "AUTH" }

    public var username: String?
    public var password: Password

    @inlinable public init(username: String? = nil, password: Password) {
        self.username = username
        self.password = password
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("AUTH", username, RESPBulkString(password))
    }
}

/// A container for client connection commands.
@_documentation(visibility: internal)
public struct CLIENT: ValkeyCommand {
    @inlinable public static var name: String { "CLIENT" }

    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("CLIENT")
    }
}

/// Returns the given string.
@_documentation(visibility: internal)
public struct ECHO<Message: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = ByteBuffer

    @inlinable public static var name: String { "ECHO" }

    public var message: Message

    @inlinable public init(message: Message) {
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("ECHO", RESPBulkString(message))
    }
}

/// Handshakes with the server.
@_documentation(visibility: internal)
public struct HELLO: ValkeyCommand {
    public struct ArgumentsAuth: RESPRenderable, Sendable, Hashable {
        public var username: String
        public var password: String

        @inlinable
        public init(username: String, password: String) {
            self.username = username
            self.password = password
        }

        @inlinable
        public var respEntries: Int {
            username.respEntries + password.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            username.encode(into: &commandEncoder)
            password.encode(into: &commandEncoder)
        }
    }
    public struct Arguments: RESPRenderable, Sendable, Hashable {
        public var protover: Int
        public var auth: ArgumentsAuth?
        public var clientname: String?

        @inlinable
        public init(protover: Int, auth: ArgumentsAuth? = nil, clientname: String? = nil) {
            self.protover = protover
            self.auth = auth
            self.clientname = clientname
        }

        @inlinable
        public var respEntries: Int {
            protover.respEntries + RESPWithToken("AUTH", auth).respEntries + RESPWithToken("SETNAME", clientname).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            protover.encode(into: &commandEncoder)
            RESPWithToken("AUTH", auth).encode(into: &commandEncoder)
            RESPWithToken("SETNAME", clientname).encode(into: &commandEncoder)
        }
    }
    public typealias Response = RESPToken.Map

    @inlinable public static var name: String { "HELLO" }

    public var arguments: Arguments?

    @inlinable public init(arguments: Arguments? = nil) {
        self.arguments = arguments
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("HELLO", arguments)
    }
}

/// Returns the server's liveliness response.
@_documentation(visibility: internal)
public struct PING: ValkeyCommand {
    @inlinable public static var name: String { "PING" }

    public var message: String?

    @inlinable public init(message: String? = nil) {
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("PING", message)
    }
}

/// Closes the connection.
@_documentation(visibility: internal)
public struct QUIT: ValkeyCommand {
    @inlinable public static var name: String { "QUIT" }

    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("QUIT")
    }
}

/// Resets the connection.
@_documentation(visibility: internal)
public struct RESET: ValkeyCommand {
    public typealias Response = String

    @inlinable public static var name: String { "RESET" }

    @inlinable public init() {
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("RESET")
    }
}

/// Changes the selected database.
@_documentation(visibility: internal)
public struct SELECT: ValkeyCommand {
    @inlinable public static var name: String { "SELECT" }

    public var index: Int

    @inlinable public init(index: Int) {
        self.index = index
    }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("SELECT", index)
    }
}

extension ValkeyClientProtocol {
    /// Authenticates the connection.
    ///
    /// - Documentation: [AUTH](https://valkey.io/commands/auth)
    /// - Available: 1.0.0
    /// - History:
    ///     * 6.0.0: Added ACL style (username and password).
    /// - Complexity: O(N) where N is the number of passwords defined for the user
    @inlinable
    public func auth<Password: RESPStringRenderable>(username: String? = nil, password: Password) async throws {
        _ = try await execute(AUTH(username: username, password: password))
    }

    /// A container for client connection commands.
    ///
    /// - Documentation: [CLIENT](https://valkey.io/commands/client)
    /// - Available: 2.4.0
    /// - Complexity: Depends on subcommand.
    @inlinable
    @discardableResult
    public func client() async throws -> CLIENT.Response {
        try await execute(CLIENT())
    }

    /// A client claims its capability.
    ///
    /// - Documentation: [CLIENT CAPA](https://valkey.io/commands/client-capa)
    /// - Available: 8.0.0
    /// - Complexity: O(1)
    @inlinable
    public func clientCapa<Capability: RESPStringRenderable>(capabilities: [Capability]) async throws {
        _ = try await execute(CLIENT.CAPA(capabilities: capabilities))
    }

    /// Returns the client ID to which the connection's tracking notifications are redirected.
    ///
    /// - Documentation: [CLIENT GETREDIR](https://valkey.io/commands/client-getredir)
    /// - Available: 6.0.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * 0: Not redirecting notifications to any client.
    ///     * -1: Client tracking is not enabled.
    ///     * [Integer]: ID of the client we are redirecting the notifications to.
    @inlinable
    @discardableResult
    public func clientGetredir() async throws -> Int {
        try await execute(CLIENT.GETREDIR())
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [CLIENT HELP](https://valkey.io/commands/client-help)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Array]: Helpful text about subcommands.
    @inlinable
    @discardableResult
    public func clientHelp() async throws -> RESPToken.Array {
        try await execute(CLIENT.HELP())
    }

    /// Mark this client as an import source when server is in import mode.
    ///
    /// - Documentation: [CLIENT IMPORT-SOURCE](https://valkey.io/commands/client-import-source)
    /// - Available: 8.1.0
    /// - Complexity: O(1)
    @inlinable
    public func clientImportSource(enabled: CLIENT.IMPORTSOURCE.Enabled) async throws {
        _ = try await execute(CLIENT.IMPORTSOURCE(enabled: enabled))
    }

    /// Terminates open connections.
    ///
    /// - Documentation: [CLIENT KILL](https://valkey.io/commands/client-kill)
    /// - Available: 2.4.0
    /// - History:
    ///     * 2.8.12: Added new filter format.
    ///     * 2.8.12: `ID` option.
    ///     * 3.2.0: Added `master` type in for `TYPE` option.
    ///     * 5.0.0: Replaced `slave` `TYPE` with `replica`. `slave` still supported for backward compatibility.
    ///     * 6.2.0: `LADDR` option.
    ///     * 8.0.0: `MAXAGE` option.
    ///     * 8.0.0: Replaced `master` `TYPE` with `primary`. `master` still supported for backward compatibility.
    ///     * 8.1.0: `ID` option accepts multiple IDs.
    ///     * 9.0.0: Added filters NAME, IDLE, FLAGS, LIB-NAME, LIB-VER, DB, CAPA, and IP. And negative filters NOT-ID, NOT-TYPE, NOT-ADDR, NOT-LADDR, NOT-USER, NOT-FLAGS, NOT-NAME, NOT-LIB-NAME, NOT-LIB-VER, NOT-DB, NOT-CAPA, NOT-IP.
    /// - Complexity: O(N) where N is the number of client connections
    /// - Response: One of the following
    ///     * "OK": When called in 3 argument format.
    ///     * [Integer]: When called in filter/value format, the number of clients killed.
    @inlinable
    @discardableResult
    public func clientKill(filter: CLIENT.KILL.Filter) async throws -> Int? {
        try await execute(CLIENT.KILL(filter: filter))
    }

    /// Lists open connections.
    ///
    /// - Documentation: [CLIENT LIST](https://valkey.io/commands/client-list)
    /// - Available: 2.4.0
    /// - History:
    ///     * 2.8.12: Added unique client `id` field.
    ///     * 5.0.0: Added optional `TYPE` filter.
    ///     * 6.0.0: Added `user` field.
    ///     * 6.2.0: Added `argv-mem`, `tot-mem`, `laddr` and `redir` fields and the optional `ID` filter.
    ///     * 7.0.0: Added `resp`, `multi-mem`, `rbs` and `rbp` fields.
    ///     * 7.0.3: Added `ssub` field.
    ///     * 8.0.0: Replaced `master` `TYPE` with `primary`. `master` still supported for backward compatibility.
    ///     * 8.1.0: Added filters USER, ADDR, LADDR, SKIPME, and MAXAGE.
    ///     * 9.0.0: Added filters NAME, IDLE, FLAGS, LIB-NAME, LIB-VER, DB, CAPA, and IP. And negative filters NOT-ID, NOT-TYPE, NOT-ADDR, NOT-LADDR, NOT-USER, NOT-FLAGS, NOT-NAME, NOT-LIB-NAME, NOT-LIB-VER, NOT-DB, NOT-CAPA, NOT-IP.
    /// - Complexity: O(N) where N is the number of client connections
    /// - Response: [String]: Information and statistics about client connections
    @inlinable
    @discardableResult
    public func clientList(
        clientType: CLIENT.LIST.ClientType? = nil,
        clientIds: [Int] = [],
        username: String? = nil,
        addr: String? = nil,
        laddr: String? = nil,
        skipme: CLIENT.LIST.Skipme? = nil,
        maxage: Int? = nil,
        name: String? = nil,
        idle: Int? = nil,
        flags: String? = nil,
        libName: String? = nil,
        libVer: String? = nil,
        db: Int? = nil,
        capa: String? = nil,
        ip: String? = nil,
        notClientType: CLIENT.LIST.NotClientType? = nil,
        notClientIds: [Int] = [],
        notUsername: String? = nil,
        notAddr: String? = nil,
        notLaddr: String? = nil,
        notName: String? = nil,
        notFlags: String? = nil,
        notLibName: String? = nil,
        notLibVer: String? = nil,
        notDb: Int? = nil,
        notCapa: String? = nil,
        notIp: String? = nil
    ) async throws -> ByteBuffer {
        try await execute(
            CLIENT.LIST(
                clientType: clientType,
                clientIds: clientIds,
                username: username,
                addr: addr,
                laddr: laddr,
                skipme: skipme,
                maxage: maxage,
                name: name,
                idle: idle,
                flags: flags,
                libName: libName,
                libVer: libVer,
                db: db,
                capa: capa,
                ip: ip,
                notClientType: notClientType,
                notClientIds: notClientIds,
                notUsername: notUsername,
                notAddr: notAddr,
                notLaddr: notLaddr,
                notName: notName,
                notFlags: notFlags,
                notLibName: notLibName,
                notLibVer: notLibVer,
                notDb: notDb,
                notCapa: notCapa,
                notIp: notIp
            )
        )
    }

    /// Sets the client eviction mode of the connection.
    ///
    /// - Documentation: [CLIENT NO-EVICT](https://valkey.io/commands/client-no-evict)
    /// - Available: 7.0.0
    /// - Complexity: O(1)
    @inlinable
    public func clientNoEvict(enabled: CLIENT.NOEVICT.Enabled) async throws {
        _ = try await execute(CLIENT.NOEVICT(enabled: enabled))
    }

    /// Controls whether commands sent by the client affect the LRU/LFU of accessed keys.
    ///
    /// - Documentation: [CLIENT NO-TOUCH](https://valkey.io/commands/client-no-touch)
    /// - Available: 7.2.0
    /// - Complexity: O(1)
    @inlinable
    public func clientNoTouch(enabled: CLIENT.NOTOUCH.Enabled) async throws {
        _ = try await execute(CLIENT.NOTOUCH(enabled: enabled))
    }

    /// Suspends commands processing.
    ///
    /// - Documentation: [CLIENT PAUSE](https://valkey.io/commands/client-pause)
    /// - Available: 3.0.0
    /// - History:
    ///     * 6.2.0: `CLIENT PAUSE WRITE` mode added along with the `mode` option.
    /// - Complexity: O(1)
    @inlinable
    public func clientPause(timeout: Int, mode: CLIENT.PAUSE.Mode? = nil) async throws {
        _ = try await execute(CLIENT.PAUSE(timeout: timeout, mode: mode))
    }

    /// Instructs the server whether to reply to commands.
    ///
    /// - Documentation: [CLIENT REPLY](https://valkey.io/commands/client-reply)
    /// - Available: 3.2.0
    /// - Complexity: O(1)
    /// - Response: "OK": When called with either OFF or SKIP subcommands, no reply is made. When called with ON, reply is OK.
    @inlinable
    public func clientReply(action: CLIENT.REPLY.Action) async throws {
        _ = try await execute(CLIENT.REPLY(action: action))
    }

    /// Unblocks a client blocked by a blocking command from a different connection.
    ///
    /// - Documentation: [CLIENT UNBLOCK](https://valkey.io/commands/client-unblock)
    /// - Available: 5.0.0
    /// - Complexity: O(log N) where N is the number of client connections
    /// - Response: One of the following
    ///     * 0: If the client was unblocked successfully.
    ///     * 1: If the client wasn't unblocked.
    @inlinable
    @discardableResult
    public func clientUnblock(clientId: Int, unblockType: CLIENT.UNBLOCK.UnblockType? = nil) async throws -> Int {
        try await execute(CLIENT.UNBLOCK(clientId: clientId, unblockType: unblockType))
    }

    /// Resumes processing commands from paused clients.
    ///
    /// - Documentation: [CLIENT UNPAUSE](https://valkey.io/commands/client-unpause)
    /// - Available: 6.2.0
    /// - Complexity: O(N) Where N is the number of paused clients
    @inlinable
    public func clientUnpause() async throws {
        _ = try await execute(CLIENT.UNPAUSE())
    }

    /// Returns the given string.
    ///
    /// - Documentation: [ECHO](https://valkey.io/commands/echo)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Response: [String]: The given string
    @inlinable
    @discardableResult
    public func echo<Message: RESPStringRenderable>(message: Message) async throws -> ByteBuffer {
        try await execute(ECHO(message: message))
    }

    /// Handshakes with the server.
    ///
    /// - Documentation: [HELLO](https://valkey.io/commands/hello)
    /// - Available: 6.0.0
    /// - History:
    ///     * 8.1.0: A new `availability_zone` field is added to the response if the `availability-zone` config is set.
    ///     * 6.2.0: `protover` made optional; when called without arguments the command reports the current connection's context.
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func hello(arguments: HELLO.Arguments? = nil) async throws -> RESPToken.Map {
        try await execute(HELLO(arguments: arguments))
    }

    /// Returns the server's liveliness response.
    ///
    /// - Documentation: [PING](https://valkey.io/commands/ping)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * "PONG": Default reply.
    ///     * [String]: Relay of given `message`.
    @inlinable
    @discardableResult
    public func ping(message: String? = nil) async throws -> PING.Response {
        try await execute(PING(message: message))
    }

    /// Closes the connection.
    ///
    /// - Documentation: [QUIT](https://valkey.io/commands/quit)
    /// - Available: 1.0.0
    /// - Deprecated since: 7.2.0. Replaced by just closing the connection.
    /// - Complexity: O(1)
    @inlinable
    public func quit() async throws {
        _ = try await execute(QUIT())
    }

    /// Resets the connection.
    ///
    /// - Documentation: [RESET](https://valkey.io/commands/reset)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func reset() async throws -> String {
        try await execute(RESET())
    }

    /// Changes the selected database.
    ///
    /// - Documentation: [SELECT](https://valkey.io/commands/select)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    @inlinable
    public func select(index: Int) async throws {
        _ = try await execute(SELECT(index: index))
    }

}

@available(valkeySwift 1.0, *)
extension ValkeyConnection {
    /// Instructs the server whether to track the keys in the next request.
    ///
    /// - Documentation: [CLIENT CACHING](https://valkey.io/commands/client-caching)
    /// - Available: 6.0.0
    /// - Complexity: O(1)
    @inlinable
    public func clientCaching(mode: CLIENT.CACHING.Mode) async throws {
        _ = try await execute(CLIENT.CACHING(mode: mode))
    }

    /// Returns the name of the connection.
    ///
    /// - Documentation: [CLIENT GETNAME](https://valkey.io/commands/client-getname)
    /// - Available: 2.6.9
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [String]: The connection name of the current connection
    ///     * [Null]: Connection name was not set
    @inlinable
    @discardableResult
    public func clientGetname() async throws -> ByteBuffer? {
        try await execute(CLIENT.GETNAME())
    }

    /// Returns the unique client ID of the connection.
    ///
    /// - Documentation: [CLIENT ID](https://valkey.io/commands/client-id)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Integer]: The id of the client
    @inlinable
    @discardableResult
    public func clientId() async throws -> Int {
        try await execute(CLIENT.ID())
    }

    /// Returns information about the connection.
    ///
    /// - Documentation: [CLIENT INFO](https://valkey.io/commands/client-info)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    /// - Response: [String]: A unique string, as described at the CLIENT LIST page, for the current client.
    @inlinable
    @discardableResult
    public func clientInfo() async throws -> ByteBuffer {
        try await execute(CLIENT.INFO())
    }

    /// Sets information specific to the client or connection.
    ///
    /// - Documentation: [CLIENT SETINFO](https://valkey.io/commands/client-setinfo)
    /// - Available: 7.2.0
    /// - Complexity: O(1)
    @inlinable
    public func clientSetinfo(attr: CLIENT.SETINFO.Attr) async throws {
        _ = try await execute(CLIENT.SETINFO(attr: attr))
    }

    /// Sets the connection name.
    ///
    /// - Documentation: [CLIENT SETNAME](https://valkey.io/commands/client-setname)
    /// - Available: 2.6.9
    /// - Complexity: O(1)
    @inlinable
    public func clientSetname<ConnectionName: RESPStringRenderable>(connectionName: ConnectionName) async throws {
        _ = try await execute(CLIENT.SETNAME(connectionName: connectionName))
    }

    /// Controls server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKING](https://valkey.io/commands/client-tracking)
    /// - Available: 6.0.0
    /// - Complexity: O(1). Some options may introduce additional complexity.
    /// - Response: "OK": If the client was successfully put into or taken out of tracking mode.
    @inlinable
    public func clientTracking(
        status: CLIENT.TRACKING.Status,
        clientId: Int? = nil,
        prefixes: [String] = [],
        bcast: Bool = false,
        optin: Bool = false,
        optout: Bool = false,
        noloop: Bool = false
    ) async throws {
        _ = try await execute(
            CLIENT.TRACKING(status: status, clientId: clientId, prefixes: prefixes, bcast: bcast, optin: optin, optout: optout, noloop: noloop)
        )
    }

    /// Returns information about server-assisted client-side caching for the connection.
    ///
    /// - Documentation: [CLIENT TRACKINGINFO](https://valkey.io/commands/client-trackinginfo)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func clientTrackinginfo() async throws -> RESPToken.Map {
        try await execute(CLIENT.TRACKINGINFO())
    }

}
