//===----------------------------------------------------------------------===//
//
// This source file is part of the valkey-swift open source project
//
// Copyright (c) 2025 the valkey-swift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of valkey-swift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// A container for object introspection commands.
@_documentation(visibility: internal)
public enum OBJECT {
    /// Returns the internal encoding of an object.
    @_documentation(visibility: internal)
    public struct ENCODING: ValkeyCommand {
        public typealias Response = ByteBuffer?

        public var key: ValkeyKey

        @inlinable public init(_ key: ValkeyKey) {
            self.key = key
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        public var isReadOnly: Bool { true }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("OBJECT", "ENCODING", key)
        }
    }

    /// Returns the logarithmic access frequency counter of an object.
    @_documentation(visibility: internal)
    public struct FREQ: ValkeyCommand {
        public typealias Response = Int

        public var key: ValkeyKey

        @inlinable public init(_ key: ValkeyKey) {
            self.key = key
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        public var isReadOnly: Bool { true }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("OBJECT", "FREQ", key)
        }
    }

    /// Returns helpful text about the different subcommands.
    @_documentation(visibility: internal)
    public struct HELP: ValkeyCommand {
        public typealias Response = RESPToken.Array

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("OBJECT", "HELP")
        }
    }

    /// Returns the time since the last access to an object.
    @_documentation(visibility: internal)
    public struct IDLETIME: ValkeyCommand {
        public typealias Response = Int

        public var key: ValkeyKey

        @inlinable public init(_ key: ValkeyKey) {
            self.key = key
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        public var isReadOnly: Bool { true }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("OBJECT", "IDLETIME", key)
        }
    }

    /// Returns the reference count of a value of a key.
    @_documentation(visibility: internal)
    public struct REFCOUNT: ValkeyCommand {
        public typealias Response = Int

        public var key: ValkeyKey

        @inlinable public init(_ key: ValkeyKey) {
            self.key = key
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        public var isReadOnly: Bool { true }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("OBJECT", "REFCOUNT", key)
        }
    }

}

/// Copies the value of a key to a new key.
@_documentation(visibility: internal)
public struct COPY: ValkeyCommand {
    public typealias Response = Int

    public var source: ValkeyKey
    public var destination: ValkeyKey
    public var destinationDb: Int?
    public var replace: Bool

    @inlinable public init(source: ValkeyKey, destination: ValkeyKey, destinationDb: Int? = nil, replace: Bool = false) {
        self.source = source
        self.destination = destination
        self.destinationDb = destinationDb
        self.replace = replace
    }

    public var keysAffected: [ValkeyKey] { [source, destination] }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("COPY", source, destination, RESPWithToken("DB", destinationDb), RESPPureToken("REPLACE", replace))
    }
}

/// Deletes one or more keys.
@_documentation(visibility: internal)
public struct DEL: ValkeyCommand {
    public typealias Response = Int

    public var keys: [ValkeyKey]

    @inlinable public init(keys: [ValkeyKey]) {
        self.keys = keys
    }

    public var keysAffected: [ValkeyKey] { keys }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("DEL", keys)
    }
}

/// Returns a serialized representation of the value stored at a key.
@_documentation(visibility: internal)
public struct DUMP: ValkeyCommand {
    public typealias Response = ByteBuffer?

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("DUMP", key)
    }
}

/// Determines whether one or more keys exist.
@_documentation(visibility: internal)
public struct EXISTS: ValkeyCommand {
    public typealias Response = Int

    public var keys: [ValkeyKey]

    @inlinable public init(keys: [ValkeyKey]) {
        self.keys = keys
    }

    public var keysAffected: [ValkeyKey] { keys }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("EXISTS", keys)
    }
}

/// Sets the expiration time of a key in seconds.
@_documentation(visibility: internal)
public struct EXPIRE: ValkeyCommand {
    public enum Condition: RESPRenderable, Sendable, Hashable {
        case nx
        case xx
        case gt
        case lt

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .nx: "NX".encode(into: &commandEncoder)
            case .xx: "XX".encode(into: &commandEncoder)
            case .gt: "GT".encode(into: &commandEncoder)
            case .lt: "LT".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = Int

    public var key: ValkeyKey
    public var seconds: Int
    public var condition: Condition?

    @inlinable public init(_ key: ValkeyKey, seconds: Int, condition: Condition? = nil) {
        self.key = key
        self.seconds = seconds
        self.condition = condition
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("EXPIRE", key, seconds, condition)
    }
}

/// Sets the expiration time of a key to a Unix timestamp.
@_documentation(visibility: internal)
public struct EXPIREAT: ValkeyCommand {
    public enum Condition: RESPRenderable, Sendable, Hashable {
        case nx
        case xx
        case gt
        case lt

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .nx: "NX".encode(into: &commandEncoder)
            case .xx: "XX".encode(into: &commandEncoder)
            case .gt: "GT".encode(into: &commandEncoder)
            case .lt: "LT".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = Int

    public var key: ValkeyKey
    public var unixTimeSeconds: Date
    public var condition: Condition?

    @inlinable public init(_ key: ValkeyKey, unixTimeSeconds: Date, condition: Condition? = nil) {
        self.key = key
        self.unixTimeSeconds = unixTimeSeconds
        self.condition = condition
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("EXPIREAT", key, Int(unixTimeSeconds.timeIntervalSince1970), condition)
    }
}

/// Returns the expiration time of a key as a Unix timestamp.
@_documentation(visibility: internal)
public struct EXPIRETIME: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("EXPIRETIME", key)
    }
}

/// Returns all key names that match a pattern.
@_documentation(visibility: internal)
public struct KEYS: ValkeyCommand {
    public typealias Response = RESPToken.Array

    public var pattern: String

    @inlinable public init(pattern: String) {
        self.pattern = pattern
    }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("KEYS", pattern)
    }
}

/// Atomically transfers a key from one instance to another.
@_documentation(visibility: internal)
public struct MIGRATE<Host: RESPStringRenderable>: ValkeyCommand {
    public enum KeySelector: RESPRenderable, Sendable, Hashable {
        case key(ValkeyKey)
        case emptyString

        @inlinable
        public var respEntries: Int {
            switch self {
            case .key(let key): key.respEntries
            case .emptyString: "\"\"".respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .key(let key): key.encode(into: &commandEncoder)
            case .emptyString: "\"\"".encode(into: &commandEncoder)
            }
        }
    }
    public struct AuthenticationAuth2: RESPRenderable, Sendable, Hashable {
        @usableFromInline let username: String
        @usableFromInline let password: String

        @inlinable public init(username: String, password: String) {
            self.username = username
            self.password = password
        }

        @inlinable
        public var respEntries: Int {
            username.respEntries + password.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            username.encode(into: &commandEncoder)
            password.encode(into: &commandEncoder)
        }
    }
    public enum Authentication: RESPRenderable, Sendable, Hashable {
        case auth(String)
        case auth2(AuthenticationAuth2)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .auth(let auth): RESPWithToken("AUTH", auth).respEntries
            case .auth2(let auth2): RESPWithToken("AUTH2", auth2).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .auth(let auth): RESPWithToken("AUTH", auth).encode(into: &commandEncoder)
            case .auth2(let auth2): RESPWithToken("AUTH2", auth2).encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = String?

    public var host: Host
    public var port: Int
    public var keySelector: KeySelector
    public var destinationDb: Int
    public var timeout: Int
    public var copy: Bool
    public var replace: Bool
    public var authentication: Authentication?
    public var keyss: [ValkeyKey]

    @inlinable public init(
        host: Host,
        port: Int,
        keySelector: KeySelector,
        destinationDb: Int,
        timeout: Int,
        copy: Bool = false,
        replace: Bool = false,
        authentication: Authentication? = nil,
        keyss: [ValkeyKey] = []
    ) {
        self.host = host
        self.port = port
        self.keySelector = keySelector
        self.destinationDb = destinationDb
        self.timeout = timeout
        self.copy = copy
        self.replace = replace
        self.authentication = authentication
        self.keyss = keyss
    }

    public var keysAffected: [ValkeyKey] { keyss }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "MIGRATE",
            RESPBulkString(host),
            port,
            keySelector,
            destinationDb,
            timeout,
            RESPPureToken("COPY", copy),
            RESPPureToken("REPLACE", replace),
            authentication,
            RESPWithToken("KEYS", keyss)
        )
    }
}

/// Moves a key to another database.
@_documentation(visibility: internal)
public struct MOVE: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var db: Int

    @inlinable public init(_ key: ValkeyKey, db: Int) {
        self.key = key
        self.db = db
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("MOVE", key, db)
    }
}

/// Removes the expiration time of a key.
@_documentation(visibility: internal)
public struct PERSIST: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("PERSIST", key)
    }
}

/// Sets the expiration time of a key in milliseconds.
@_documentation(visibility: internal)
public struct PEXPIRE: ValkeyCommand {
    public enum Condition: RESPRenderable, Sendable, Hashable {
        case nx
        case xx
        case gt
        case lt

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .nx: "NX".encode(into: &commandEncoder)
            case .xx: "XX".encode(into: &commandEncoder)
            case .gt: "GT".encode(into: &commandEncoder)
            case .lt: "LT".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = Int

    public var key: ValkeyKey
    public var milliseconds: Int
    public var condition: Condition?

    @inlinable public init(_ key: ValkeyKey, milliseconds: Int, condition: Condition? = nil) {
        self.key = key
        self.milliseconds = milliseconds
        self.condition = condition
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("PEXPIRE", key, milliseconds, condition)
    }
}

/// Sets the expiration time of a key to a Unix milliseconds timestamp.
@_documentation(visibility: internal)
public struct PEXPIREAT: ValkeyCommand {
    public enum Condition: RESPRenderable, Sendable, Hashable {
        case nx
        case xx
        case gt
        case lt

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .nx: "NX".encode(into: &commandEncoder)
            case .xx: "XX".encode(into: &commandEncoder)
            case .gt: "GT".encode(into: &commandEncoder)
            case .lt: "LT".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = Int

    public var key: ValkeyKey
    public var unixTimeMilliseconds: Date
    public var condition: Condition?

    @inlinable public init(_ key: ValkeyKey, unixTimeMilliseconds: Date, condition: Condition? = nil) {
        self.key = key
        self.unixTimeMilliseconds = unixTimeMilliseconds
        self.condition = condition
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("PEXPIREAT", key, Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000), condition)
    }
}

/// Returns the expiration time of a key as a Unix milliseconds timestamp.
@_documentation(visibility: internal)
public struct PEXPIRETIME: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("PEXPIRETIME", key)
    }
}

/// Returns the expiration time in milliseconds of a key.
@_documentation(visibility: internal)
public struct PTTL: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("PTTL", key)
    }
}

/// Returns a random key name from the database.
@_documentation(visibility: internal)
public struct RANDOMKEY: ValkeyCommand {
    public typealias Response = ByteBuffer?

    @inlinable public init() {
    }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("RANDOMKEY")
    }
}

/// Renames a key and overwrites the destination.
@_documentation(visibility: internal)
public struct RENAME: ValkeyCommand {
    public var key: ValkeyKey
    public var newkey: ValkeyKey

    @inlinable public init(_ key: ValkeyKey, newkey: ValkeyKey) {
        self.key = key
        self.newkey = newkey
    }

    public var keysAffected: [ValkeyKey] { [key, newkey] }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("RENAME", key, newkey)
    }
}

/// Renames a key only when the target key name doesn't exist.
@_documentation(visibility: internal)
public struct RENAMENX: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var newkey: ValkeyKey

    @inlinable public init(_ key: ValkeyKey, newkey: ValkeyKey) {
        self.key = key
        self.newkey = newkey
    }

    public var keysAffected: [ValkeyKey] { [key, newkey] }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("RENAMENX", key, newkey)
    }
}

/// Creates a key from the serialized representation of a value.
@_documentation(visibility: internal)
public struct RESTORE<SerializedValue: RESPStringRenderable>: ValkeyCommand {
    public var key: ValkeyKey
    public var ttl: Int
    public var serializedValue: SerializedValue
    public var replace: Bool
    public var absttl: Bool
    public var seconds: Int?
    public var frequency: Int?

    @inlinable public init(
        _ key: ValkeyKey,
        ttl: Int,
        serializedValue: SerializedValue,
        replace: Bool = false,
        absttl: Bool = false,
        seconds: Int? = nil,
        frequency: Int? = nil
    ) {
        self.key = key
        self.ttl = ttl
        self.serializedValue = serializedValue
        self.replace = replace
        self.absttl = absttl
        self.seconds = seconds
        self.frequency = frequency
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "RESTORE",
            key,
            ttl,
            RESPBulkString(serializedValue),
            RESPPureToken("REPLACE", replace),
            RESPPureToken("ABSTTL", absttl),
            RESPWithToken("IDLETIME", seconds),
            RESPWithToken("FREQ", frequency)
        )
    }
}

/// Iterates over the key names in the database.
@_documentation(visibility: internal)
public struct SCAN: ValkeyCommand {
    public typealias Response = RESPToken.Array

    public var cursor: Int
    public var pattern: String?
    public var count: Int?
    public var type: String?

    @inlinable public init(cursor: Int, pattern: String? = nil, count: Int? = nil, type: String? = nil) {
        self.cursor = cursor
        self.pattern = pattern
        self.count = count
        self.type = type
    }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("SCAN", cursor, RESPWithToken("MATCH", pattern), RESPWithToken("COUNT", count), RESPWithToken("TYPE", type))
    }
}

/// Sorts the elements in a list, a set, or a sorted set, optionally storing the result.
@_documentation(visibility: internal)
public struct SORT: ValkeyCommand {
    public struct Limit: RESPRenderable, Sendable, Hashable {
        @usableFromInline let offset: Int
        @usableFromInline let count: Int

        @inlinable public init(offset: Int, count: Int) {
            self.offset = offset
            self.count = count
        }

        @inlinable
        public var respEntries: Int {
            offset.respEntries + count.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            offset.encode(into: &commandEncoder)
            count.encode(into: &commandEncoder)
        }
    }
    public enum Order: RESPRenderable, Sendable, Hashable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public var key: ValkeyKey
    public var byPattern: String?
    public var limit: Limit?
    public var getPatterns: [String]
    public var order: Order?
    public var sorting: Bool
    public var destination: ValkeyKey?

    @inlinable public init(
        _ key: ValkeyKey,
        byPattern: String? = nil,
        limit: Limit? = nil,
        getPatterns: [String] = [],
        order: Order? = nil,
        sorting: Bool = false,
        destination: ValkeyKey? = nil
    ) {
        self.key = key
        self.byPattern = byPattern
        self.limit = limit
        self.getPatterns = getPatterns
        self.order = order
        self.sorting = sorting
        self.destination = destination
    }

    public var keysAffected: [ValkeyKey] { (destination.map { [$0] } ?? []) + [key] }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "SORT",
            key,
            RESPWithToken("BY", byPattern),
            RESPWithToken("LIMIT", limit),
            RESPWithToken("GET", getPatterns),
            order,
            RESPPureToken("ALPHA", sorting),
            RESPWithToken("STORE", destination)
        )
    }
}

/// Returns the sorted elements of a list, a set, or a sorted set.
@_documentation(visibility: internal)
public struct SORTRO: ValkeyCommand {
    public struct Limit: RESPRenderable, Sendable, Hashable {
        @usableFromInline let offset: Int
        @usableFromInline let count: Int

        @inlinable public init(offset: Int, count: Int) {
            self.offset = offset
            self.count = count
        }

        @inlinable
        public var respEntries: Int {
            offset.respEntries + count.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            offset.encode(into: &commandEncoder)
            count.encode(into: &commandEncoder)
        }
    }
    public enum Order: RESPRenderable, Sendable, Hashable {
        case asc
        case desc

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .asc: "ASC".encode(into: &commandEncoder)
            case .desc: "DESC".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPToken.Array

    public var key: ValkeyKey
    public var byPattern: String?
    public var limit: Limit?
    public var getPatterns: [String]
    public var order: Order?
    public var sorting: Bool

    @inlinable public init(
        _ key: ValkeyKey,
        byPattern: String? = nil,
        limit: Limit? = nil,
        getPatterns: [String] = [],
        order: Order? = nil,
        sorting: Bool = false
    ) {
        self.key = key
        self.byPattern = byPattern
        self.limit = limit
        self.getPatterns = getPatterns
        self.order = order
        self.sorting = sorting
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "SORT_RO",
            key,
            RESPWithToken("BY", byPattern),
            RESPWithToken("LIMIT", limit),
            RESPWithToken("GET", getPatterns),
            order,
            RESPPureToken("ALPHA", sorting)
        )
    }
}

/// Returns the number of existing keys out of those specified after updating the time they were last accessed.
@_documentation(visibility: internal)
public struct TOUCH: ValkeyCommand {
    public typealias Response = Int

    public var keys: [ValkeyKey]

    @inlinable public init(keys: [ValkeyKey]) {
        self.keys = keys
    }

    public var keysAffected: [ValkeyKey] { keys }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("TOUCH", keys)
    }
}

/// Returns the expiration time in seconds of a key.
@_documentation(visibility: internal)
public struct TTL: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("TTL", key)
    }
}

/// Determines the type of value stored at a key.
@_documentation(visibility: internal)
public struct TYPE: ValkeyCommand {
    public typealias Response = ByteBuffer?

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("TYPE", key)
    }
}

/// Asynchronously deletes one or more keys.
@_documentation(visibility: internal)
public struct UNLINK: ValkeyCommand {
    public typealias Response = Int

    public var keys: [ValkeyKey]

    @inlinable public init(keys: [ValkeyKey]) {
        self.keys = keys
    }

    public var keysAffected: [ValkeyKey] { keys }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("UNLINK", keys)
    }
}

/// Blocks until the asynchronous replication of all preceding write commands sent by the connection is completed.
@_documentation(visibility: internal)
public struct WAIT: ValkeyCommand {
    public typealias Response = Int

    public var numreplicas: Int
    public var timeout: Int

    @inlinable public init(numreplicas: Int, timeout: Int) {
        self.numreplicas = numreplicas
        self.timeout = timeout
    }

    public var isBlocking: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("WAIT", numreplicas, timeout)
    }
}

/// Blocks until all of the preceding write commands sent by the connection are written to the append-only file of the primary and/or replicas.
@_documentation(visibility: internal)
public struct WAITAOF: ValkeyCommand {
    public typealias Response = RESPToken.Array

    public var numlocal: Int
    public var numreplicas: Int
    public var timeout: Int

    @inlinable public init(numlocal: Int, numreplicas: Int, timeout: Int) {
        self.numlocal = numlocal
        self.numreplicas = numreplicas
        self.timeout = timeout
    }

    public var isBlocking: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("WAITAOF", numlocal, numreplicas, timeout)
    }
}

extension ValkeyConnectionProtocol {
    /// Copies the value of a key to a new key.
    ///
    /// - Documentation: [COPY](https://valkey.io/commands/copy)
    /// - Available: 6.2.0
    /// - Complexity: O(N) worst case for collections, where N is the number of nested items. O(1) for string values.
    /// - Response: One of the following
    ///     * 1: Source was copied.
    ///     * 0: Source was not copied when the destination key already exists
    @inlinable
    @discardableResult
    public func copy(source: ValkeyKey, destination: ValkeyKey, destinationDb: Int? = nil, replace: Bool = false) async throws -> Int {
        try await send(command: COPY(source: source, destination: destination, destinationDb: destinationDb, replace: replace))
    }

    /// Deletes one or more keys.
    ///
    /// - Documentation: [DEL](https://valkey.io/commands/del)
    /// - Available: 1.0.0
    /// - Complexity: O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).
    /// - Response: [Integer]: The number of keys that were removed.
    @inlinable
    @discardableResult
    public func del(keys: [ValkeyKey]) async throws -> Int {
        try await send(command: DEL(keys: keys))
    }

    /// Returns a serialized representation of the value stored at a key.
    ///
    /// - Documentation: [DUMP](https://valkey.io/commands/dump)
    /// - Available: 2.6.0
    /// - Complexity: O(1) to access the key and additional O(N*M) to serialize it, where N is the number of objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1).
    /// - Response: One of the following
    ///     * [String]: The serialized value.
    ///     * [Null]: Key does not exist.
    @inlinable
    public func dump(_ key: ValkeyKey) async throws -> ByteBuffer? {
        try await send(command: DUMP(key))
    }

    /// Determines whether one or more keys exist.
    ///
    /// - Documentation: [EXISTS](https://valkey.io/commands/exists)
    /// - Available: 1.0.0
    /// - History:
    ///     * 3.0.3: Accepts multiple `key` arguments.
    /// - Complexity: O(N) where N is the number of keys to check.
    /// - Response: [Integer]: Number of keys that exist from those specified as arguments.
    @inlinable
    public func exists(keys: [ValkeyKey]) async throws -> Int {
        try await send(command: EXISTS(keys: keys))
    }

    /// Sets the expiration time of a key in seconds.
    ///
    /// - Documentation: [EXPIRE](https://valkey.io/commands/expire)
    /// - Available: 1.0.0
    /// - History:
    ///     * 7.0.0: Added options: `NX`, `XX`, `GT` and `LT`.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * 0: The timeout was not set. e.g. key doesn't exist, or operation skipped due to the provided arguments.
    ///     * 1: The timeout was set.
    @inlinable
    @discardableResult
    public func expire(_ key: ValkeyKey, seconds: Int, condition: EXPIRE.Condition? = nil) async throws -> Int {
        try await send(command: EXPIRE(key, seconds: seconds, condition: condition))
    }

    /// Sets the expiration time of a key to a Unix timestamp.
    ///
    /// - Documentation: [EXPIREAT](https://valkey.io/commands/expireat)
    /// - Available: 1.2.0
    /// - History:
    ///     * 7.0.0: Added options: `NX`, `XX`, `GT` and `LT`.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * 1: The timeout was set.
    ///     * 0: The timeout was not set. e.g. key doesn't exist, or operation skipped due to the provided arguments.
    @inlinable
    @discardableResult
    public func expireat(_ key: ValkeyKey, unixTimeSeconds: Date, condition: EXPIREAT.Condition? = nil) async throws -> Int {
        try await send(command: EXPIREAT(key, unixTimeSeconds: unixTimeSeconds, condition: condition))
    }

    /// Returns the expiration time of a key as a Unix timestamp.
    ///
    /// - Documentation: [EXPIRETIME](https://valkey.io/commands/expiretime)
    /// - Available: 7.0.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [Integer]: Expiration Unix timestamp in seconds.
    ///     * -1: The key exists but has no associated expiration time.
    ///     * -2: The key does not exist.
    @inlinable
    public func expiretime(_ key: ValkeyKey) async throws -> Int {
        try await send(command: EXPIRETIME(key))
    }

    /// Returns all key names that match a pattern.
    ///
    /// - Documentation: [KEYS](https://valkey.io/commands/keys)
    /// - Available: 1.0.0
    /// - Complexity: O(N) with N being the number of keys in the database, under the assumption that the key names in the database and the given pattern have limited length.
    /// - Response: [Array]: List of keys matching pattern.
    @inlinable
    public func keys(pattern: String) async throws -> RESPToken.Array {
        try await send(command: KEYS(pattern: pattern))
    }

    /// Atomically transfers a key from one instance to another.
    ///
    /// - Documentation: [MIGRATE](https://valkey.io/commands/migrate)
    /// - Available: 2.6.0
    /// - History:
    ///     * 3.0.0: Added the `COPY` and `REPLACE` options.
    ///     * 3.0.6: Added the `KEYS` option.
    ///     * 4.0.7: Added the `AUTH` option.
    ///     * 6.0.0: Added the `AUTH2` option.
    /// - Complexity: This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed.
    /// - Response: One of the following
    ///     * "OK": Success.
    ///     * "NOKEY": No keys were found in the source instance.
    @inlinable
    @discardableResult
    public func migrate<Host: RESPStringRenderable>(
        host: Host,
        port: Int,
        keySelector: MIGRATE<Host>.KeySelector,
        destinationDb: Int,
        timeout: Int,
        copy: Bool = false,
        replace: Bool = false,
        authentication: MIGRATE<Host>.Authentication? = nil,
        keyss: [ValkeyKey] = []
    ) async throws -> String? {
        try await send(
            command: MIGRATE(
                host: host,
                port: port,
                keySelector: keySelector,
                destinationDb: destinationDb,
                timeout: timeout,
                copy: copy,
                replace: replace,
                authentication: authentication,
                keyss: keyss
            )
        )
    }

    /// Moves a key to another database.
    ///
    /// - Documentation: [MOVE](https://valkey.io/commands/move)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * 1: Key was moved.
    ///     * 0: Key wasn't moved. When key already exists in the destination database, or it does not exist in the source database
    @inlinable
    @discardableResult
    public func move(_ key: ValkeyKey, db: Int) async throws -> Int {
        try await send(command: MOVE(key, db: db))
    }

    /// Returns the internal encoding of an object.
    ///
    /// - Documentation: [OBJECT ENCODING](https://valkey.io/commands/object-encoding)
    /// - Available: 2.2.3
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [Null]: Key doesn't exist.
    ///     * [String]: Encoding of the object.
    @inlinable
    public func objectEncoding(_ key: ValkeyKey) async throws -> ByteBuffer? {
        try await send(command: OBJECT.ENCODING(key))
    }

    /// Returns the logarithmic access frequency counter of an object.
    ///
    /// - Documentation: [OBJECT FREQ](https://valkey.io/commands/object-freq)
    /// - Available: 4.0.0
    /// - Complexity: O(1)
    /// - Response: [Integer]: The counter's value.
    @inlinable
    public func objectFreq(_ key: ValkeyKey) async throws -> Int {
        try await send(command: OBJECT.FREQ(key))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [OBJECT HELP](https://valkey.io/commands/object-help)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    /// - Response: [Array]: Helpful text about subcommands.
    @inlinable
    @discardableResult
    public func objectHelp() async throws -> RESPToken.Array {
        try await send(command: OBJECT.HELP())
    }

    /// Returns the time since the last access to an object.
    ///
    /// - Documentation: [OBJECT IDLETIME](https://valkey.io/commands/object-idletime)
    /// - Available: 2.2.3
    /// - Complexity: O(1)
    /// - Response: [Integer]: The idle time in seconds.
    @inlinable
    public func objectIdletime(_ key: ValkeyKey) async throws -> Int {
        try await send(command: OBJECT.IDLETIME(key))
    }

    /// Returns the reference count of a value of a key.
    ///
    /// - Documentation: [OBJECT REFCOUNT](https://valkey.io/commands/object-refcount)
    /// - Available: 2.2.3
    /// - Complexity: O(1)
    /// - Response: [Integer]: The number of references.
    @inlinable
    public func objectRefcount(_ key: ValkeyKey) async throws -> Int {
        try await send(command: OBJECT.REFCOUNT(key))
    }

    /// Removes the expiration time of a key.
    ///
    /// - Documentation: [PERSIST](https://valkey.io/commands/persist)
    /// - Available: 2.2.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * 0: Key does not exist or does not have an associated timeout.
    ///     * 1: The timeout has been removed.
    @inlinable
    @discardableResult
    public func persist(_ key: ValkeyKey) async throws -> Int {
        try await send(command: PERSIST(key))
    }

    /// Sets the expiration time of a key in milliseconds.
    ///
    /// - Documentation: [PEXPIRE](https://valkey.io/commands/pexpire)
    /// - Available: 2.6.0
    /// - History:
    ///     * 7.0.0: Added options: `NX`, `XX`, `GT` and `LT`.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * 0: The timeout was not set. e.g. key doesn't exist, or operation skipped due to the provided arguments.
    ///     * 1: The timeout was set.
    @inlinable
    @discardableResult
    public func pexpire(_ key: ValkeyKey, milliseconds: Int, condition: PEXPIRE.Condition? = nil) async throws -> Int {
        try await send(command: PEXPIRE(key, milliseconds: milliseconds, condition: condition))
    }

    /// Sets the expiration time of a key to a Unix milliseconds timestamp.
    ///
    /// - Documentation: [PEXPIREAT](https://valkey.io/commands/pexpireat)
    /// - Available: 2.6.0
    /// - History:
    ///     * 7.0.0: Added options: `NX`, `XX`, `GT` and `LT`.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * 1: The timeout was set.
    ///     * 0: The timeout was not set. e.g. key doesn't exist, or operation skipped due to the provided arguments.
    @inlinable
    @discardableResult
    public func pexpireat(_ key: ValkeyKey, unixTimeMilliseconds: Date, condition: PEXPIREAT.Condition? = nil) async throws -> Int {
        try await send(command: PEXPIREAT(key, unixTimeMilliseconds: unixTimeMilliseconds, condition: condition))
    }

    /// Returns the expiration time of a key as a Unix milliseconds timestamp.
    ///
    /// - Documentation: [PEXPIRETIME](https://valkey.io/commands/pexpiretime)
    /// - Available: 7.0.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [Integer]: Expiration Unix timestamp in milliseconds.
    ///     * -1: The key exists but has no associated expiration time.
    ///     * -2: The key does not exist.
    @inlinable
    public func pexpiretime(_ key: ValkeyKey) async throws -> Int {
        try await send(command: PEXPIRETIME(key))
    }

    /// Returns the expiration time in milliseconds of a key.
    ///
    /// - Documentation: [PTTL](https://valkey.io/commands/pttl)
    /// - Available: 2.6.0
    /// - History:
    ///     * 2.8.0: Added the -2 reply.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [Integer]: TTL in milliseconds.
    ///     * -1: The key exists but has no associated expire.
    ///     * -2: The key does not exist.
    @inlinable
    public func pttl(_ key: ValkeyKey) async throws -> Int {
        try await send(command: PTTL(key))
    }

    /// Returns a random key name from the database.
    ///
    /// - Documentation: [RANDOMKEY](https://valkey.io/commands/randomkey)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [Null]: When the database is empty.
    ///     * [String]: Random key in db.
    @inlinable
    public func randomkey() async throws -> ByteBuffer? {
        try await send(command: RANDOMKEY())
    }

    /// Renames a key and overwrites the destination.
    ///
    /// - Documentation: [RENAME](https://valkey.io/commands/rename)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    @inlinable
    public func rename(_ key: ValkeyKey, newkey: ValkeyKey) async throws {
        _ = try await send(command: RENAME(key, newkey: newkey))
    }

    /// Renames a key only when the target key name doesn't exist.
    ///
    /// - Documentation: [RENAMENX](https://valkey.io/commands/renamenx)
    /// - Available: 1.0.0
    /// - History:
    ///     * 3.2.0: The command no longer returns an error when source and destination names are the same.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * 1: Key was renamed to newkey.
    ///     * 0: New key already exists.
    @inlinable
    @discardableResult
    public func renamenx(_ key: ValkeyKey, newkey: ValkeyKey) async throws -> Int {
        try await send(command: RENAMENX(key, newkey: newkey))
    }

    /// Creates a key from the serialized representation of a value.
    ///
    /// - Documentation: [RESTORE](https://valkey.io/commands/restore)
    /// - Available: 2.6.0
    /// - History:
    ///     * 3.0.0: Added the `REPLACE` modifier.
    ///     * 5.0.0: Added the `ABSTTL` modifier.
    ///     * 5.0.0: Added the `IDLETIME` and `FREQ` options.
    /// - Complexity: O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N)).
    @inlinable
    public func restore<SerializedValue: RESPStringRenderable>(
        _ key: ValkeyKey,
        ttl: Int,
        serializedValue: SerializedValue,
        replace: Bool = false,
        absttl: Bool = false,
        seconds: Int? = nil,
        frequency: Int? = nil
    ) async throws {
        _ = try await send(
            command: RESTORE(
                key,
                ttl: ttl,
                serializedValue: serializedValue,
                replace: replace,
                absttl: absttl,
                seconds: seconds,
                frequency: frequency
            )
        )
    }

    /// Iterates over the key names in the database.
    ///
    /// - Documentation: [SCAN](https://valkey.io/commands/scan)
    /// - Available: 2.8.0
    /// - History:
    ///     * 6.0.0: Added the `TYPE` subcommand.
    /// - Complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.
    /// - Response: [Array]: Cursor and scan response in array form.
    @inlinable
    public func scan(cursor: Int, pattern: String? = nil, count: Int? = nil, type: String? = nil) async throws -> RESPToken.Array {
        try await send(command: SCAN(cursor: cursor, pattern: pattern, count: count, type: type))
    }

    /// Sorts the elements in a list, a set, or a sorted set, optionally storing the result.
    ///
    /// - Documentation: [SORT](https://valkey.io/commands/sort)
    /// - Available: 1.0.0
    /// - Complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
    /// - Response: One of the following
    ///     * [Integer]: When the store option is specified the command returns the number of sorted elements in the destination list.
    ///     * [Array]: When not passing the store option the command returns a list of sorted elements.
    @inlinable
    @discardableResult
    public func sort(
        _ key: ValkeyKey,
        byPattern: String? = nil,
        limit: SORT.Limit? = nil,
        getPatterns: [String] = [],
        order: SORT.Order? = nil,
        sorting: Bool = false,
        destination: ValkeyKey? = nil
    ) async throws -> SORT.Response {
        try await send(
            command: SORT(key, byPattern: byPattern, limit: limit, getPatterns: getPatterns, order: order, sorting: sorting, destination: destination)
        )
    }

    /// Returns the sorted elements of a list, a set, or a sorted set.
    ///
    /// - Documentation: [SORT_RO](https://valkey.io/commands/sort_ro)
    /// - Available: 7.0.0
    /// - Complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).
    /// - Response: [Array]: A list of sorted elements.
    @inlinable
    public func sortRo(
        _ key: ValkeyKey,
        byPattern: String? = nil,
        limit: SORTRO.Limit? = nil,
        getPatterns: [String] = [],
        order: SORTRO.Order? = nil,
        sorting: Bool = false
    ) async throws -> RESPToken.Array {
        try await send(command: SORTRO(key, byPattern: byPattern, limit: limit, getPatterns: getPatterns, order: order, sorting: sorting))
    }

    /// Returns the number of existing keys out of those specified after updating the time they were last accessed.
    ///
    /// - Documentation: [TOUCH](https://valkey.io/commands/touch)
    /// - Available: 3.2.1
    /// - Complexity: O(N) where N is the number of keys that will be touched.
    /// - Response: [Integer]: The number of touched keys.
    @inlinable
    public func touch(keys: [ValkeyKey]) async throws -> Int {
        try await send(command: TOUCH(keys: keys))
    }

    /// Returns the expiration time in seconds of a key.
    ///
    /// - Documentation: [TTL](https://valkey.io/commands/ttl)
    /// - Available: 1.0.0
    /// - History:
    ///     * 2.8.0: Added the -2 reply.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [Integer]: TTL in seconds.
    ///     * -1: The key exists but has no associated expire.
    ///     * -2: The key does not exist.
    @inlinable
    public func ttl(_ key: ValkeyKey) async throws -> Int {
        try await send(command: TTL(key))
    }

    /// Determines the type of value stored at a key.
    ///
    /// - Documentation: [TYPE](https://valkey.io/commands/type)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [Null]: Key doesn't exist
    ///     * [String]: Type of the key
    @inlinable
    public func type(_ key: ValkeyKey) async throws -> ByteBuffer? {
        try await send(command: TYPE(key))
    }

    /// Asynchronously deletes one or more keys.
    ///
    /// - Documentation: [UNLINK](https://valkey.io/commands/unlink)
    /// - Available: 4.0.0
    /// - Complexity: O(1) for each key removed regardless of its size. Then the command does O(N) work in a different thread in order to reclaim memory, where N is the number of allocations the deleted objects where composed of.
    /// - Response: [Integer]: The number of keys that were unlinked.
    @inlinable
    @discardableResult
    public func unlink(keys: [ValkeyKey]) async throws -> Int {
        try await send(command: UNLINK(keys: keys))
    }

    /// Blocks until the asynchronous replication of all preceding write commands sent by the connection is completed.
    ///
    /// - Documentation: [WAIT](https://valkey.io/commands/wait)
    /// - Available: 3.0.0
    /// - Complexity: O(1)
    /// - Response: [Integer]: The number of replicas reached by all the writes performed in the context of the current connection.
    @inlinable
    @discardableResult
    public func wait(numreplicas: Int, timeout: Int) async throws -> Int {
        try await send(command: WAIT(numreplicas: numreplicas, timeout: timeout))
    }

    /// Blocks until all of the preceding write commands sent by the connection are written to the append-only file of the primary and/or replicas.
    ///
    /// - Documentation: [WAITAOF](https://valkey.io/commands/waitaof)
    /// - Available: 7.2.0
    /// - Complexity: O(1)
    /// - Response: [Array]: Number of local and remote AOF files in sync.
    @inlinable
    @discardableResult
    public func waitaof(numlocal: Int, numreplicas: Int, timeout: Int) async throws -> RESPToken.Array {
        try await send(command: WAITAOF(numlocal: numlocal, numreplicas: numreplicas, timeout: timeout))
    }

}
