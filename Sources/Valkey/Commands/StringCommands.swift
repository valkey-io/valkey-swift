//
// This source file is part of the valkey-swift project
// Copyright (c) 2025-2026 the valkey-swift project authors
//
// See LICENSE.txt for license information
// SPDX-License-Identifier: Apache-2.0
//
// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// Appends a string to the value of a key. Creates the key if it doesn't exist.
@_documentation(visibility: internal)
public struct APPEND<Value: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "APPEND" }

    public var key: ValkeyKey
    public var value: Value

    @inlinable public init(_ key: ValkeyKey, value: Value) {
        self.key = key
        self.value = value
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("APPEND", key, RESPRenderableBulkString(value))
    }
}

/// Decrements the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
@_documentation(visibility: internal)
public struct DECR: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "DECR" }

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("DECR", key)
    }
}

/// Decrements a number from the integer value of a key. Uses 0 as initial value if the key doesn't exist.
@_documentation(visibility: internal)
public struct DECRBY: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "DECRBY" }

    public var key: ValkeyKey
    public var decrement: Int

    @inlinable public init(_ key: ValkeyKey, decrement: Int) {
        self.key = key
        self.decrement = decrement
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("DECRBY", key, decrement)
    }
}

/// Delete key if value matches string.
@_documentation(visibility: internal)
public struct DELIFEQ<Value: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "DELIFEQ" }

    public var key: ValkeyKey
    public var value: Value

    @inlinable public init(_ key: ValkeyKey, value: Value) {
        self.key = key
        self.value = value
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("DELIFEQ", key, RESPRenderableBulkString(value))
    }
}

/// Returns the string value of a key.
@_documentation(visibility: internal)
public struct GET: ValkeyCommand {
    public typealias Response = RESPBulkString?

    @inlinable public static var name: String { "GET" }

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GET", key)
    }
}

/// Returns the string value of a key after deleting the key.
@_documentation(visibility: internal)
public struct GETDEL: ValkeyCommand {
    public typealias Response = RESPBulkString?

    @inlinable public static var name: String { "GETDEL" }

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GETDEL", key)
    }
}

/// Returns the string value of a key after setting its expiration time.
@_documentation(visibility: internal)
public struct GETEX: ValkeyCommand {
    public enum Expiration: RESPRenderable, Sendable, Hashable {
        case seconds(Int)
        case milliseconds(Int)
        case unixTimeSeconds(Date)
        case unixTimeMilliseconds(Date)
        case persist

        @inlinable
        public var respEntries: Int {
            switch self {
            case .seconds(let seconds): RESPWithToken("EX", seconds).respEntries
            case .milliseconds(let milliseconds): RESPWithToken("PX", milliseconds).respEntries
            case .unixTimeSeconds(let unixTimeSeconds): RESPWithToken("EXAT", Int(unixTimeSeconds.timeIntervalSince1970)).respEntries
            case .unixTimeMilliseconds(let unixTimeMilliseconds):
                RESPWithToken("PXAT", Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000)).respEntries
            case .persist: "PERSIST".respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .seconds(let seconds): RESPWithToken("EX", seconds).encode(into: &commandEncoder)
            case .milliseconds(let milliseconds): RESPWithToken("PX", milliseconds).encode(into: &commandEncoder)
            case .unixTimeSeconds(let unixTimeSeconds):
                RESPWithToken("EXAT", Int(unixTimeSeconds.timeIntervalSince1970)).encode(into: &commandEncoder)
            case .unixTimeMilliseconds(let unixTimeMilliseconds):
                RESPWithToken("PXAT", Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000)).encode(into: &commandEncoder)
            case .persist: "PERSIST".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPBulkString?

    @inlinable public static var name: String { "GETEX" }

    public var key: ValkeyKey
    public var expiration: Expiration?

    @inlinable public init(_ key: ValkeyKey, expiration: Expiration? = nil) {
        self.key = key
        self.expiration = expiration
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GETEX", key, expiration)
    }
}

/// Returns a substring of the string stored at a key.
@_documentation(visibility: internal)
public struct GETRANGE: ValkeyCommand {
    public typealias Response = RESPBulkString

    @inlinable public static var name: String { "GETRANGE" }

    public var key: ValkeyKey
    public var start: Int
    public var end: Int

    @inlinable public init(_ key: ValkeyKey, start: Int, end: Int) {
        self.key = key
        self.start = start
        self.end = end
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GETRANGE", key, start, end)
    }
}

/// Returns the previous string value of a key after setting it to a new value.
@_documentation(visibility: internal)
public struct GETSET<Value: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = RESPBulkString?

    @inlinable public static var name: String { "GETSET" }

    public var key: ValkeyKey
    public var value: Value

    @inlinable public init(_ key: ValkeyKey, value: Value) {
        self.key = key
        self.value = value
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("GETSET", key, RESPRenderableBulkString(value))
    }
}

/// Increments the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
@_documentation(visibility: internal)
public struct INCR: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "INCR" }

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("INCR", key)
    }
}

/// Increments the integer value of a key by a number. Uses 0 as initial value if the key doesn't exist.
@_documentation(visibility: internal)
public struct INCRBY: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "INCRBY" }

    public var key: ValkeyKey
    public var increment: Int

    @inlinable public init(_ key: ValkeyKey, increment: Int) {
        self.key = key
        self.increment = increment
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("INCRBY", key, increment)
    }
}

/// Increment the floating point value of a key by a number. Uses 0 as initial value if the key doesn't exist.
@_documentation(visibility: internal)
public struct INCRBYFLOAT: ValkeyCommand {
    public typealias Response = RESPBulkString

    @inlinable public static var name: String { "INCRBYFLOAT" }

    public var key: ValkeyKey
    public var increment: Double

    @inlinable public init(_ key: ValkeyKey, increment: Double) {
        self.key = key
        self.increment = increment
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("INCRBYFLOAT", key, increment)
    }
}

/// Finds the longest common substring.
@_documentation(visibility: internal)
public struct LCS: ValkeyCommand {
    @inlinable public static var name: String { "LCS" }

    public var key1: ValkeyKey
    public var key2: ValkeyKey
    public var len: Bool
    public var idx: Bool
    public var minMatchLen: Int?
    public var withmatchlen: Bool

    @inlinable public init(
        key1: ValkeyKey,
        key2: ValkeyKey,
        len: Bool = false,
        idx: Bool = false,
        minMatchLen: Int? = nil,
        withmatchlen: Bool = false
    ) {
        self.key1 = key1
        self.key2 = key2
        self.len = len
        self.idx = idx
        self.minMatchLen = minMatchLen
        self.withmatchlen = withmatchlen
    }

    public var keysAffected: [ValkeyKey] { [key1, key2] }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "LCS",
            key1,
            key2,
            RESPPureToken("LEN", len),
            RESPPureToken("IDX", idx),
            RESPWithToken("MINMATCHLEN", minMatchLen),
            RESPPureToken("WITHMATCHLEN", withmatchlen)
        )
    }
}

/// Atomically returns the string values of one or more keys.
@_documentation(visibility: internal)
public struct MGET: ValkeyCommand {
    public typealias Response = RESPToken.Array

    @inlinable public static var name: String { "MGET" }

    public var keys: [ValkeyKey]

    @inlinable public init(keys: [ValkeyKey]) {
        self.keys = keys
    }

    public var keysAffected: [ValkeyKey] { keys }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("MGET", keys)
    }
}

/// Atomically creates or modifies the string values of one or more keys.
@_documentation(visibility: internal)
public struct MSET<Value: RESPStringRenderable>: ValkeyCommand {
    public struct Data: RESPRenderable, Sendable, Hashable {
        public var key: ValkeyKey
        public var value: Value

        @inlinable
        public init(key: ValkeyKey, value: Value) {
            self.key = key
            self.value = value
        }

        @inlinable
        public var respEntries: Int {
            key.respEntries + RESPRenderableBulkString(value).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            key.encode(into: &commandEncoder)
            RESPRenderableBulkString(value).encode(into: &commandEncoder)
        }
    }
    @inlinable public static var name: String { "MSET" }

    public var data: [Data]

    @inlinable public init(data: [Data]) {
        self.data = data
    }

    public var keysAffected: [ValkeyKey] { data.map { $0.key } }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("MSET", data)
    }
}

/// Atomically modifies the string values of one or more keys only when all keys don't exist.
@_documentation(visibility: internal)
public struct MSETNX<Value: RESPStringRenderable>: ValkeyCommand {
    public struct Data: RESPRenderable, Sendable, Hashable {
        public var key: ValkeyKey
        public var value: Value

        @inlinable
        public init(key: ValkeyKey, value: Value) {
            self.key = key
            self.value = value
        }

        @inlinable
        public var respEntries: Int {
            key.respEntries + RESPRenderableBulkString(value).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            key.encode(into: &commandEncoder)
            RESPRenderableBulkString(value).encode(into: &commandEncoder)
        }
    }
    public typealias Response = Int

    @inlinable public static var name: String { "MSETNX" }

    public var data: [Data]

    @inlinable public init(data: [Data]) {
        self.data = data
    }

    public var keysAffected: [ValkeyKey] { data.map { $0.key } }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("MSETNX", data)
    }
}

/// Sets both string value and expiration time in milliseconds of a key. The key is created if it doesn't exist.
@_documentation(visibility: internal)
public struct PSETEX<Value: RESPStringRenderable>: ValkeyCommand {
    @inlinable public static var name: String { "PSETEX" }

    public var key: ValkeyKey
    public var milliseconds: Int
    public var value: Value

    @inlinable public init(_ key: ValkeyKey, milliseconds: Int, value: Value) {
        self.key = key
        self.milliseconds = milliseconds
        self.value = value
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("PSETEX", key, milliseconds, RESPRenderableBulkString(value))
    }
}

/// Sets the string value of a key, ignoring its type. The key is created if it doesn't exist.
@_documentation(visibility: internal)
public struct SET<Value: RESPStringRenderable>: ValkeyCommand {
    public enum Condition: RESPRenderable, Sendable, Hashable {
        case nx
        case xx
        case comparisonValue(String)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .nx: "NX".respEntries
            case .xx: "XX".respEntries
            case .comparisonValue(let comparisonValue): RESPWithToken("IFEQ", comparisonValue).respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .nx: "NX".encode(into: &commandEncoder)
            case .xx: "XX".encode(into: &commandEncoder)
            case .comparisonValue(let comparisonValue): RESPWithToken("IFEQ", comparisonValue).encode(into: &commandEncoder)
            }
        }
    }
    public enum Expiration: RESPRenderable, Sendable, Hashable {
        case seconds(Int)
        case milliseconds(Int)
        case unixTimeSeconds(Date)
        case unixTimeMilliseconds(Date)
        case keepttl

        @inlinable
        public var respEntries: Int {
            switch self {
            case .seconds(let seconds): RESPWithToken("EX", seconds).respEntries
            case .milliseconds(let milliseconds): RESPWithToken("PX", milliseconds).respEntries
            case .unixTimeSeconds(let unixTimeSeconds): RESPWithToken("EXAT", Int(unixTimeSeconds.timeIntervalSince1970)).respEntries
            case .unixTimeMilliseconds(let unixTimeMilliseconds):
                RESPWithToken("PXAT", Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000)).respEntries
            case .keepttl: "KEEPTTL".respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .seconds(let seconds): RESPWithToken("EX", seconds).encode(into: &commandEncoder)
            case .milliseconds(let milliseconds): RESPWithToken("PX", milliseconds).encode(into: &commandEncoder)
            case .unixTimeSeconds(let unixTimeSeconds):
                RESPWithToken("EXAT", Int(unixTimeSeconds.timeIntervalSince1970)).encode(into: &commandEncoder)
            case .unixTimeMilliseconds(let unixTimeMilliseconds):
                RESPWithToken("PXAT", Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000)).encode(into: &commandEncoder)
            case .keepttl: "KEEPTTL".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = RESPBulkString?

    @inlinable public static var name: String { "SET" }

    public var key: ValkeyKey
    public var value: Value
    public var condition: Condition?
    public var get: Bool
    public var expiration: Expiration?

    @inlinable public init(_ key: ValkeyKey, value: Value, condition: Condition? = nil, get: Bool = false, expiration: Expiration? = nil) {
        self.key = key
        self.value = value
        self.condition = condition
        self.get = get
        self.expiration = expiration
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("SET", key, RESPRenderableBulkString(value), condition, RESPPureToken("GET", get), expiration)
    }
}

/// Sets the string value and expiration time of a key. Creates the key if it doesn't exist.
@_documentation(visibility: internal)
public struct SETEX<Value: RESPStringRenderable>: ValkeyCommand {
    @inlinable public static var name: String { "SETEX" }

    public var key: ValkeyKey
    public var seconds: Int
    public var value: Value

    @inlinable public init(_ key: ValkeyKey, seconds: Int, value: Value) {
        self.key = key
        self.seconds = seconds
        self.value = value
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("SETEX", key, seconds, RESPRenderableBulkString(value))
    }
}

/// Set the string value of a key only when the key doesn't exist.
@_documentation(visibility: internal)
public struct SETNX<Value: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "SETNX" }

    public var key: ValkeyKey
    public var value: Value

    @inlinable public init(_ key: ValkeyKey, value: Value) {
        self.key = key
        self.value = value
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("SETNX", key, RESPRenderableBulkString(value))
    }
}

/// Overwrites a part of a string value with another by an offset. Creates the key if it doesn't exist.
@_documentation(visibility: internal)
public struct SETRANGE<Value: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "SETRANGE" }

    public var key: ValkeyKey
    public var offset: Int
    public var value: Value

    @inlinable public init(_ key: ValkeyKey, offset: Int, value: Value) {
        self.key = key
        self.offset = offset
        self.value = value
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("SETRANGE", key, offset, RESPRenderableBulkString(value))
    }
}

/// Returns the length of a string value.
@_documentation(visibility: internal)
public struct STRLEN: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "STRLEN" }

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("STRLEN", key)
    }
}

/// Returns a substring from a string value.
@_documentation(visibility: internal)
public struct SUBSTR: ValkeyCommand {
    public typealias Response = RESPBulkString

    @inlinable public static var name: String { "SUBSTR" }

    public var key: ValkeyKey
    public var start: Int
    public var end: Int

    @inlinable public init(_ key: ValkeyKey, start: Int, end: Int) {
        self.key = key
        self.start = start
        self.end = end
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("SUBSTR", key, start, end)
    }
}

@available(valkeySwift 1.0, *)
extension ValkeyClientProtocol {
    /// Appends a string to the value of a key. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [APPEND](https://valkey.io/commands/append)
    /// - Available: 2.0.0
    /// - Complexity: O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by the server will double the free space available on every reallocation.
    /// - Returns: The length of the string after the append operation.
    @inlinable
    @discardableResult
    public func append<Value: RESPStringRenderable>(_ key: ValkeyKey, value: Value) async throws(ValkeyClientError) -> Int {
        try await execute(APPEND(key, value: value))
    }

    /// Decrements the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [DECR](https://valkey.io/commands/decr)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Returns: The value of the key after decrementing it.
    @inlinable
    @discardableResult
    public func decr(_ key: ValkeyKey) async throws(ValkeyClientError) -> Int {
        try await execute(DECR(key))
    }

    /// Decrements a number from the integer value of a key. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [DECRBY](https://valkey.io/commands/decrby)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Returns: The value of the key after decrementing it.
    @inlinable
    @discardableResult
    public func decrby(_ key: ValkeyKey, decrement: Int) async throws(ValkeyClientError) -> Int {
        try await execute(DECRBY(key, decrement: decrement))
    }

    /// Delete key if value matches string.
    ///
    /// - Documentation: [DELIFEQ](https://valkey.io/commands/delifeq)
    /// - Available: 9.0.0
    /// - Complexity: O(1)
    /// - Returns: One of the following
    ///     * 0: The key was not deleted.
    ///     * 1: The key was deleted.
    @inlinable
    @discardableResult
    public func delifeq<Value: RESPStringRenderable>(_ key: ValkeyKey, value: Value) async throws(ValkeyClientError) -> Int {
        try await execute(DELIFEQ(key, value: value))
    }

    /// Returns the string value of a key.
    ///
    /// - Documentation: [GET](https://valkey.io/commands/get)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Returns: One of the following
    ///     * The value of the key.
    ///     * nil: Key does not exist.
    @inlinable
    public func get(_ key: ValkeyKey) async throws(ValkeyClientError) -> RESPBulkString? {
        try await execute(GET(key))
    }

    /// Returns the string value of a key after deleting the key.
    ///
    /// - Documentation: [GETDEL](https://valkey.io/commands/getdel)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    /// - Returns: One of the following
    ///     * The value of the key.
    ///     * nil: The key does not exist.
    @inlinable
    @discardableResult
    public func getdel(_ key: ValkeyKey) async throws(ValkeyClientError) -> RESPBulkString? {
        try await execute(GETDEL(key))
    }

    /// Returns the string value of a key after setting its expiration time.
    ///
    /// - Documentation: [GETEX](https://valkey.io/commands/getex)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    /// - Returns: One of the following
    ///     * The value of the key.
    ///     * nil: Key does not exist.
    @inlinable
    @discardableResult
    public func getex(_ key: ValkeyKey, expiration: GETEX.Expiration? = nil) async throws(ValkeyClientError) -> RESPBulkString? {
        try await execute(GETEX(key, expiration: expiration))
    }

    /// Returns a substring of the string stored at a key.
    ///
    /// - Documentation: [GETRANGE](https://valkey.io/commands/getrange)
    /// - Available: 2.4.0
    /// - Complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
    /// - Returns: The substring of the string value stored at key, determined by the offsets start and end (both are inclusive).
    @inlinable
    public func getrange(_ key: ValkeyKey, start: Int, end: Int) async throws(ValkeyClientError) -> RESPBulkString {
        try await execute(GETRANGE(key, start: start, end: end))
    }

    /// Returns the previous string value of a key after setting it to a new value.
    ///
    /// - Documentation: [GETSET](https://valkey.io/commands/getset)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Returns: One of the following
    ///     * The old value stored at the key.
    ///     * nil: The key does not exist.
    @inlinable
    @discardableResult
    public func getset<Value: RESPStringRenderable>(_ key: ValkeyKey, value: Value) async throws(ValkeyClientError) -> RESPBulkString? {
        try await execute(GETSET(key, value: value))
    }

    /// Increments the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCR](https://valkey.io/commands/incr)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Returns: The value of key after the increment
    @inlinable
    @discardableResult
    public func incr(_ key: ValkeyKey) async throws(ValkeyClientError) -> Int {
        try await execute(INCR(key))
    }

    /// Increments the integer value of a key by a number. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCRBY](https://valkey.io/commands/incrby)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Returns: The value of the key after incrementing it.
    @inlinable
    @discardableResult
    public func incrby(_ key: ValkeyKey, increment: Int) async throws(ValkeyClientError) -> Int {
        try await execute(INCRBY(key, increment: increment))
    }

    /// Increment the floating point value of a key by a number. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCRBYFLOAT](https://valkey.io/commands/incrbyfloat)
    /// - Available: 2.6.0
    /// - Complexity: O(1)
    /// - Returns: The value of the key after incrementing it.
    @inlinable
    @discardableResult
    public func incrbyfloat(_ key: ValkeyKey, increment: Double) async throws(ValkeyClientError) -> RESPBulkString {
        try await execute(INCRBYFLOAT(key, increment: increment))
    }

    /// Finds the longest common substring.
    ///
    /// - Documentation: [LCS](https://valkey.io/commands/lcs)
    /// - Available: 7.0.0
    /// - Complexity: O(N*M) where N and M are the lengths of s1 and s2, respectively
    /// - Returns: One of the following
    ///     * The longest common subsequence.
    ///     * The length of the longest common subsequence when 'LEN' is given.
    ///     * Array with the LCS length and all the ranges in both the strings when 'IDX' is given. In RESP2 this is returned as a flat array
    @inlinable
    public func lcs(
        key1: ValkeyKey,
        key2: ValkeyKey,
        len: Bool = false,
        idx: Bool = false,
        minMatchLen: Int? = nil,
        withmatchlen: Bool = false
    ) async throws(ValkeyClientError) -> LCS.Response {
        try await execute(LCS(key1: key1, key2: key2, len: len, idx: idx, minMatchLen: minMatchLen, withmatchlen: withmatchlen))
    }

    /// Atomically returns the string values of one or more keys.
    ///
    /// - Documentation: [MGET](https://valkey.io/commands/mget)
    /// - Available: 1.0.0
    /// - Complexity: O(N) where N is the number of keys to retrieve.
    /// - Returns: List of values at the specified keys.
    @inlinable
    public func mget(keys: [ValkeyKey]) async throws(ValkeyClientError) -> RESPToken.Array {
        try await execute(MGET(keys: keys))
    }

    /// Atomically creates or modifies the string values of one or more keys.
    ///
    /// - Documentation: [MSET](https://valkey.io/commands/mset)
    /// - Available: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    @inlinable
    public func mset<Value: RESPStringRenderable>(data: [MSET<Value>.Data]) async throws(ValkeyClientError) {
        _ = try await execute(MSET(data: data))
    }

    /// Atomically modifies the string values of one or more keys only when all keys don't exist.
    ///
    /// - Documentation: [MSETNX](https://valkey.io/commands/msetnx)
    /// - Available: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Returns: One of the following
    ///     * 0: No key was set (at least one key already existed).
    ///     * 1: All the keys were set.
    @inlinable
    @discardableResult
    public func msetnx<Value: RESPStringRenderable>(data: [MSETNX<Value>.Data]) async throws(ValkeyClientError) -> Int {
        try await execute(MSETNX(data: data))
    }

    /// Sets both string value and expiration time in milliseconds of a key. The key is created if it doesn't exist.
    ///
    /// - Documentation: [PSETEX](https://valkey.io/commands/psetex)
    /// - Available: 2.6.0
    /// - Complexity: O(1)
    @inlinable
    public func psetex<Value: RESPStringRenderable>(_ key: ValkeyKey, milliseconds: Int, value: Value) async throws(ValkeyClientError) {
        _ = try await execute(PSETEX(key, milliseconds: milliseconds, value: value))
    }

    /// Sets the string value of a key, ignoring its type. The key is created if it doesn't exist.
    ///
    /// - Documentation: [SET](https://valkey.io/commands/set)
    /// - Available: 1.0.0
    /// - History:
    ///     * 2.6.12: Added the `EX`, `PX`, `NX` and `XX` options.
    ///     * 6.0.0: Added the `KEEPTTL` option.
    ///     * 6.2.0: Added the `GET`, `EXAT` and `PXAT` option.
    ///     * 7.0.0: Allowed the `NX` and `GET` options to be used together.
    ///     * 8.1.0: Added the `IFEQ` option.
    /// - Complexity: O(1)
    /// - Returns: One of the following
    ///     * nil: `GET` not given: Operation was aborted (conflict with one of the `XX`/`NX` options).
    ///     * "OK": `GET` not given: The key was set.
    ///     * nil: `GET` given: The key didn't exist before the `SET`
    ///     * `GET` given: The previous value of the key
    @inlinable
    @discardableResult
    public func set<Value: RESPStringRenderable>(
        _ key: ValkeyKey,
        value: Value,
        condition: SET<Value>.Condition? = nil,
        get: Bool = false,
        expiration: SET<Value>.Expiration? = nil
    ) async throws(ValkeyClientError) -> RESPBulkString? {
        try await execute(SET(key, value: value, condition: condition, get: get, expiration: expiration))
    }

    /// Sets the string value and expiration time of a key. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETEX](https://valkey.io/commands/setex)
    /// - Available: 2.0.0
    /// - Complexity: O(1)
    @inlinable
    public func setex<Value: RESPStringRenderable>(_ key: ValkeyKey, seconds: Int, value: Value) async throws(ValkeyClientError) {
        _ = try await execute(SETEX(key, seconds: seconds, value: value))
    }

    /// Set the string value of a key only when the key doesn't exist.
    ///
    /// - Documentation: [SETNX](https://valkey.io/commands/setnx)
    /// - Available: 1.0.0
    /// - Complexity: O(1)
    /// - Returns: One of the following
    ///     * 0: The key was set.
    ///     * 1: The key was not set.
    @inlinable
    @discardableResult
    public func setnx<Value: RESPStringRenderable>(_ key: ValkeyKey, value: Value) async throws(ValkeyClientError) -> Int {
        try await execute(SETNX(key, value: value))
    }

    /// Overwrites a part of a string value with another by an offset. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETRANGE](https://valkey.io/commands/setrange)
    /// - Available: 2.2.0
    /// - Complexity: O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.
    /// - Returns: Length of the string after it was modified by the command.
    @inlinable
    @discardableResult
    public func setrange<Value: RESPStringRenderable>(_ key: ValkeyKey, offset: Int, value: Value) async throws(ValkeyClientError) -> Int {
        try await execute(SETRANGE(key, offset: offset, value: value))
    }

    /// Returns the length of a string value.
    ///
    /// - Documentation: [STRLEN](https://valkey.io/commands/strlen)
    /// - Available: 2.2.0
    /// - Complexity: O(1)
    /// - Returns: The length of the string value stored at key, or 0 when key does not exist.
    @inlinable
    public func strlen(_ key: ValkeyKey) async throws(ValkeyClientError) -> Int {
        try await execute(STRLEN(key))
    }

    /// Returns a substring from a string value.
    ///
    /// - Documentation: [SUBSTR](https://valkey.io/commands/substr)
    /// - Available: 1.0.0
    /// - Complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
    /// - Returns: The substring of the string value stored at key, determined by the offsets start and end (both are inclusive).
    @inlinable
    public func substr(_ key: ValkeyKey, start: Int, end: Int) async throws(ValkeyClientError) -> RESPBulkString {
        try await execute(SUBSTR(key, start: start, end: end))
    }

}
