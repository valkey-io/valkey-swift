//
// This source file is part of the valkey-swift project
// Copyright (c) 2025 the valkey-swift project authors
//
// See LICENSE.txt for license information
// SPDX-License-Identifier: Apache-2.0
//
// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

extension FUNCTION {
    public typealias LOADResponse = String
}

extension FUNCTION.LIST {
    public typealias Response = [ResponseElement]
    public struct ResponseElement: RESPTokenDecodable, Sendable {
        public struct Function: RESPTokenDecodable, Sendable {
            public let name: String
            public let description: String?
            public let flags: [String]

            public init(fromRESP token: RESPToken) throws {
                let map = try [String: RESPToken](fromRESP: token)
                guard let name = map["name"] else { throw RESPDecodeError.missingToken(key: "name", token: token) }
                guard let description = map["description"] else { throw RESPDecodeError.missingToken(key: "description", token: token) }
                guard let flags = map["flags"] else { throw RESPDecodeError.missingToken(key: "flags", token: token) }
                self.name = try String(fromRESP: name)
                self.description = try String?(fromRESP: description)
                self.flags = try [String](fromRESP: flags)
            }
        }
        public let libraryName: String
        public let engine: String
        public let functions: [Function]
        public let libraryCode: String?

        public init(fromRESP token: RESPToken) throws {
            let map = try [String: RESPToken](fromRESP: token)
            guard let libraryName = map["library_name"] else { throw RESPDecodeError.missingToken(key: "library_name", token: token) }
            guard let engine = map["engine"] else { throw RESPDecodeError.missingToken(key: "engine", token: token) }
            guard let functions = map["functions"] else { throw RESPDecodeError.missingToken(key: "functions", token: token) }
            let libraryCode = map["library_code"]
            self.libraryName = try String(fromRESP: libraryName)
            self.engine = try String(fromRESP: engine)
            self.functions = try [Function](fromRESP: functions)
            self.libraryCode = try libraryCode.map { try String(fromRESP: $0) }
        }
    }
}

extension FUNCTION.LOAD {
    public typealias Response = FUNCTION.LOADResponse
}

extension FUNCTION.STATS {
    public struct Response: RESPTokenDecodable, Sendable {

        public struct Script: RESPTokenDecodable, Sendable {
            public let name: String
            public let command: [ByteBuffer]
            public let durationInMilliseconds: Double

            public init(fromRESP token: RESPToken) throws {
                let map = try [String: RESPToken](fromRESP: token)
                guard let name = map["name"] else { throw RESPDecodeError.missingToken(key: "name", token: token) }
                guard let command = map["command"] else { throw RESPDecodeError.missingToken(key: "command", token: token) }
                guard let duration = map["duration_ms"] else { throw RESPDecodeError.missingToken(key: "duration_ms", token: token) }
                self.name = try .init(fromRESP: name)
                self.command = try .init(fromRESP: command)
                self.durationInMilliseconds = try Double(fromRESP: duration)
            }
        }
        public struct Engine: RESPTokenDecodable, Sendable {
            public let libraryCount: Int
            public let functionCount: Int

            public init(fromRESP token: RESPToken) throws {
                let map = try [String: RESPToken](fromRESP: token)
                guard let libraryCount = map["libraries_count"] else { throw RESPDecodeError.missingToken(key: "libraries_count", token: token) }
                guard let functionCount = map["functions_count"] else { throw RESPDecodeError.missingToken(key: "functions_count", token: token) }
                self.libraryCount = try .init(fromRESP: libraryCount)
                self.functionCount = try .init(fromRESP: functionCount)
            }
        }
        public let runningScript: Script
        public let engines: [String: Engine]
        public init(fromRESP token: RESPToken) throws {
            let map = try [String: RESPToken](fromRESP: token)
            guard let runningScript = map["running_script"] else { throw RESPDecodeError.missingToken(key: "running_script", token: token) }
            guard let engines = map["engines"] else { throw RESPDecodeError.missingToken(key: "engines", token: token) }
            self.runningScript = try .init(fromRESP: runningScript)
            self.engines = try .init(fromRESP: engines)
        }
    }
}

extension SCRIPT {
    public typealias LOADResponse = String
    public typealias EXISTSResponse = [Int]
    public typealias SHOWResponse = String
}

extension SCRIPT.LOAD {
    public typealias Response = SCRIPT.LOADResponse
}

extension SCRIPT.EXISTS {
    public typealias Response = SCRIPT.EXISTSResponse
}

extension SCRIPT.SHOW {
    public typealias Response = SCRIPT.SHOWResponse
}
