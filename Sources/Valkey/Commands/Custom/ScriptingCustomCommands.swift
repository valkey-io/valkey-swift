//
// This source file is part of the valkey-swift project
// Copyright (c) 2025 the valkey-swift project authors
//
// See LICENSE.txt for license information
// SPDX-License-Identifier: Apache-2.0
//
// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

extension FUNCTION {
    public typealias LOADResponse = String
}

extension FUNCTION.LIST {
    public typealias Response = [ResponseElement]
    public struct ResponseElement: RESPTokenDecodable, Sendable {
        public struct Function: RESPTokenDecodable, Sendable {
            public let name: String
            public let description: String?
            public let flags: [String]

            public init(_ token: RESPToken) throws {
                let map = try [String: RESPToken](token)
                guard let name = map["name"] else { throw RESPDecodeError.missingToken(key: "name", token: token) }
                guard let description = map["description"] else { throw RESPDecodeError.missingToken(key: "description", token: token) }
                guard let flags = map["flags"] else { throw RESPDecodeError.missingToken(key: "flags", token: token) }
                self.name = try String(name)
                self.description = try String?(description)
                self.flags = try [String](flags)
            }
        }
        public let libraryName: String
        public let engine: String
        public let functions: [Function]
        public let libraryCode: String?

        public init(_ token: RESPToken) throws {
            let map = try [String: RESPToken](token)
            guard let libraryName = map["library_name"] else { throw RESPDecodeError.missingToken(key: "library_name", token: token) }
            guard let engine = map["engine"] else { throw RESPDecodeError.missingToken(key: "engine", token: token) }
            guard let functions = map["functions"] else { throw RESPDecodeError.missingToken(key: "functions", token: token) }
            let libraryCode = map["library_code"]
            self.libraryName = try String(libraryName)
            self.engine = try String(engine)
            self.functions = try [Function](functions)
            self.libraryCode = try libraryCode.map { try String($0) }
        }
    }
}

extension FUNCTION.LOAD {
    public typealias Response = FUNCTION.LOADResponse
}

extension FUNCTION.STATS {
    public struct Response: RESPTokenDecodable, Sendable {

        public struct Script: RESPTokenDecodable, Sendable {
            public let name: String
            public let command: [RESPBulkString]
            public let durationInMilliseconds: Double

            public init(_ token: RESPToken) throws {
                let map = try [String: RESPToken](token)
                guard let name = map["name"] else { throw RESPDecodeError.missingToken(key: "name", token: token) }
                guard let command = map["command"] else { throw RESPDecodeError.missingToken(key: "command", token: token) }
                guard let duration = map["duration_ms"] else { throw RESPDecodeError.missingToken(key: "duration_ms", token: token) }
                self.name = try .init(name)
                self.command = try .init(command)
                self.durationInMilliseconds = try Double(duration)
            }
        }
        public struct Engine: RESPTokenDecodable, Sendable {
            public let libraryCount: Int
            public let functionCount: Int

            public init(_ token: RESPToken) throws {
                let map = try [String: RESPToken](token)
                guard let libraryCount = map["libraries_count"] else { throw RESPDecodeError.missingToken(key: "libraries_count", token: token) }
                guard let functionCount = map["functions_count"] else { throw RESPDecodeError.missingToken(key: "functions_count", token: token) }
                self.libraryCount = try .init(libraryCount)
                self.functionCount = try .init(functionCount)
            }
        }
        public let runningScript: Script
        public let engines: [String: Engine]
        public init(_ token: RESPToken) throws {
            let map = try [String: RESPToken](token)
            guard let runningScript = map["running_script"] else { throw RESPDecodeError.missingToken(key: "running_script", token: token) }
            guard let engines = map["engines"] else { throw RESPDecodeError.missingToken(key: "engines", token: token) }
            self.runningScript = try .init(runningScript)
            self.engines = try .init(engines)
        }
    }
}
