//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-valkey open source project
//
// Copyright (c) 2025 the swift-valkey project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-valkey project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// A container for Pub/Sub commands.
public enum PUBSUB {
    /// Returns the active channels.
    public struct CHANNELS: RESPCommand {
        public typealias Response = RESPToken.Array

        public var pattern: String?

        @inlinable public init(pattern: String? = nil) {
            self.pattern = pattern
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "CHANNELS", pattern)
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: RESPCommand {
        public typealias Response = RESPToken.Array

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "HELP")
        }
    }

    /// Returns a count of unique pattern subscriptions.
    public struct NUMPAT: RESPCommand {
        public typealias Response = Int

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "NUMPAT")
        }
    }

    /// Returns a count of subscribers to channels.
    public struct NUMSUB: RESPCommand {
        public typealias Response = RESPToken.Array

        public var channel: [String]

        @inlinable public init(channel: [String] = []) {
            self.channel = channel
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "NUMSUB", channel)
        }
    }

    /// Returns the active shard channels.
    public struct SHARDCHANNELS: RESPCommand {
        public typealias Response = RESPToken.Array

        public var pattern: String?

        @inlinable public init(pattern: String? = nil) {
            self.pattern = pattern
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "SHARDCHANNELS", pattern)
        }
    }

    /// Returns the count of subscribers of shard channels.
    public struct SHARDNUMSUB: RESPCommand {
        public typealias Response = RESPToken.Array

        public var shardchannel: [String]

        @inlinable public init(shardchannel: [String] = []) {
            self.shardchannel = shardchannel
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("PUBSUB", "SHARDNUMSUB", shardchannel)
        }
    }

}

/// Listens for messages published to channels that match one or more patterns.
public struct PSUBSCRIBE: RESPCommand {
    public var pattern: [String]

    @inlinable public init(pattern: [String]) {
        self.pattern = pattern
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("PSUBSCRIBE", pattern)
    }
}

/// Posts a message to a channel.
public struct PUBLISH<Channel: RESPStringRenderable, Message: RESPStringRenderable>: RESPCommand {
    public typealias Response = Int

    public var channel: Channel
    public var message: Message

    @inlinable public init(channel: Channel, message: Message) {
        self.channel = channel
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("PUBLISH", RESPBulkString(channel), RESPBulkString(message))
    }
}

/// Stops listening to messages published to channels that match one or more patterns.
public struct PUNSUBSCRIBE: RESPCommand {
    public var pattern: [String]

    @inlinable public init(pattern: [String] = []) {
        self.pattern = pattern
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("PUNSUBSCRIBE", pattern)
    }
}

/// Post a message to a shard channel
public struct SPUBLISH<Shardchannel: RESPStringRenderable, Message: RESPStringRenderable>: RESPCommand {
    public typealias Response = Int

    public var shardchannel: Shardchannel
    public var message: Message

    @inlinable public init(shardchannel: Shardchannel, message: Message) {
        self.shardchannel = shardchannel
        self.message = message
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SPUBLISH", RESPBulkString(shardchannel), RESPBulkString(message))
    }
}

/// Listens for messages published to shard channels.
public struct SSUBSCRIBE<Shardchannel: RESPStringRenderable>: RESPCommand {
    public var shardchannel: [Shardchannel]

    @inlinable public init(shardchannel: [Shardchannel]) {
        self.shardchannel = shardchannel
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SSUBSCRIBE", shardchannel.map { RESPBulkString($0) })
    }
}

/// Listens for messages published to channels.
public struct SUBSCRIBE<Channel: RESPStringRenderable>: RESPCommand {
    public var channel: [Channel]

    @inlinable public init(channel: [Channel]) {
        self.channel = channel
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SUBSCRIBE", channel.map { RESPBulkString($0) })
    }
}

/// Stops listening to messages posted to shard channels.
public struct SUNSUBSCRIBE: RESPCommand {
    public var shardchannel: [String]

    @inlinable public init(shardchannel: [String] = []) {
        self.shardchannel = shardchannel
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SUNSUBSCRIBE", shardchannel)
    }
}

/// Stops listening to messages posted to channels.
public struct UNSUBSCRIBE: RESPCommand {
    public var channel: [String]

    @inlinable public init(channel: [String] = []) {
        self.channel = channel
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("UNSUBSCRIBE", channel)
    }
}

extension ValkeyConnection {
    /// Posts a message to a channel.
    ///
    /// - Documentation: [PUBLISH](https:/valkey.io/commands/publish)
    /// - Version: 2.0.0
    /// - Complexity: O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).
    /// - Categories: @pubsub, @fast
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the number of clients that received the message. Note that in a Valkey Cluster, only clients that are connected to the same node as the publishing client are included in the count.
    @inlinable
    public func publish<Channel: RESPStringRenderable, Message: RESPStringRenderable>(channel: Channel, message: Message) async throws -> Int {
        try await send(command: PUBLISH(channel: channel, message: message))
    }

    /// Returns the active channels.
    ///
    /// - Documentation: [PUBSUB CHANNELS](https:/valkey.io/commands/pubsub-channels)
    /// - Version: 2.8.0
    /// - Complexity: O(N) where N is the number of active channels, and assuming constant time pattern matching (relatively short channels and patterns)
    /// - Categories: @pubsub, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): a list of active channels, optionally matching the specified pattern.
    @inlinable
    public func pubsubChannels(pattern: String? = nil) async throws -> RESPToken.Array {
        try await send(command: PUBSUB.CHANNELS(pattern: pattern))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [PUBSUB HELP](https:/valkey.io/commands/pubsub-help)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func pubsubHelp() async throws -> RESPToken.Array {
        try await send(command: PUBSUB.HELP())
    }

    /// Returns a count of unique pattern subscriptions.
    ///
    /// - Documentation: [PUBSUB NUMPAT](https:/valkey.io/commands/pubsub-numpat)
    /// - Version: 2.8.0
    /// - Complexity: O(1)
    /// - Categories: @pubsub, @slow
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the number of patterns all the clients are subscribed to.
    @inlinable
    public func pubsubNumpat() async throws -> Int {
        try await send(command: PUBSUB.NUMPAT())
    }

    /// Returns a count of subscribers to channels.
    ///
    /// - Documentation: [PUBSUB NUMSUB](https:/valkey.io/commands/pubsub-numsub)
    /// - Version: 2.8.0
    /// - Complexity: O(N) for the NUMSUB subcommand, where N is the number of requested channels
    /// - Categories: @pubsub, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): the number of subscribers per channel, each even element (including the 0th) is channel name, each odd element is the number of subscribers
    @inlinable
    public func pubsubNumsub(channel: [String] = []) async throws -> RESPToken.Array {
        try await send(command: PUBSUB.NUMSUB(channel: channel))
    }

    /// Returns the active shard channels.
    ///
    /// - Documentation: [PUBSUB SHARDCHANNELS](https:/valkey.io/commands/pubsub-shardchannels)
    /// - Version: 7.0.0
    /// - Complexity: O(N) where N is the number of active shard channels, and assuming constant time pattern matching (relatively short shard channels).
    /// - Categories: @pubsub, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): a list of active channels, optionally matching the specified pattern.
    @inlinable
    public func pubsubShardchannels(pattern: String? = nil) async throws -> RESPToken.Array {
        try await send(command: PUBSUB.SHARDCHANNELS(pattern: pattern))
    }

    /// Returns the count of subscribers of shard channels.
    ///
    /// - Documentation: [PUBSUB SHARDNUMSUB](https:/valkey.io/commands/pubsub-shardnumsub)
    /// - Version: 7.0.0
    /// - Complexity: O(N) for the SHARDNUMSUB subcommand, where N is the number of requested shard channels
    /// - Categories: @pubsub, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): the number of subscribers per shard channel, each even element (including the 0th) is channel name, each odd element is the number of subscribers.
    @inlinable
    public func pubsubShardnumsub(shardchannel: [String] = []) async throws -> RESPToken.Array {
        try await send(command: PUBSUB.SHARDNUMSUB(shardchannel: shardchannel))
    }

    /// Post a message to a shard channel
    ///
    /// - Documentation: [SPUBLISH](https:/valkey.io/commands/spublish)
    /// - Version: 7.0.0
    /// - Complexity: O(N) where N is the number of clients subscribed to the receiving shard channel.
    /// - Categories: @pubsub, @fast
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the number of clients that received the message. Note that in a Valkey Cluster, only clients that are connected to the same node as the publishing client are included in the count
    @inlinable
    public func spublish<Shardchannel: RESPStringRenderable, Message: RESPStringRenderable>(shardchannel: Shardchannel, message: Message) async throws -> Int {
        try await send(command: SPUBLISH(shardchannel: shardchannel, message: message))
    }

}
