//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-valkey open source project
//
// Copyright (c) 2025 Apple Inc. and the swift-valkey project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-valkey project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// A container for consumer groups commands.
public enum XGROUP {
    /// Creates a consumer group.
    public struct CREATE: RESPCommand {
        public enum IdSelector: RESPRenderable, Sendable {
            case id(String)
            case newId

            public var respEntries: Int {
                switch self {
                case .id(let id): id.respEntries
                case .newId: "$".respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout RESPCommandEncoder) {
                switch self {
                case .id(let id): id.encode(into: &commandEncoder)
                case .newId: "$".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = RESPToken

        public var key: RESPKey
        public var group: String
        public var idSelector: IdSelector
        public var mkstream: Bool = false
        public var entriesRead: Int? = nil

        @inlinable public init(key: RESPKey, group: String, idSelector: IdSelector, mkstream: Bool = false, entriesRead: Int? = nil) {
            self.key = key
            self.group = group
            self.idSelector = idSelector
            self.mkstream = mkstream
            self.entriesRead = entriesRead
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "CREATE", key, group, idSelector, RESPPureToken("MKSTREAM", mkstream), RESPWithToken("ENTRIESREAD", entriesRead))
        }
    }

    /// Creates a consumer in a consumer group.
    public struct CREATECONSUMER: RESPCommand {
        public typealias Response = Int

        public var key: RESPKey
        public var group: String
        public var consumer: String

        @inlinable public init(key: RESPKey, group: String, consumer: String) {
            self.key = key
            self.group = group
            self.consumer = consumer
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "CREATECONSUMER", key, group, consumer)
        }
    }

    /// Deletes a consumer from a consumer group.
    public struct DELCONSUMER: RESPCommand {
        public typealias Response = Int

        public var key: RESPKey
        public var group: String
        public var consumer: String

        @inlinable public init(key: RESPKey, group: String, consumer: String) {
            self.key = key
            self.group = group
            self.consumer = consumer
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "DELCONSUMER", key, group, consumer)
        }
    }

    /// Destroys a consumer group.
    public struct DESTROY: RESPCommand {
        public typealias Response = Int

        public var key: RESPKey
        public var group: String

        @inlinable public init(key: RESPKey, group: String) {
            self.key = key
            self.group = group
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "DESTROY", key, group)
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "HELP")
        }
    }

    /// Sets the last-delivered ID of a consumer group.
    public struct SETID: RESPCommand {
        public enum IdSelector: RESPRenderable, Sendable {
            case id(String)
            case newId

            public var respEntries: Int {
                switch self {
                case .id(let id): id.respEntries
                case .newId: "$".respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout RESPCommandEncoder) {
                switch self {
                case .id(let id): id.encode(into: &commandEncoder)
                case .newId: "$".encode(into: &commandEncoder)
                }
            }
        }
        public typealias Response = RESPToken

        public var key: RESPKey
        public var group: String
        public var idSelector: IdSelector
        public var entriesread: Int? = nil

        @inlinable public init(key: RESPKey, group: String, idSelector: IdSelector, entriesread: Int? = nil) {
            self.key = key
            self.group = group
            self.idSelector = idSelector
            self.entriesread = entriesread
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "SETID", key, group, idSelector, RESPWithToken("ENTRIESREAD", entriesread))
        }
    }

}

/// A container for stream introspection commands.
public enum XINFO {
    /// Returns a list of the consumers in a consumer group.
    public struct CONSUMERS: RESPCommand {
        public typealias Response = [RESPToken]

        public var key: RESPKey
        public var group: String

        @inlinable public init(key: RESPKey, group: String) {
            self.key = key
            self.group = group
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "CONSUMERS", key, group)
        }
    }

    /// Returns a list of the consumer groups of a stream.
    public struct GROUPS: RESPCommand {
        public typealias Response = [RESPToken]

        public var key: RESPKey

        @inlinable public init(key: RESPKey) {
            self.key = key
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "GROUPS", key)
        }
    }

    /// Returns helpful text about the different subcommands.
    public struct HELP: RESPCommand {
        public typealias Response = [RESPToken]


        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "HELP")
        }
    }

    /// Returns information about a stream.
    public struct STREAM: RESPCommand {
        public struct FullBlock: RESPRenderable, Sendable {
            @usableFromInline let full: Bool
            @usableFromInline let count: Int?


            @inlinable public init(full: Bool = false, count: Int? = nil) {
                self.full = full
                self.count = count
            }

            @inlinable
            public var respEntries: Int {
                "FULL".respEntries + RESPWithToken("COUNT", count).respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout RESPCommandEncoder) {
                "FULL".encode(into: &commandEncoder)
                RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            }
        }
        public typealias Response = [String: RESPToken]

        public var key: RESPKey
        public var fullBlock: FullBlock? = nil

        @inlinable public init(key: RESPKey, fullBlock: FullBlock? = nil) {
            self.key = key
            self.fullBlock = fullBlock
        }

        @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "STREAM", key, fullBlock)
        }
    }

}

/// Returns the number of messages that were successfully acknowledged by the consumer group member of a stream.
public struct XACK: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey
    public var group: String
    public var id: [String]

    @inlinable public init(key: RESPKey, group: String, id: [String]) {
        self.key = key
        self.group = group
        self.id = id
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XACK", key, group, id)
    }
}

/// Appends a new message to a stream. Creates the key if it doesn't exist.
public struct XADD: RESPCommand {
    public enum TrimStrategy: RESPRenderable, Sendable {
        case maxlen
        case minid

        public var respEntries: Int {
            switch self {
            case .maxlen: "MAXLEN".respEntries
            case .minid: "MINID".respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            switch self {
            case .maxlen: "MAXLEN".encode(into: &commandEncoder)
            case .minid: "MINID".encode(into: &commandEncoder)
            }
        }
    }
    public enum TrimOperator: RESPRenderable, Sendable {
        case equal
        case approximately

        public var respEntries: Int {
            switch self {
            case .equal: "=".respEntries
            case .approximately: "~".respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            switch self {
            case .equal: "=".encode(into: &commandEncoder)
            case .approximately: "~".encode(into: &commandEncoder)
            }
        }
    }
    public struct Trim: RESPRenderable, Sendable {
        @usableFromInline let strategy: TrimStrategy
        @usableFromInline let `operator`: TrimOperator?
        @usableFromInline let threshold: String
        @usableFromInline let count: Int?


        @inlinable public init(strategy: TrimStrategy, `operator`: TrimOperator? = nil, threshold: String, count: Int? = nil) {
            self.strategy = strategy
            self.`operator` = `operator`
            self.threshold = threshold
            self.count = count
        }

        @inlinable
        public var respEntries: Int {
            strategy.respEntries + `operator`.respEntries + threshold.respEntries + RESPWithToken("LIMIT", count).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            strategy.encode(into: &commandEncoder)
            `operator`.encode(into: &commandEncoder)
            threshold.encode(into: &commandEncoder)
            RESPWithToken("LIMIT", count).encode(into: &commandEncoder)
        }
    }
    public enum IdSelector: RESPRenderable, Sendable {
        case autoId
        case id(String)

        public var respEntries: Int {
            switch self {
            case .autoId: "*".respEntries
            case .id(let id): id.respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            switch self {
            case .autoId: "*".encode(into: &commandEncoder)
            case .id(let id): id.encode(into: &commandEncoder)
            }
        }
    }
    public struct Data: RESPRenderable, Sendable {
        @usableFromInline let field: String
        @usableFromInline let value: String


        @inlinable public init(field: String, value: String) {
            self.field = field
            self.value = value
        }

        @inlinable
        public var respEntries: Int {
            field.respEntries + value.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            field.encode(into: &commandEncoder)
            value.encode(into: &commandEncoder)
        }
    }
    public typealias Response = String?

    public var key: RESPKey
    public var nomkstream: Bool = false
    public var trim: Trim? = nil
    public var idSelector: IdSelector
    public var data: [Data]

    @inlinable public init(key: RESPKey, nomkstream: Bool = false, trim: Trim? = nil, idSelector: IdSelector, data: [Data]) {
        self.key = key
        self.nomkstream = nomkstream
        self.trim = trim
        self.idSelector = idSelector
        self.data = data
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XADD", key, RESPPureToken("NOMKSTREAM", nomkstream), trim, idSelector, data)
    }
}

/// Changes, or acquires, ownership of messages in a consumer group, as if the messages were delivered to as consumer group member.
public struct XAUTOCLAIM: RESPCommand {
    public typealias Response = [RESPToken]

    public var key: RESPKey
    public var group: String
    public var consumer: String
    public var minIdleTime: String
    public var start: String
    public var count: Int? = nil
    public var justid: Bool = false

    @inlinable public init(key: RESPKey, group: String, consumer: String, minIdleTime: String, start: String, count: Int? = nil, justid: Bool = false) {
        self.key = key
        self.group = group
        self.consumer = consumer
        self.minIdleTime = minIdleTime
        self.start = start
        self.count = count
        self.justid = justid
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XAUTOCLAIM", key, group, consumer, minIdleTime, start, RESPWithToken("COUNT", count), RESPPureToken("JUSTID", justid))
    }
}

/// Changes, or acquires, ownership of a message in a consumer group, as if the message was delivered a consumer group member.
public struct XCLAIM: RESPCommand {
    public typealias Response = [RESPToken]

    public var key: RESPKey
    public var group: String
    public var consumer: String
    public var minIdleTime: String
    public var id: [String]
    public var ms: Int? = nil
    public var unixTimeMilliseconds: Date? = nil
    public var count: Int? = nil
    public var force: Bool = false
    public var justid: Bool = false
    public var lastid: String? = nil

    @inlinable public init(key: RESPKey, group: String, consumer: String, minIdleTime: String, id: [String], ms: Int? = nil, unixTimeMilliseconds: Date? = nil, count: Int? = nil, force: Bool = false, justid: Bool = false, lastid: String? = nil) {
        self.key = key
        self.group = group
        self.consumer = consumer
        self.minIdleTime = minIdleTime
        self.id = id
        self.ms = ms
        self.unixTimeMilliseconds = unixTimeMilliseconds
        self.count = count
        self.force = force
        self.justid = justid
        self.lastid = lastid
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XCLAIM", key, group, consumer, minIdleTime, id, RESPWithToken("IDLE", ms), RESPWithToken("TIME", unixTimeMilliseconds.map { Int($0.timeIntervalSince1970 * 1000) }), RESPWithToken("RETRYCOUNT", count), RESPPureToken("FORCE", force), RESPPureToken("JUSTID", justid), RESPWithToken("LASTID", lastid))
    }
}

/// Returns the number of messages after removing them from a stream.
public struct XDEL: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey
    public var id: [String]

    @inlinable public init(key: RESPKey, id: [String]) {
        self.key = key
        self.id = id
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XDEL", key, id)
    }
}

/// Return the number of messages in a stream.
public struct XLEN: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey

    @inlinable public init(key: RESPKey) {
        self.key = key
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XLEN", key)
    }
}

/// Returns the information and entries from a stream consumer group's pending entries list.
public struct XPENDING: RESPCommand {
    public struct Filters: RESPRenderable, Sendable {
        @usableFromInline let minIdleTime: Int?
        @usableFromInline let start: String
        @usableFromInline let end: String
        @usableFromInline let count: Int
        @usableFromInline let consumer: String?


        @inlinable public init(minIdleTime: Int? = nil, start: String, end: String, count: Int, consumer: String? = nil) {
            self.minIdleTime = minIdleTime
            self.start = start
            self.end = end
            self.count = count
            self.consumer = consumer
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("IDLE", minIdleTime).respEntries + start.respEntries + end.respEntries + count.respEntries + consumer.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            RESPWithToken("IDLE", minIdleTime).encode(into: &commandEncoder)
            start.encode(into: &commandEncoder)
            end.encode(into: &commandEncoder)
            count.encode(into: &commandEncoder)
            consumer.encode(into: &commandEncoder)
        }
    }
    public typealias Response = [RESPToken]

    public var key: RESPKey
    public var group: String
    public var filters: Filters? = nil

    @inlinable public init(key: RESPKey, group: String, filters: Filters? = nil) {
        self.key = key
        self.group = group
        self.filters = filters
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XPENDING", key, group, filters)
    }
}

/// Returns the messages from a stream within a range of IDs.
public struct XRANGE: RESPCommand {
    public typealias Response = [RESPToken]

    public var key: RESPKey
    public var start: String
    public var end: String
    public var count: Int? = nil

    @inlinable public init(key: RESPKey, start: String, end: String, count: Int? = nil) {
        self.key = key
        self.start = start
        self.end = end
        self.count = count
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XRANGE", key, start, end, RESPWithToken("COUNT", count))
    }
}

/// Returns messages from multiple streams with IDs greater than the ones requested. Blocks until a message is available otherwise.
public struct XREAD: RESPCommand {
    public struct Streams: RESPRenderable, Sendable {
        @usableFromInline let key: [RESPKey]
        @usableFromInline let id: [String]


        @inlinable public init(key: [RESPKey], id: [String]) {
            self.key = key
            self.id = id
        }

        @inlinable
        public var respEntries: Int {
            key.respEntries + id.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            key.encode(into: &commandEncoder)
            id.encode(into: &commandEncoder)
        }
    }
    public typealias Response = [String: RESPToken]?

    public var count: Int? = nil
    public var milliseconds: Int? = nil
    public var streams: Streams

    @inlinable public init(count: Int? = nil, milliseconds: Int? = nil, streams: Streams) {
        self.count = count
        self.milliseconds = milliseconds
        self.streams = streams
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XREAD", RESPWithToken("COUNT", count), RESPWithToken("BLOCK", milliseconds), RESPWithToken("STREAMS", streams))
    }
}

/// Returns new or historical messages from a stream for a consumer in a group. Blocks until a message is available otherwise.
public struct XREADGROUP: RESPCommand {
    public struct GroupBlock: RESPRenderable, Sendable {
        @usableFromInline let group: String
        @usableFromInline let consumer: String


        @inlinable public init(group: String, consumer: String) {
            self.group = group
            self.consumer = consumer
        }

        @inlinable
        public var respEntries: Int {
            group.respEntries + consumer.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            group.encode(into: &commandEncoder)
            consumer.encode(into: &commandEncoder)
        }
    }
    public struct Streams: RESPRenderable, Sendable {
        @usableFromInline let key: [RESPKey]
        @usableFromInline let id: [String]


        @inlinable public init(key: [RESPKey], id: [String]) {
            self.key = key
            self.id = id
        }

        @inlinable
        public var respEntries: Int {
            key.respEntries + id.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            key.encode(into: &commandEncoder)
            id.encode(into: &commandEncoder)
        }
    }
    public typealias Response = [String: RESPToken]?

    public var groupBlock: GroupBlock
    public var count: Int? = nil
    public var milliseconds: Int? = nil
    public var noack: Bool = false
    public var streams: Streams

    @inlinable public init(groupBlock: GroupBlock, count: Int? = nil, milliseconds: Int? = nil, noack: Bool = false, streams: Streams) {
        self.groupBlock = groupBlock
        self.count = count
        self.milliseconds = milliseconds
        self.noack = noack
        self.streams = streams
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XREADGROUP", RESPWithToken("GROUP", groupBlock), RESPWithToken("COUNT", count), RESPWithToken("BLOCK", milliseconds), RESPPureToken("NOACK", noack), RESPWithToken("STREAMS", streams))
    }
}

/// Returns the messages from a stream within a range of IDs in reverse order.
public struct XREVRANGE: RESPCommand {
    public typealias Response = [RESPToken]

    public var key: RESPKey
    public var end: String
    public var start: String
    public var count: Int? = nil

    @inlinable public init(key: RESPKey, end: String, start: String, count: Int? = nil) {
        self.key = key
        self.end = end
        self.start = start
        self.count = count
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XREVRANGE", key, end, start, RESPWithToken("COUNT", count))
    }
}

/// An internal command for replicating stream values.
public struct XSETID: RESPCommand {
    public typealias Response = RESPToken

    public var key: RESPKey
    public var lastId: String
    public var entriesAdded: Int? = nil
    public var maxDeletedId: String? = nil

    @inlinable public init(key: RESPKey, lastId: String, entriesAdded: Int? = nil, maxDeletedId: String? = nil) {
        self.key = key
        self.lastId = lastId
        self.entriesAdded = entriesAdded
        self.maxDeletedId = maxDeletedId
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XSETID", key, lastId, RESPWithToken("ENTRIESADDED", entriesAdded), RESPWithToken("MAXDELETEDID", maxDeletedId))
    }
}

/// Deletes messages from the beginning of a stream.
public struct XTRIM: RESPCommand {
    public enum TrimStrategy: RESPRenderable, Sendable {
        case maxlen
        case minid

        public var respEntries: Int {
            switch self {
            case .maxlen: "MAXLEN".respEntries
            case .minid: "MINID".respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            switch self {
            case .maxlen: "MAXLEN".encode(into: &commandEncoder)
            case .minid: "MINID".encode(into: &commandEncoder)
            }
        }
    }
    public enum TrimOperator: RESPRenderable, Sendable {
        case equal
        case approximately

        public var respEntries: Int {
            switch self {
            case .equal: "=".respEntries
            case .approximately: "~".respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            switch self {
            case .equal: "=".encode(into: &commandEncoder)
            case .approximately: "~".encode(into: &commandEncoder)
            }
        }
    }
    public struct Trim: RESPRenderable, Sendable {
        @usableFromInline let strategy: TrimStrategy
        @usableFromInline let `operator`: TrimOperator?
        @usableFromInline let threshold: String
        @usableFromInline let count: Int?


        @inlinable public init(strategy: TrimStrategy, `operator`: TrimOperator? = nil, threshold: String, count: Int? = nil) {
            self.strategy = strategy
            self.`operator` = `operator`
            self.threshold = threshold
            self.count = count
        }

        @inlinable
        public var respEntries: Int {
            strategy.respEntries + `operator`.respEntries + threshold.respEntries + RESPWithToken("LIMIT", count).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) {
            strategy.encode(into: &commandEncoder)
            `operator`.encode(into: &commandEncoder)
            threshold.encode(into: &commandEncoder)
            RESPWithToken("LIMIT", count).encode(into: &commandEncoder)
        }
    }
    public typealias Response = Int

    public var key: RESPKey
    public var trim: Trim

    @inlinable public init(key: RESPKey, trim: Trim) {
        self.key = key
        self.trim = trim
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("XTRIM", key, trim)
    }
}


extension ValkeyConnection {
    /// Returns the number of messages that were successfully acknowledged by the consumer group member of a stream.
    ///
    /// - Documentation: [XACK](https:/valkey.io/commands/xack)
    /// - Version: 5.0.0
    /// - Complexity: O(1) for each message ID processed.
    /// - Categories: @write, @stream, @fast
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have already been acknowledged), and XACK will not count them as successfully acknowledged.
    @inlinable
    public func xack(key: RESPKey, group: String, id: [String]) async throws -> Int {
        try await send(command: XACK(key: key, group: group, id: id))
    }

    /// Appends a new message to a stream. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [XADD](https:/valkey.io/commands/xadd)
    /// - Version: 5.0.0
    /// - Complexity: O(1) when adding a new entry, O(N) when trimming where N being the number of entries evicted.
    /// - Categories: @write, @stream, @fast
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/valkey.io/topics/protocol/#bulk-strings): The ID of the added entry. The ID is the one automatically generated if an asterisk (`*`) is passed as the _id_ argument, otherwise the command just returns the same ID specified by the user during insertion.
    ///     * [Null](https:/valkey.io/topics/protocol/#nulls): if the NOMKSTREAM option is given and the key doesn't exist.
    @inlinable
    public func xadd(key: RESPKey, nomkstream: Bool = false, trim: XADD.Trim? = nil, idSelector: XADD.IdSelector, data: [XADD.Data]) async throws -> String? {
        try await send(command: XADD(key: key, nomkstream: nomkstream, trim: trim, idSelector: idSelector, data: data))
    }

    /// Changes, or acquires, ownership of messages in a consumer group, as if the messages were delivered to as consumer group member.
    ///
    /// - Documentation: [XAUTOCLAIM](https:/valkey.io/commands/xautoclaim)
    /// - Version: 6.2.0
    /// - Complexity: O(1) if COUNT is small.
    /// - Categories: @write, @stream, @fast
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays), specifically, an array with three elements:
    ///     1. A stream ID to be used as the _start_ argument for the next call to XAUTOCLAIM.
    ///     2. An [Array](https:/valkey.io/topics/protocol/#arrays) containing all the successfully claimed messages in the same format as `XRANGE`.
    ///     3. An [Array](https:/valkey.io/topics/protocol/#arrays) containing message IDs that no longer exist in the stream, and were deleted from the PEL in which they were found.
    @inlinable
    public func xautoclaim(key: RESPKey, group: String, consumer: String, minIdleTime: String, start: String, count: Int? = nil, justid: Bool = false) async throws -> [RESPToken] {
        try await send(command: XAUTOCLAIM(key: key, group: group, consumer: consumer, minIdleTime: minIdleTime, start: start, count: count, justid: justid))
    }

    /// Changes, or acquires, ownership of a message in a consumer group, as if the message was delivered a consumer group member.
    ///
    /// - Documentation: [XCLAIM](https:/valkey.io/commands/xclaim)
    /// - Version: 5.0.0
    /// - Complexity: O(log N) with N being the number of messages in the PEL of the consumer group.
    /// - Categories: @write, @stream, @fast
    /// - Returns: Any of the following:
    ///     * [Array](https:/valkey.io/topics/protocol/#arrays): when the _JUSTID_ option is specified, an array of IDs of messages successfully claimed.
    ///     * [Array](https:/valkey.io/topics/protocol/#arrays): an array of stream entries, each of which contains an array of two elements, the entry ID and the entry data itself.
    @inlinable
    public func xclaim(key: RESPKey, group: String, consumer: String, minIdleTime: String, id: [String], ms: Int? = nil, unixTimeMilliseconds: Date? = nil, count: Int? = nil, force: Bool = false, justid: Bool = false, lastid: String? = nil) async throws -> [RESPToken] {
        try await send(command: XCLAIM(key: key, group: group, consumer: consumer, minIdleTime: minIdleTime, id: id, ms: ms, unixTimeMilliseconds: unixTimeMilliseconds, count: count, force: force, justid: justid, lastid: lastid))
    }

    /// Returns the number of messages after removing them from a stream.
    ///
    /// - Documentation: [XDEL](https:/valkey.io/commands/xdel)
    /// - Version: 5.0.0
    /// - Complexity: O(1) for each single item to delete in the stream, regardless of the stream size.
    /// - Categories: @write, @stream, @fast
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the number of entries that were deleted.
    @inlinable
    public func xdel(key: RESPKey, id: [String]) async throws -> Int {
        try await send(command: XDEL(key: key, id: id))
    }

    /// Creates a consumer group.
    ///
    /// - Documentation: [XGROUP CREATE](https:/valkey.io/commands/xgroup-create)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Simple string](https:/valkey.io/topics/protocol/#simple-strings): `OK`.
    @inlinable
    public func xgroupCreate(key: RESPKey, group: String, idSelector: XGROUP.CREATE.IdSelector, mkstream: Bool = false, entriesRead: Int? = nil) async throws -> RESPToken {
        try await send(command: XGROUP.CREATE(key: key, group: group, idSelector: idSelector, mkstream: mkstream, entriesRead: entriesRead))
    }

    /// Creates a consumer in a consumer group.
    ///
    /// - Documentation: [XGROUP CREATECONSUMER](https:/valkey.io/commands/xgroup-createconsumer)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the number of created consumers, either 0 or 1.
    @inlinable
    public func xgroupCreateconsumer(key: RESPKey, group: String, consumer: String) async throws -> Int {
        try await send(command: XGROUP.CREATECONSUMER(key: key, group: group, consumer: consumer))
    }

    /// Deletes a consumer from a consumer group.
    ///
    /// - Documentation: [XGROUP DELCONSUMER](https:/valkey.io/commands/xgroup-delconsumer)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the number of pending messages the consumer had before it was deleted.
    @inlinable
    public func xgroupDelconsumer(key: RESPKey, group: String, consumer: String) async throws -> Int {
        try await send(command: XGROUP.DELCONSUMER(key: key, group: group, consumer: consumer))
    }

    /// Destroys a consumer group.
    ///
    /// - Documentation: [XGROUP DESTROY](https:/valkey.io/commands/xgroup-destroy)
    /// - Version: 5.0.0
    /// - Complexity: O(N) where N is the number of entries in the group's pending entries list (PEL).
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the number of destroyed consumer groups, either 0 or 1.
    @inlinable
    public func xgroupDestroy(key: RESPKey, group: String) async throws -> Int {
        try await send(command: XGROUP.DESTROY(key: key, group: group))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [XGROUP HELP](https:/valkey.io/commands/xgroup-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @stream, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func xgroupHelp() async throws -> [RESPToken] {
        try await send(command: XGROUP.HELP())
    }

    /// Sets the last-delivered ID of a consumer group.
    ///
    /// - Documentation: [XGROUP SETID](https:/valkey.io/commands/xgroup-setid)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Simple string](https:/valkey.io/topics/protocol/#simple-strings): `OK`.
    @inlinable
    public func xgroupSetid(key: RESPKey, group: String, idSelector: XGROUP.SETID.IdSelector, entriesread: Int? = nil) async throws -> RESPToken {
        try await send(command: XGROUP.SETID(key: key, group: group, idSelector: idSelector, entriesread: entriesread))
    }

    /// Returns a list of the consumers in a consumer group.
    ///
    /// - Documentation: [XINFO CONSUMERS](https:/valkey.io/commands/xinfo-consumers)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): a list of consumers and their attributes.
    @inlinable
    public func xinfoConsumers(key: RESPKey, group: String) async throws -> [RESPToken] {
        try await send(command: XINFO.CONSUMERS(key: key, group: group))
    }

    /// Returns a list of the consumer groups of a stream.
    ///
    /// - Documentation: [XINFO GROUPS](https:/valkey.io/commands/xinfo-groups)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): a list of consumer groups.
    @inlinable
    public func xinfoGroups(key: RESPKey) async throws -> [RESPToken] {
        try await send(command: XINFO.GROUPS(key: key))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [XINFO HELP](https:/valkey.io/commands/xinfo-help)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @stream, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): a list of sub-commands and their descriptions.
    @inlinable
    public func xinfoHelp() async throws -> [RESPToken] {
        try await send(command: XINFO.HELP())
    }

    /// Returns information about a stream.
    ///
    /// - Documentation: [XINFO STREAM](https:/valkey.io/commands/xinfo-stream)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @slow
    /// - Returns: One of the following:
    ///     * [Map](https:/valkey.io/topics/protocol/#maps): when the _FULL_ argument was not given, a list of information about a stream in summary form.
    ///     * [Map](https:/valkey.io/topics/protocol/#maps): when the _FULL_ argument was given, a list of information about a stream in extended form.
    @inlinable
    public func xinfoStream(key: RESPKey, fullBlock: XINFO.STREAM.FullBlock? = nil) async throws -> [String: RESPToken] {
        try await send(command: XINFO.STREAM(key: key, fullBlock: fullBlock))
    }

    /// Return the number of messages in a stream.
    ///
    /// - Documentation: [XLEN](https:/valkey.io/commands/xlen)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @stream, @fast
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): the number of entries of the stream at _key_.
    @inlinable
    public func xlen(key: RESPKey) async throws -> Int {
        try await send(command: XLEN(key: key))
    }

    /// Returns the information and entries from a stream consumer group's pending entries list.
    ///
    /// - Documentation: [XPENDING](https:/valkey.io/commands/xpending)
    /// - Version: 5.0.0
    /// - Complexity: O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). O(M), where M is the total number of entries scanned when used with the IDLE filter. When the command returns just the summary and the list of consumers is small, it runs in O(1) time; otherwise, an additional O(N) time for iterating every consumer.
    /// - Categories: @read, @stream, @slow
    /// - Returns: * [Array](https:/valkey.io/topics/protocol/#arrays): different data depending on the way XPENDING is called, as explained on this page.
    @inlinable
    public func xpending(key: RESPKey, group: String, filters: XPENDING.Filters? = nil) async throws -> [RESPToken] {
        try await send(command: XPENDING(key: key, group: group, filters: filters))
    }

    /// Returns the messages from a stream within a range of IDs.
    ///
    /// - Documentation: [XRANGE](https:/valkey.io/commands/xrange)
    /// - Version: 5.0.0
    /// - Complexity: O(N) with N being the number of elements being returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
    /// - Categories: @read, @stream, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): a list of stream entries with IDs matching the specified range.
    @inlinable
    public func xrange(key: RESPKey, start: String, end: String, count: Int? = nil) async throws -> [RESPToken] {
        try await send(command: XRANGE(key: key, start: start, end: end, count: count))
    }

    /// Returns messages from multiple streams with IDs greater than the ones requested. Blocks until a message is available otherwise.
    ///
    /// - Documentation: [XREAD](https:/valkey.io/commands/xread)
    /// - Version: 5.0.0
    /// - Categories: @read, @stream, @slow, @blocking
    /// - Returns: One of the following:
    ///     * [Map](https:/valkey.io/topics/protocol/#maps): A map of key-value elements where each element is composed of the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by `XADD`.
    ///     * [Null](https:/valkey.io/topics/protocol/#nulls): if the _BLOCK_ option is given and a timeout occurs, or if there is no stream that can be served.
    @inlinable
    public func xread(count: Int? = nil, milliseconds: Int? = nil, streams: XREAD.Streams) async throws -> [String: RESPToken]? {
        try await send(command: XREAD(count: count, milliseconds: milliseconds, streams: streams))
    }

    /// Returns new or historical messages from a stream for a consumer in a group. Blocks until a message is available otherwise.
    ///
    /// - Documentation: [XREADGROUP](https:/valkey.io/commands/xreadgroup)
    /// - Version: 5.0.0
    /// - Complexity: For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data.
    /// - Categories: @write, @stream, @slow, @blocking
    /// - Returns: One of the following:
    ///     * [Map](https:/valkey.io/topics/protocol/#maps): A map of key-value elements where each element is composed of the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by `XADD`.
    ///     * [Null](https:/valkey.io/topics/protocol/#nulls): if the _BLOCK_ option is given and a timeout occurs, or if there is no stream that can be served.
    @inlinable
    public func xreadgroup(groupBlock: XREADGROUP.GroupBlock, count: Int? = nil, milliseconds: Int? = nil, noack: Bool = false, streams: XREADGROUP.Streams) async throws -> [String: RESPToken]? {
        try await send(command: XREADGROUP(groupBlock: groupBlock, count: count, milliseconds: milliseconds, noack: noack, streams: streams))
    }

    /// Returns the messages from a stream within a range of IDs in reverse order.
    ///
    /// - Documentation: [XREVRANGE](https:/valkey.io/commands/xrevrange)
    /// - Version: 5.0.0
    /// - Complexity: O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
    /// - Categories: @read, @stream, @slow
    /// - Returns: [Array](https:/valkey.io/topics/protocol/#arrays): The command returns the entries with IDs matching the specified range. The returned entries are complete, which means that the ID and all the fields they are composed of are returned. Moreover, the entries are returned with their fields and values in the same order as `XADD` added them.
    @inlinable
    public func xrevrange(key: RESPKey, end: String, start: String, count: Int? = nil) async throws -> [RESPToken] {
        try await send(command: XREVRANGE(key: key, end: end, start: start, count: count))
    }

    /// An internal command for replicating stream values.
    ///
    /// - Documentation: [XSETID](https:/valkey.io/commands/xsetid)
    /// - Version: 5.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @stream, @fast
    /// - Returns: [Simple string](https:/valkey.io/topics/protocol/#simple-strings): `OK`.
    @inlinable
    public func xsetid(key: RESPKey, lastId: String, entriesAdded: Int? = nil, maxDeletedId: String? = nil) async throws -> RESPToken {
        try await send(command: XSETID(key: key, lastId: lastId, entriesAdded: entriesAdded, maxDeletedId: maxDeletedId))
    }

    /// Deletes messages from the beginning of a stream.
    ///
    /// - Documentation: [XTRIM](https:/valkey.io/commands/xtrim)
    /// - Version: 5.0.0
    /// - Complexity: O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.
    /// - Categories: @write, @stream, @slow
    /// - Returns: [Integer](https:/valkey.io/topics/protocol/#integers): The number of entries deleted from the stream.
    @inlinable
    public func xtrim(key: RESPKey, trim: XTRIM.Trim) async throws -> Int {
        try await send(command: XTRIM(key: key, trim: trim))
    }

}
