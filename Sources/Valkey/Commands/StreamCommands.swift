//
// This source file is part of the valkey-swift project
// Copyright (c) 2025-2026 the valkey-swift project authors
//
// See LICENSE.txt for license information
// SPDX-License-Identifier: Apache-2.0
//
// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// A container for consumer groups commands.
@_documentation(visibility: internal)
public enum XGROUP {
    /// Creates a consumer group.
    @_documentation(visibility: internal)
    public struct CREATE<Group: RESPStringRenderable>: ValkeyCommand {
        public enum IdSelector: RESPRenderable, Sendable, Hashable {
            case id(String)
            case newId

            @inlinable
            public var respEntries: Int {
                switch self {
                case .id(let id): id.respEntries
                case .newId: "$".respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .id(let id): id.encode(into: &commandEncoder)
                case .newId: "$".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "XGROUP CREATE" }

        public var key: ValkeyKey
        public var group: Group
        public var idSelector: IdSelector
        public var mkstream: Bool
        public var entriesread: Int?

        @inlinable public init(_ key: ValkeyKey, group: Group, idSelector: IdSelector, mkstream: Bool = false, entriesread: Int? = nil) {
            self.key = key
            self.group = group
            self.idSelector = idSelector
            self.mkstream = mkstream
            self.entriesread = entriesread
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "XGROUP",
                "CREATE",
                key,
                RESPRenderableBulkString(group),
                idSelector,
                RESPPureToken("MKSTREAM", mkstream),
                RESPWithToken("ENTRIESREAD", entriesread)
            )
        }
    }

    /// Creates a consumer in a consumer group.
    @_documentation(visibility: internal)
    public struct CREATECONSUMER<Group: RESPStringRenderable, Consumer: RESPStringRenderable>: ValkeyCommand {
        public typealias Response = Int

        @inlinable public static var name: String { "XGROUP CREATECONSUMER" }

        public var key: ValkeyKey
        public var group: Group
        public var consumer: Consumer

        @inlinable public init(_ key: ValkeyKey, group: Group, consumer: Consumer) {
            self.key = key
            self.group = group
            self.consumer = consumer
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "CREATECONSUMER", key, RESPRenderableBulkString(group), RESPRenderableBulkString(consumer))
        }
    }

    /// Deletes a consumer from a consumer group.
    @_documentation(visibility: internal)
    public struct DELCONSUMER<Group: RESPStringRenderable, Consumer: RESPStringRenderable>: ValkeyCommand {
        public typealias Response = Int

        @inlinable public static var name: String { "XGROUP DELCONSUMER" }

        public var key: ValkeyKey
        public var group: Group
        public var consumer: Consumer

        @inlinable public init(_ key: ValkeyKey, group: Group, consumer: Consumer) {
            self.key = key
            self.group = group
            self.consumer = consumer
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "DELCONSUMER", key, RESPRenderableBulkString(group), RESPRenderableBulkString(consumer))
        }
    }

    /// Destroys a consumer group.
    @_documentation(visibility: internal)
    public struct DESTROY<Group: RESPStringRenderable>: ValkeyCommand {
        public typealias Response = Int

        @inlinable public static var name: String { "XGROUP DESTROY" }

        public var key: ValkeyKey
        public var group: Group

        @inlinable public init(_ key: ValkeyKey, group: Group) {
            self.key = key
            self.group = group
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "DESTROY", key, RESPRenderableBulkString(group))
        }
    }

    /// Returns helpful text about the different subcommands.
    @_documentation(visibility: internal)
    public struct HELP: ValkeyCommand {
        public typealias Response = RESPToken.Array

        @inlinable public static var name: String { "XGROUP HELP" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "HELP")
        }
    }

    /// Sets the last-delivered ID of a consumer group.
    @_documentation(visibility: internal)
    public struct SETID<Group: RESPStringRenderable>: ValkeyCommand {
        public enum IdSelector: RESPRenderable, Sendable, Hashable {
            case id(String)
            case newId

            @inlinable
            public var respEntries: Int {
                switch self {
                case .id(let id): id.respEntries
                case .newId: "$".respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .id(let id): id.encode(into: &commandEncoder)
                case .newId: "$".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "XGROUP SETID" }

        public var key: ValkeyKey
        public var group: Group
        public var idSelector: IdSelector
        public var entriesread: Int?

        @inlinable public init(_ key: ValkeyKey, group: Group, idSelector: IdSelector, entriesread: Int? = nil) {
            self.key = key
            self.group = group
            self.idSelector = idSelector
            self.entriesread = entriesread
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "SETID", key, RESPRenderableBulkString(group), idSelector, RESPWithToken("ENTRIESREAD", entriesread))
        }
    }

}

/// A container for stream introspection commands.
@_documentation(visibility: internal)
public enum XINFO {
    /// Returns a list of the consumers in a consumer group.
    @_documentation(visibility: internal)
    public struct CONSUMERS<Group: RESPStringRenderable>: ValkeyCommand {
        public typealias Response = [XINFO.Consumer]

        @inlinable public static var name: String { "XINFO CONSUMERS" }

        public var key: ValkeyKey
        public var group: Group

        @inlinable public init(_ key: ValkeyKey, group: Group) {
            self.key = key
            self.group = group
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        public var isReadOnly: Bool { true }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "CONSUMERS", key, RESPRenderableBulkString(group))
        }
    }

    /// Returns a list of the consumer groups of a stream.
    @_documentation(visibility: internal)
    public struct GROUPS: ValkeyCommand {
        @inlinable public static var name: String { "XINFO GROUPS" }

        public var key: ValkeyKey

        @inlinable public init(_ key: ValkeyKey) {
            self.key = key
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        public var isReadOnly: Bool { true }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "GROUPS", key)
        }
    }

    /// Returns helpful text about the different subcommands.
    @_documentation(visibility: internal)
    public struct HELP: ValkeyCommand {
        public typealias Response = RESPToken.Array

        @inlinable public static var name: String { "XINFO HELP" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "HELP")
        }
    }

    /// Returns information about a stream.
    @_documentation(visibility: internal)
    public struct STREAM: ValkeyCommand {
        public struct FullBlock: RESPRenderable, Sendable, Hashable {
            public var count: Int?

            @inlinable
            public init(count: Int? = nil) {
                self.count = count
            }

            @inlinable
            public var respEntries: Int {
                "FULL".respEntries + RESPWithToken("COUNT", count).respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "FULL".encode(into: &commandEncoder)
                RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            }
        }
        @inlinable public static var name: String { "XINFO STREAM" }

        public var key: ValkeyKey
        public var fullBlock: FullBlock?

        @inlinable public init(_ key: ValkeyKey, fullBlock: FullBlock? = nil) {
            self.key = key
            self.fullBlock = fullBlock
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        public var isReadOnly: Bool { true }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "STREAM", key, fullBlock)
        }
    }

}

/// Returns the number of messages that were successfully acknowledged by the consumer group member of a stream.
@_documentation(visibility: internal)
public struct XACK<Group: RESPStringRenderable, Id: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "XACK" }

    public var key: ValkeyKey
    public var group: Group
    public var ids: [Id]

    @inlinable public init(_ key: ValkeyKey, group: Group, ids: [Id]) {
        self.key = key
        self.group = group
        self.ids = ids
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XACK", key, RESPRenderableBulkString(group), ids.map { RESPRenderableBulkString($0) })
    }
}

/// Appends a new message to a stream. Creates the key if it doesn't exist.
@_documentation(visibility: internal)
public struct XADD<Field: RESPStringRenderable, Value: RESPStringRenderable>: ValkeyCommand {
    public enum TrimStrategy: RESPRenderable, Sendable, Hashable {
        case maxlen
        case minid

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .maxlen: "MAXLEN".encode(into: &commandEncoder)
            case .minid: "MINID".encode(into: &commandEncoder)
            }
        }
    }
    public enum TrimOperator: RESPRenderable, Sendable, Hashable {
        case equal
        case approximately

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .equal: "=".encode(into: &commandEncoder)
            case .approximately: "~".encode(into: &commandEncoder)
            }
        }
    }
    public struct Trim: RESPRenderable, Sendable, Hashable {
        public var strategy: TrimStrategy
        public var `operator`: TrimOperator?
        public var threshold: String
        public var count: Int?

        @inlinable
        public init(strategy: TrimStrategy, `operator`: TrimOperator? = nil, threshold: String, count: Int? = nil) {
            self.strategy = strategy
            self.`operator` = `operator`
            self.threshold = threshold
            self.count = count
        }

        @inlinable
        public var respEntries: Int {
            strategy.respEntries + `operator`.respEntries + threshold.respEntries + RESPWithToken("LIMIT", count).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            strategy.encode(into: &commandEncoder)
            `operator`.encode(into: &commandEncoder)
            threshold.encode(into: &commandEncoder)
            RESPWithToken("LIMIT", count).encode(into: &commandEncoder)
        }
    }
    public enum IdSelector: RESPRenderable, Sendable, Hashable {
        case autoId
        case id(String)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .autoId: "*".respEntries
            case .id(let id): id.respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .autoId: "*".encode(into: &commandEncoder)
            case .id(let id): id.encode(into: &commandEncoder)
            }
        }
    }
    public struct Data: RESPRenderable, Sendable, Hashable {
        public var field: Field
        public var value: Value

        @inlinable
        public init(field: Field, value: Value) {
            self.field = field
            self.value = value
        }

        @inlinable
        public var respEntries: Int {
            RESPRenderableBulkString(field).respEntries + RESPRenderableBulkString(value).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPRenderableBulkString(field).encode(into: &commandEncoder)
            RESPRenderableBulkString(value).encode(into: &commandEncoder)
        }
    }
    public typealias Response = RESPBulkString?

    @inlinable public static var name: String { "XADD" }

    public var key: ValkeyKey
    public var nomkstream: Bool
    public var trim: Trim?
    public var idSelector: IdSelector
    public var data: [Data]

    @inlinable public init(_ key: ValkeyKey, nomkstream: Bool = false, trim: Trim? = nil, idSelector: IdSelector, data: [Data]) {
        self.key = key
        self.nomkstream = nomkstream
        self.trim = trim
        self.idSelector = idSelector
        self.data = data
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XADD", key, RESPPureToken("NOMKSTREAM", nomkstream), trim, idSelector, data)
    }
}

/// Changes, or acquires, ownership of messages in a consumer group, as if the messages were delivered to as consumer group member.
@_documentation(visibility: internal)
public struct XAUTOCLAIM<Group: RESPStringRenderable, Consumer: RESPStringRenderable, MinIdleTime: RESPStringRenderable, Start: RESPStringRenderable>:
    ValkeyCommand
{
    @inlinable public static var name: String { "XAUTOCLAIM" }

    public var key: ValkeyKey
    public var group: Group
    public var consumer: Consumer
    public var minIdleTime: MinIdleTime
    public var start: Start
    public var count: Int?
    public var justid: Bool

    @inlinable public init(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer,
        minIdleTime: MinIdleTime,
        start: Start,
        count: Int? = nil,
        justid: Bool = false
    ) {
        self.key = key
        self.group = group
        self.consumer = consumer
        self.minIdleTime = minIdleTime
        self.start = start
        self.count = count
        self.justid = justid
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "XAUTOCLAIM",
            key,
            RESPRenderableBulkString(group),
            RESPRenderableBulkString(consumer),
            RESPRenderableBulkString(minIdleTime),
            RESPRenderableBulkString(start),
            RESPWithToken("COUNT", count),
            RESPPureToken("JUSTID", justid)
        )
    }
}

/// Changes, or acquires, ownership of a message in a consumer group, as if the message was delivered a consumer group member.
@_documentation(visibility: internal)
public struct XCLAIM<Group: RESPStringRenderable, Consumer: RESPStringRenderable, MinIdleTime: RESPStringRenderable, Id: RESPStringRenderable>:
    ValkeyCommand
{
    @inlinable public static var name: String { "XCLAIM" }

    public var key: ValkeyKey
    public var group: Group
    public var consumer: Consumer
    public var minIdleTime: MinIdleTime
    public var ids: [Id]
    public var ms: Int?
    public var unixTimeMilliseconds: Date?
    public var count: Int?
    public var force: Bool
    public var justid: Bool
    public var lastid: String?

    @inlinable public init(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer,
        minIdleTime: MinIdleTime,
        ids: [Id],
        ms: Int? = nil,
        unixTimeMilliseconds: Date? = nil,
        count: Int? = nil,
        force: Bool = false,
        justid: Bool = false,
        lastid: String? = nil
    ) {
        self.key = key
        self.group = group
        self.consumer = consumer
        self.minIdleTime = minIdleTime
        self.ids = ids
        self.ms = ms
        self.unixTimeMilliseconds = unixTimeMilliseconds
        self.count = count
        self.force = force
        self.justid = justid
        self.lastid = lastid
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "XCLAIM",
            key,
            RESPRenderableBulkString(group),
            RESPRenderableBulkString(consumer),
            RESPRenderableBulkString(minIdleTime),
            ids.map { RESPRenderableBulkString($0) },
            RESPWithToken("IDLE", ms),
            RESPWithToken("TIME", unixTimeMilliseconds.map { Int($0.timeIntervalSince1970 * 1000) }),
            RESPWithToken("RETRYCOUNT", count),
            RESPPureToken("FORCE", force),
            RESPPureToken("JUSTID", justid),
            RESPWithToken("LASTID", lastid)
        )
    }
}

/// Returns the number of messages after removing them from a stream.
@_documentation(visibility: internal)
public struct XDEL<Id: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "XDEL" }

    public var key: ValkeyKey
    public var ids: [Id]

    @inlinable public init(_ key: ValkeyKey, ids: [Id]) {
        self.key = key
        self.ids = ids
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XDEL", key, ids.map { RESPRenderableBulkString($0) })
    }
}

/// Return the number of messages in a stream.
@_documentation(visibility: internal)
public struct XLEN: ValkeyCommand {
    public typealias Response = Int

    @inlinable public static var name: String { "XLEN" }

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XLEN", key)
    }
}

/// Returns the information and entries from a stream consumer group's pending entries list.
@_documentation(visibility: internal)
public struct XPENDING<Group: RESPStringRenderable>: ValkeyCommand {
    public struct Filters: RESPRenderable, Sendable, Hashable {
        public var minIdleTime: Int?
        public var start: String
        public var end: String
        public var count: Int
        public var consumer: String?

        @inlinable
        public init(minIdleTime: Int? = nil, start: String, end: String, count: Int, consumer: String? = nil) {
            self.minIdleTime = minIdleTime
            self.start = start
            self.end = end
            self.count = count
            self.consumer = consumer
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("IDLE", minIdleTime).respEntries + start.respEntries + end.respEntries + count.respEntries + consumer.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("IDLE", minIdleTime).encode(into: &commandEncoder)
            start.encode(into: &commandEncoder)
            end.encode(into: &commandEncoder)
            count.encode(into: &commandEncoder)
            consumer.encode(into: &commandEncoder)
        }
    }
    @inlinable public static var name: String { "XPENDING" }

    public var key: ValkeyKey
    public var group: Group
    public var filters: Filters?

    @inlinable public init(_ key: ValkeyKey, group: Group, filters: Filters? = nil) {
        self.key = key
        self.group = group
        self.filters = filters
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XPENDING", key, RESPRenderableBulkString(group), filters)
    }
}

/// Returns the messages from a stream within a range of IDs.
@_documentation(visibility: internal)
public struct XRANGE<Start: RESPStringRenderable, End: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = [XMessage]

    @inlinable public static var name: String { "XRANGE" }

    public var key: ValkeyKey
    public var start: Start
    public var end: End
    public var count: Int?

    @inlinable public init(_ key: ValkeyKey, start: Start, end: End, count: Int? = nil) {
        self.key = key
        self.start = start
        self.end = end
        self.count = count
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XRANGE", key, RESPRenderableBulkString(start), RESPRenderableBulkString(end), RESPWithToken("COUNT", count))
    }
}

/// Returns messages from multiple streams with IDs greater than the ones requested. Blocks until a message is available otherwise.
@_documentation(visibility: internal)
public struct XREAD<Id: RESPStringRenderable>: ValkeyCommand {
    public struct Streams: RESPRenderable, Sendable, Hashable {
        public var keys: [ValkeyKey]
        public var ids: [Id]

        @inlinable
        public init(keys: [ValkeyKey], ids: [Id]) {
            self.keys = keys
            self.ids = ids
        }

        @inlinable
        public var respEntries: Int {
            keys.respEntries + ids.map { RESPRenderableBulkString($0) }.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            keys.encode(into: &commandEncoder)
            ids.map { RESPRenderableBulkString($0) }.encode(into: &commandEncoder)
        }
    }
    public typealias Response = XREADStreams<XMessage>?

    @inlinable public static var name: String { "XREAD" }

    public var count: Int?
    public var milliseconds: Int?
    public var streams: Streams

    @inlinable public init(count: Int? = nil, milliseconds: Int? = nil, streams: Streams) {
        self.count = count
        self.milliseconds = milliseconds
        self.streams = streams
    }

    public var keysAffected: [ValkeyKey] { streams.keys }

    public var isBlocking: Bool { true }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XREAD", RESPWithToken("COUNT", count), RESPWithToken("BLOCK", milliseconds), RESPWithToken("STREAMS", streams))
    }
}

/// Returns new or historical messages from a stream for a consumer in a group. Blocks until a message is available otherwise.
@_documentation(visibility: internal)
public struct XREADGROUP<Group: RESPStringRenderable, Consumer: RESPStringRenderable, Id: RESPStringRenderable>: ValkeyCommand {
    public struct GroupBlock: RESPRenderable, Sendable, Hashable {
        public var group: Group
        public var consumer: Consumer

        @inlinable
        public init(group: Group, consumer: Consumer) {
            self.group = group
            self.consumer = consumer
        }

        @inlinable
        public var respEntries: Int {
            RESPRenderableBulkString(group).respEntries + RESPRenderableBulkString(consumer).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPRenderableBulkString(group).encode(into: &commandEncoder)
            RESPRenderableBulkString(consumer).encode(into: &commandEncoder)
        }
    }
    public struct Streams: RESPRenderable, Sendable, Hashable {
        public var keys: [ValkeyKey]
        public var ids: [Id]

        @inlinable
        public init(keys: [ValkeyKey], ids: [Id]) {
            self.keys = keys
            self.ids = ids
        }

        @inlinable
        public var respEntries: Int {
            keys.respEntries + ids.map { RESPRenderableBulkString($0) }.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            keys.encode(into: &commandEncoder)
            ids.map { RESPRenderableBulkString($0) }.encode(into: &commandEncoder)
        }
    }
    public typealias Response = XREADStreams<XREADGroupMessage>?

    @inlinable public static var name: String { "XREADGROUP" }

    public var groupBlock: GroupBlock
    public var count: Int?
    public var milliseconds: Int?
    public var noack: Bool
    public var streams: Streams

    @inlinable public init(groupBlock: GroupBlock, count: Int? = nil, milliseconds: Int? = nil, noack: Bool = false, streams: Streams) {
        self.groupBlock = groupBlock
        self.count = count
        self.milliseconds = milliseconds
        self.noack = noack
        self.streams = streams
    }

    public var keysAffected: [ValkeyKey] { streams.keys }

    public var isBlocking: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "XREADGROUP",
            RESPWithToken("GROUP", groupBlock),
            RESPWithToken("COUNT", count),
            RESPWithToken("BLOCK", milliseconds),
            RESPPureToken("NOACK", noack),
            RESPWithToken("STREAMS", streams)
        )
    }
}

/// Returns the messages from a stream within a range of IDs in reverse order.
@_documentation(visibility: internal)
public struct XREVRANGE<End: RESPStringRenderable, Start: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = [XMessage]

    @inlinable public static var name: String { "XREVRANGE" }

    public var key: ValkeyKey
    public var end: End
    public var start: Start
    public var count: Int?

    @inlinable public init(_ key: ValkeyKey, end: End, start: Start, count: Int? = nil) {
        self.key = key
        self.end = end
        self.start = start
        self.count = count
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XREVRANGE", key, RESPRenderableBulkString(end), RESPRenderableBulkString(start), RESPWithToken("COUNT", count))
    }
}

/// An internal command for replicating stream values.
@_documentation(visibility: internal)
public struct XSETID<LastId: RESPStringRenderable>: ValkeyCommand {
    @inlinable public static var name: String { "XSETID" }

    public var key: ValkeyKey
    public var lastId: LastId
    public var entriesAdded: Int?
    public var maxDeletedId: String?

    @inlinable public init(_ key: ValkeyKey, lastId: LastId, entriesAdded: Int? = nil, maxDeletedId: String? = nil) {
        self.key = key
        self.lastId = lastId
        self.entriesAdded = entriesAdded
        self.maxDeletedId = maxDeletedId
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "XSETID",
            key,
            RESPRenderableBulkString(lastId),
            RESPWithToken("ENTRIESADDED", entriesAdded),
            RESPWithToken("MAXDELETEDID", maxDeletedId)
        )
    }
}

/// Deletes messages from the beginning of a stream.
@_documentation(visibility: internal)
public struct XTRIM<Threshold: RESPStringRenderable>: ValkeyCommand {
    public enum TrimStrategy: RESPRenderable, Sendable, Hashable {
        case maxlen
        case minid

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .maxlen: "MAXLEN".encode(into: &commandEncoder)
            case .minid: "MINID".encode(into: &commandEncoder)
            }
        }
    }
    public enum TrimOperator: RESPRenderable, Sendable, Hashable {
        case equal
        case approximately

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .equal: "=".encode(into: &commandEncoder)
            case .approximately: "~".encode(into: &commandEncoder)
            }
        }
    }
    public struct Trim: RESPRenderable, Sendable, Hashable {
        public var strategy: TrimStrategy
        public var `operator`: TrimOperator?
        public var threshold: Threshold
        public var count: Int?

        @inlinable
        public init(strategy: TrimStrategy, `operator`: TrimOperator? = nil, threshold: Threshold, count: Int? = nil) {
            self.strategy = strategy
            self.`operator` = `operator`
            self.threshold = threshold
            self.count = count
        }

        @inlinable
        public var respEntries: Int {
            strategy.respEntries + `operator`.respEntries + RESPRenderableBulkString(threshold).respEntries
                + RESPWithToken("LIMIT", count).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            strategy.encode(into: &commandEncoder)
            `operator`.encode(into: &commandEncoder)
            RESPRenderableBulkString(threshold).encode(into: &commandEncoder)
            RESPWithToken("LIMIT", count).encode(into: &commandEncoder)
        }
    }
    public typealias Response = Int

    @inlinable public static var name: String { "XTRIM" }

    public var key: ValkeyKey
    public var trim: Trim

    @inlinable public init(_ key: ValkeyKey, trim: Trim) {
        self.key = key
        self.trim = trim
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XTRIM", key, trim)
    }
}

@available(valkeySwift 1.0, *)
extension ValkeyClientProtocol {
    /// Returns the number of messages that were successfully acknowledged by the consumer group member of a stream.
    ///
    /// - Documentation: [XACK](https://valkey.io/commands/xack)
    /// - Available: 5.0.0
    /// - Complexity: O(1) for each message ID processed.
    /// - Response: [Integer]: The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have already been acknowledged), and XACK will not count them as successfully acknowledged.
    @inlinable
    @discardableResult
    public func xack<Group: RESPStringRenderable, Id: RESPStringRenderable>(_ key: ValkeyKey, group: Group, ids: [Id]) async throws -> Int {
        try await execute(XACK(key, group: group, ids: ids))
    }

    /// Appends a new message to a stream. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [XADD](https://valkey.io/commands/xadd)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.2.0: Added the `NOMKSTREAM` option, `MINID` trimming strategy and the `LIMIT` option.
    ///     * 7.0.0: Added support for the `<ms>-*` explicit ID form.
    /// - Complexity: O(1) when adding a new entry, O(N) when trimming where N being the number of entries evicted.
    /// - Response: One of the following
    ///     * [String]: The ID of the added entry. The ID is the one auto-generated if * is passed as ID argument, otherwise the command just returns the same ID specified by the user during insertion.
    ///     * [Null]: The NOMKSTREAM option is given and the key doesn't exist.
    @inlinable
    @discardableResult
    public func xadd<Field: RESPStringRenderable, Value: RESPStringRenderable>(
        _ key: ValkeyKey,
        nomkstream: Bool = false,
        trim: XADD<Field, Value>.Trim? = nil,
        idSelector: XADD<Field, Value>.IdSelector,
        data: [XADD<Field, Value>.Data]
    ) async throws -> RESPBulkString? {
        try await execute(XADD(key, nomkstream: nomkstream, trim: trim, idSelector: idSelector, data: data))
    }

    /// Changes, or acquires, ownership of messages in a consumer group, as if the messages were delivered to as consumer group member.
    ///
    /// - Documentation: [XAUTOCLAIM](https://valkey.io/commands/xautoclaim)
    /// - Available: 6.2.0
    /// - History:
    ///     * 7.0.0: Added an element to the reply array, containing deleted entries the command cleared from the PEL
    /// - Complexity: O(1) if COUNT is small.
    /// - Response: One of the following
    ///     * [Array]: Claimed stream entries (with data, if `JUSTID` was not given).
    ///     * [Array]: Claimed stream entries (without data, if `JUSTID` was given).
    @inlinable
    @discardableResult
    public func xautoclaim<
        Group: RESPStringRenderable,
        Consumer: RESPStringRenderable,
        MinIdleTime: RESPStringRenderable,
        Start: RESPStringRenderable
    >(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer,
        minIdleTime: MinIdleTime,
        start: Start,
        count: Int? = nil,
        justid: Bool = false
    ) async throws -> XAUTOCLAIMResponse {
        try await execute(XAUTOCLAIM(key, group: group, consumer: consumer, minIdleTime: minIdleTime, start: start, count: count, justid: justid))
    }

    /// Changes, or acquires, ownership of a message in a consumer group, as if the message was delivered a consumer group member.
    ///
    /// - Documentation: [XCLAIM](https://valkey.io/commands/xclaim)
    /// - Available: 5.0.0
    /// - Complexity: O(log N) with N being the number of messages in the PEL of the consumer group.
    /// - Response: Stream entries with IDs matching the specified range.
    @inlinable
    @discardableResult
    public func xclaim<Group: RESPStringRenderable, Consumer: RESPStringRenderable, MinIdleTime: RESPStringRenderable, Id: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer,
        minIdleTime: MinIdleTime,
        ids: [Id],
        ms: Int? = nil,
        unixTimeMilliseconds: Date? = nil,
        count: Int? = nil,
        force: Bool = false,
        justid: Bool = false,
        lastid: String? = nil
    ) async throws -> XCLAIMResponse {
        try await execute(
            XCLAIM(
                key,
                group: group,
                consumer: consumer,
                minIdleTime: minIdleTime,
                ids: ids,
                ms: ms,
                unixTimeMilliseconds: unixTimeMilliseconds,
                count: count,
                force: force,
                justid: justid,
                lastid: lastid
            )
        )
    }

    /// Returns the number of messages after removing them from a stream.
    ///
    /// - Documentation: [XDEL](https://valkey.io/commands/xdel)
    /// - Available: 5.0.0
    /// - Complexity: O(1) for each single item to delete in the stream, regardless of the stream size.
    /// - Response: [Integer]: The number of entries actually deleted
    @inlinable
    @discardableResult
    public func xdel<Id: RESPStringRenderable>(_ key: ValkeyKey, ids: [Id]) async throws -> Int {
        try await execute(XDEL(key, ids: ids))
    }

    /// Creates a consumer group.
    ///
    /// - Documentation: [XGROUP CREATE](https://valkey.io/commands/xgroup-create)
    /// - Available: 5.0.0
    /// - History:
    ///     * 7.0.0: Added the `entries_read` named argument.
    /// - Complexity: O(1)
    @inlinable
    public func xgroupCreate<Group: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        idSelector: XGROUP.CREATE<Group>.IdSelector,
        mkstream: Bool = false,
        entriesread: Int? = nil
    ) async throws {
        _ = try await execute(XGROUP.CREATE(key, group: group, idSelector: idSelector, mkstream: mkstream, entriesread: entriesread))
    }

    /// Creates a consumer in a consumer group.
    ///
    /// - Documentation: [XGROUP CREATECONSUMER](https://valkey.io/commands/xgroup-createconsumer)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    /// - Response: The number of created consumers (0 or 1)
    @inlinable
    @discardableResult
    public func xgroupCreateconsumer<Group: RESPStringRenderable, Consumer: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer
    ) async throws -> Int {
        try await execute(XGROUP.CREATECONSUMER(key, group: group, consumer: consumer))
    }

    /// Deletes a consumer from a consumer group.
    ///
    /// - Documentation: [XGROUP DELCONSUMER](https://valkey.io/commands/xgroup-delconsumer)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Integer]: The number of pending messages that were yet associated with such a consumer
    @inlinable
    @discardableResult
    public func xgroupDelconsumer<Group: RESPStringRenderable, Consumer: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer
    ) async throws -> Int {
        try await execute(XGROUP.DELCONSUMER(key, group: group, consumer: consumer))
    }

    /// Destroys a consumer group.
    ///
    /// - Documentation: [XGROUP DESTROY](https://valkey.io/commands/xgroup-destroy)
    /// - Available: 5.0.0
    /// - Complexity: O(N) where N is the number of entries in the group's pending entries list (PEL).
    /// - Response: The number of destroyed consumer groups (0 or 1)
    @inlinable
    @discardableResult
    public func xgroupDestroy<Group: RESPStringRenderable>(_ key: ValkeyKey, group: Group) async throws -> Int {
        try await execute(XGROUP.DESTROY(key, group: group))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [XGROUP HELP](https://valkey.io/commands/xgroup-help)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Array]: Helpful text about subcommands.
    @inlinable
    @discardableResult
    public func xgroupHelp() async throws -> RESPToken.Array {
        try await execute(XGROUP.HELP())
    }

    /// Sets the last-delivered ID of a consumer group.
    ///
    /// - Documentation: [XGROUP SETID](https://valkey.io/commands/xgroup-setid)
    /// - Available: 5.0.0
    /// - History:
    ///     * 7.0.0: Added the optional `entries_read` argument.
    /// - Complexity: O(1)
    @inlinable
    public func xgroupSetid<Group: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        idSelector: XGROUP.SETID<Group>.IdSelector,
        entriesread: Int? = nil
    ) async throws {
        _ = try await execute(XGROUP.SETID(key, group: group, idSelector: idSelector, entriesread: entriesread))
    }

    /// Returns a list of the consumers in a consumer group.
    ///
    /// - Documentation: [XINFO CONSUMERS](https://valkey.io/commands/xinfo-consumers)
    /// - Available: 5.0.0
    /// - History:
    ///     * 7.2.0: Added the `inactive` field, and changed the meaning of `idle`.
    /// - Complexity: O(1)
    /// - Response: [Array]: Array list of consumers
    @inlinable
    public func xinfoConsumers<Group: RESPStringRenderable>(_ key: ValkeyKey, group: Group) async throws -> [XINFO.Consumer] {
        try await execute(XINFO.CONSUMERS(key, group: group))
    }

    /// Returns a list of the consumer groups of a stream.
    ///
    /// - Documentation: [XINFO GROUPS](https://valkey.io/commands/xinfo-groups)
    /// - Available: 5.0.0
    /// - History:
    ///     * 7.0.0: Added the `entries-read` and `lag` fields
    /// - Complexity: O(1)
    @inlinable
    public func xinfoGroups(_ key: ValkeyKey) async throws -> XINFO.GROUPS.Response {
        try await execute(XINFO.GROUPS(key))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [XINFO HELP](https://valkey.io/commands/xinfo-help)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Array]: Helpful text about subcommands.
    @inlinable
    @discardableResult
    public func xinfoHelp() async throws -> RESPToken.Array {
        try await execute(XINFO.HELP())
    }

    /// Returns information about a stream.
    ///
    /// - Documentation: [XINFO STREAM](https://valkey.io/commands/xinfo-stream)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.0.0: Added the `FULL` modifier.
    ///     * 7.0.0: Added the `max-deleted-entry-id`, `entries-added`, `recorded-first-entry-id`, `entries-read` and `lag` fields
    ///     * 7.2.0: Added the `active-time` field, and changed the meaning of `seen-time`.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [Map]: Summary form, in case `FULL` was not given.
    ///     * [Map]: Extended form, in case `FULL` was given.
    @inlinable
    public func xinfoStream(_ key: ValkeyKey, fullBlock: XINFO.STREAM.FullBlock? = nil) async throws -> XINFO.STREAM.Response {
        try await execute(XINFO.STREAM(key, fullBlock: fullBlock))
    }

    /// Return the number of messages in a stream.
    ///
    /// - Documentation: [XLEN](https://valkey.io/commands/xlen)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Integer]: The number of entries of the stream at key
    @inlinable
    public func xlen(_ key: ValkeyKey) async throws -> Int {
        try await execute(XLEN(key))
    }

    /// Returns the information and entries from a stream consumer group's pending entries list.
    ///
    /// - Documentation: [XPENDING](https://valkey.io/commands/xpending)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.2.0: Added the `IDLE` option and exclusive range intervals.
    /// - Complexity: O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). O(M), where M is the total number of entries scanned when used with the IDLE filter. When the command returns just the summary and the list of consumers is small, it runs in O(1) time; otherwise, an additional O(N) time for iterating every consumer.
    /// - Response: One of the following
    ///     * [Array]: Extended form, in case `start` was given.
    ///     * [Array]: Summary form, in case `start` was not given.
    @inlinable
    public func xpending<Group: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        filters: XPENDING<Group>.Filters? = nil
    ) async throws -> XPENDINGResponse {
        try await execute(XPENDING(key, group: group, filters: filters))
    }

    /// Returns the messages from a stream within a range of IDs.
    ///
    /// - Documentation: [XRANGE](https://valkey.io/commands/xrange)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.2.0: Added exclusive ranges.
    /// - Complexity: O(N) with N being the number of elements being returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
    /// - Response: [Array]: Stream entries with IDs matching the specified range.
    @inlinable
    public func xrange<Start: RESPStringRenderable, End: RESPStringRenderable>(
        _ key: ValkeyKey,
        start: Start,
        end: End,
        count: Int? = nil
    ) async throws -> [XMessage] {
        try await execute(XRANGE(key, start: start, end: end, count: count))
    }

    /// Returns messages from multiple streams with IDs greater than the ones requested. Blocks until a message is available otherwise.
    ///
    /// - Documentation: [XREAD](https://valkey.io/commands/xread)
    /// - Available: 5.0.0
    /// - Response: One of the following
    ///     * [Map]: A map of key-value elements when each element composed of key name and the entries reported for that key.
    ///     * [Null]: If BLOCK option is given, and a timeout occurs, or there is no stream we can serve.
    @inlinable
    public func xread<Id: RESPStringRenderable>(
        count: Int? = nil,
        milliseconds: Int? = nil,
        streams: XREAD<Id>.Streams
    ) async throws -> XREADStreams<XMessage>? {
        try await execute(XREAD(count: count, milliseconds: milliseconds, streams: streams))
    }

    /// Returns new or historical messages from a stream for a consumer in a group. Blocks until a message is available otherwise.
    ///
    /// - Documentation: [XREADGROUP](https://valkey.io/commands/xreadgroup)
    /// - Available: 5.0.0
    /// - Complexity: For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data.
    /// - Response: One of the following
    ///     * [Null]: If BLOCK option is specified and the timeout expired
    ///     * [Map]: A map of key-value elements when each element composed of key name and the entries reported for that key
    @inlinable
    @discardableResult
    public func xreadgroup<Group: RESPStringRenderable, Consumer: RESPStringRenderable, Id: RESPStringRenderable>(
        groupBlock: XREADGROUP<Group, Consumer, Id>.GroupBlock,
        count: Int? = nil,
        milliseconds: Int? = nil,
        noack: Bool = false,
        streams: XREADGROUP<Group, Consumer, Id>.Streams
    ) async throws -> XREADStreams<XREADGroupMessage>? {
        try await execute(XREADGROUP(groupBlock: groupBlock, count: count, milliseconds: milliseconds, noack: noack, streams: streams))
    }

    /// Returns the messages from a stream within a range of IDs in reverse order.
    ///
    /// - Documentation: [XREVRANGE](https://valkey.io/commands/xrevrange)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.2.0: Added exclusive ranges.
    /// - Complexity: O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
    /// - Response: [Array]: An array of the entries with IDs matching the specified range
    @inlinable
    public func xrevrange<End: RESPStringRenderable, Start: RESPStringRenderable>(
        _ key: ValkeyKey,
        end: End,
        start: Start,
        count: Int? = nil
    ) async throws -> [XMessage] {
        try await execute(XREVRANGE(key, end: end, start: start, count: count))
    }

    /// An internal command for replicating stream values.
    ///
    /// - Documentation: [XSETID](https://valkey.io/commands/xsetid)
    /// - Available: 5.0.0
    /// - History:
    ///     * 7.0.0: Added the `entries_added` and `max_deleted_entry_id` arguments.
    /// - Complexity: O(1)
    @inlinable
    public func xsetid<LastId: RESPStringRenderable>(
        _ key: ValkeyKey,
        lastId: LastId,
        entriesAdded: Int? = nil,
        maxDeletedId: String? = nil
    ) async throws {
        _ = try await execute(XSETID(key, lastId: lastId, entriesAdded: entriesAdded, maxDeletedId: maxDeletedId))
    }

    /// Deletes messages from the beginning of a stream.
    ///
    /// - Documentation: [XTRIM](https://valkey.io/commands/xtrim)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.2.0: Added the `MINID` trimming strategy and the `LIMIT` option.
    /// - Complexity: O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.
    /// - Response: [Integer]: The number of entries deleted from the stream.
    @inlinable
    @discardableResult
    public func xtrim<Threshold: RESPStringRenderable>(_ key: ValkeyKey, trim: XTRIM<Threshold>.Trim) async throws -> Int {
        try await execute(XTRIM(key, trim: trim))
    }

}
