//===----------------------------------------------------------------------===//
//
// This source file is part of the valkey-swift open source project
//
// Copyright (c) 2025 the valkey-swift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of valkey-swift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// A container for consumer groups commands.
@_documentation(visibility: internal)
public enum XGROUP {
    /// Creates a consumer group.
    @_documentation(visibility: internal)
    public struct CREATE<Group: RESPStringRenderable>: ValkeyCommand {
        public enum IdSelector: RESPRenderable, Sendable, Hashable {
            case id(String)
            case newId

            @inlinable
            public var respEntries: Int {
                switch self {
                case .id(let id): id.respEntries
                case .newId: "$".respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .id(let id): id.encode(into: &commandEncoder)
                case .newId: "$".encode(into: &commandEncoder)
                }
            }
        }
        public var key: ValkeyKey
        public var group: Group
        public var idSelector: IdSelector
        public var mkstream: Bool
        public var entriesread: Int?

        @inlinable public init(_ key: ValkeyKey, group: Group, idSelector: IdSelector, mkstream: Bool = false, entriesread: Int? = nil) {
            self.key = key
            self.group = group
            self.idSelector = idSelector
            self.mkstream = mkstream
            self.entriesread = entriesread
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "XGROUP",
                "CREATE",
                key,
                RESPBulkString(group),
                idSelector,
                RESPPureToken("MKSTREAM", mkstream),
                RESPWithToken("ENTRIESREAD", entriesread)
            )
        }
    }

    /// Creates a consumer in a consumer group.
    @_documentation(visibility: internal)
    public struct CREATECONSUMER<Group: RESPStringRenderable, Consumer: RESPStringRenderable>: ValkeyCommand {
        public typealias Response = Int

        public var key: ValkeyKey
        public var group: Group
        public var consumer: Consumer

        @inlinable public init(_ key: ValkeyKey, group: Group, consumer: Consumer) {
            self.key = key
            self.group = group
            self.consumer = consumer
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "CREATECONSUMER", key, RESPBulkString(group), RESPBulkString(consumer))
        }
    }

    /// Deletes a consumer from a consumer group.
    @_documentation(visibility: internal)
    public struct DELCONSUMER<Group: RESPStringRenderable, Consumer: RESPStringRenderable>: ValkeyCommand {
        public typealias Response = Int

        public var key: ValkeyKey
        public var group: Group
        public var consumer: Consumer

        @inlinable public init(_ key: ValkeyKey, group: Group, consumer: Consumer) {
            self.key = key
            self.group = group
            self.consumer = consumer
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "DELCONSUMER", key, RESPBulkString(group), RESPBulkString(consumer))
        }
    }

    /// Destroys a consumer group.
    @_documentation(visibility: internal)
    public struct DESTROY<Group: RESPStringRenderable>: ValkeyCommand {
        public typealias Response = Int

        public var key: ValkeyKey
        public var group: Group

        @inlinable public init(_ key: ValkeyKey, group: Group) {
            self.key = key
            self.group = group
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "DESTROY", key, RESPBulkString(group))
        }
    }

    /// Returns helpful text about the different subcommands.
    @_documentation(visibility: internal)
    public struct HELP: ValkeyCommand {
        public typealias Response = RESPToken.Array

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "HELP")
        }
    }

    /// Sets the last-delivered ID of a consumer group.
    @_documentation(visibility: internal)
    public struct SETID<Group: RESPStringRenderable>: ValkeyCommand {
        public enum IdSelector: RESPRenderable, Sendable, Hashable {
            case id(String)
            case newId

            @inlinable
            public var respEntries: Int {
                switch self {
                case .id(let id): id.respEntries
                case .newId: "$".respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .id(let id): id.encode(into: &commandEncoder)
                case .newId: "$".encode(into: &commandEncoder)
                }
            }
        }
        public var key: ValkeyKey
        public var group: Group
        public var idSelector: IdSelector
        public var entriesread: Int?

        @inlinable public init(_ key: ValkeyKey, group: Group, idSelector: IdSelector, entriesread: Int? = nil) {
            self.key = key
            self.group = group
            self.idSelector = idSelector
            self.entriesread = entriesread
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XGROUP", "SETID", key, RESPBulkString(group), idSelector, RESPWithToken("ENTRIESREAD", entriesread))
        }
    }

}

/// A container for stream introspection commands.
@_documentation(visibility: internal)
public enum XINFO {
    /// Returns a list of the consumers in a consumer group.
    @_documentation(visibility: internal)
    public struct CONSUMERS<Group: RESPStringRenderable>: ValkeyCommand {
        public typealias Response = RESPToken.Array

        public var key: ValkeyKey
        public var group: Group

        @inlinable public init(_ key: ValkeyKey, group: Group) {
            self.key = key
            self.group = group
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        public var isReadOnly: Bool { true }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "CONSUMERS", key, RESPBulkString(group))
        }
    }

    /// Returns a list of the consumer groups of a stream.
    @_documentation(visibility: internal)
    public struct GROUPS: ValkeyCommand {
        public typealias Response = RESPToken.Array

        public var key: ValkeyKey

        @inlinable public init(_ key: ValkeyKey) {
            self.key = key
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        public var isReadOnly: Bool { true }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "GROUPS", key)
        }
    }

    /// Returns helpful text about the different subcommands.
    @_documentation(visibility: internal)
    public struct HELP: ValkeyCommand {
        public typealias Response = RESPToken.Array

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "HELP")
        }
    }

    /// Returns information about a stream.
    @_documentation(visibility: internal)
    public struct STREAM: ValkeyCommand {
        public struct FullBlock: RESPRenderable, Sendable, Hashable {
            @usableFromInline let count: Int?

            @inlinable public init(count: Int? = nil) {
                self.count = count
            }

            @inlinable
            public var respEntries: Int {
                "FULL".respEntries + RESPWithToken("COUNT", count).respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "FULL".encode(into: &commandEncoder)
                RESPWithToken("COUNT", count).encode(into: &commandEncoder)
            }
        }
        public typealias Response = RESPToken.Map

        public var key: ValkeyKey
        public var fullBlock: FullBlock?

        @inlinable public init(_ key: ValkeyKey, fullBlock: FullBlock? = nil) {
            self.key = key
            self.fullBlock = fullBlock
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        public var isReadOnly: Bool { true }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("XINFO", "STREAM", key, fullBlock)
        }
    }

}

/// Returns the number of messages that were successfully acknowledged by the consumer group member of a stream.
@_documentation(visibility: internal)
public struct XACK<Group: RESPStringRenderable, Id: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var group: Group
    public var ids: [Id]

    @inlinable public init(_ key: ValkeyKey, group: Group, ids: [Id]) {
        self.key = key
        self.group = group
        self.ids = ids
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XACK", key, RESPBulkString(group), ids.map { RESPBulkString($0) })
    }
}

/// Appends a new message to a stream. Creates the key if it doesn't exist.
@_documentation(visibility: internal)
public struct XADD<Field: RESPStringRenderable, Value: RESPStringRenderable>: ValkeyCommand {
    public enum TrimStrategy: RESPRenderable, Sendable, Hashable {
        case maxlen
        case minid

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .maxlen: "MAXLEN".encode(into: &commandEncoder)
            case .minid: "MINID".encode(into: &commandEncoder)
            }
        }
    }
    public enum TrimOperator: RESPRenderable, Sendable, Hashable {
        case equal
        case approximately

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .equal: "=".encode(into: &commandEncoder)
            case .approximately: "~".encode(into: &commandEncoder)
            }
        }
    }
    public struct Trim: RESPRenderable, Sendable, Hashable {
        @usableFromInline let strategy: TrimStrategy
        @usableFromInline let `operator`: TrimOperator?
        @usableFromInline let threshold: String
        @usableFromInline let count: Int?

        @inlinable public init(strategy: TrimStrategy, `operator`: TrimOperator? = nil, threshold: String, count: Int? = nil) {
            self.strategy = strategy
            self.`operator` = `operator`
            self.threshold = threshold
            self.count = count
        }

        @inlinable
        public var respEntries: Int {
            strategy.respEntries + `operator`.respEntries + threshold.respEntries + RESPWithToken("LIMIT", count).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            strategy.encode(into: &commandEncoder)
            `operator`.encode(into: &commandEncoder)
            threshold.encode(into: &commandEncoder)
            RESPWithToken("LIMIT", count).encode(into: &commandEncoder)
        }
    }
    public enum IdSelector: RESPRenderable, Sendable, Hashable {
        case autoId
        case id(String)

        @inlinable
        public var respEntries: Int {
            switch self {
            case .autoId: "*".respEntries
            case .id(let id): id.respEntries
            }
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .autoId: "*".encode(into: &commandEncoder)
            case .id(let id): id.encode(into: &commandEncoder)
            }
        }
    }
    public struct Data: RESPRenderable, Sendable, Hashable {
        @usableFromInline let field: Field
        @usableFromInline let value: Value

        @inlinable public init(field: Field, value: Value) {
            self.field = field
            self.value = value
        }

        @inlinable
        public var respEntries: Int {
            RESPBulkString(field).respEntries + RESPBulkString(value).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPBulkString(field).encode(into: &commandEncoder)
            RESPBulkString(value).encode(into: &commandEncoder)
        }
    }
    public typealias Response = ByteBuffer?

    public var key: ValkeyKey
    public var nomkstream: Bool
    public var trim: Trim?
    public var idSelector: IdSelector
    public var datas: [Data]

    @inlinable public init(_ key: ValkeyKey, nomkstream: Bool = false, trim: Trim? = nil, idSelector: IdSelector, datas: [Data]) {
        self.key = key
        self.nomkstream = nomkstream
        self.trim = trim
        self.idSelector = idSelector
        self.datas = datas
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XADD", key, RESPPureToken("NOMKSTREAM", nomkstream), trim, idSelector, datas)
    }
}

/// Changes, or acquires, ownership of messages in a consumer group, as if the messages were delivered to as consumer group member.
@_documentation(visibility: internal)
public struct XAUTOCLAIM<Group: RESPStringRenderable, Consumer: RESPStringRenderable, MinIdleTime: RESPStringRenderable, Start: RESPStringRenderable>:
    ValkeyCommand
{
    public var key: ValkeyKey
    public var group: Group
    public var consumer: Consumer
    public var minIdleTime: MinIdleTime
    public var start: Start
    public var count: Int?
    public var justid: Bool

    @inlinable public init(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer,
        minIdleTime: MinIdleTime,
        start: Start,
        count: Int? = nil,
        justid: Bool = false
    ) {
        self.key = key
        self.group = group
        self.consumer = consumer
        self.minIdleTime = minIdleTime
        self.start = start
        self.count = count
        self.justid = justid
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "XAUTOCLAIM",
            key,
            RESPBulkString(group),
            RESPBulkString(consumer),
            RESPBulkString(minIdleTime),
            RESPBulkString(start),
            RESPWithToken("COUNT", count),
            RESPPureToken("JUSTID", justid)
        )
    }
}

/// Changes, or acquires, ownership of a message in a consumer group, as if the message was delivered a consumer group member.
@_documentation(visibility: internal)
public struct XCLAIM<Group: RESPStringRenderable, Consumer: RESPStringRenderable, MinIdleTime: RESPStringRenderable, Id: RESPStringRenderable>:
    ValkeyCommand
{
    public var key: ValkeyKey
    public var group: Group
    public var consumer: Consumer
    public var minIdleTime: MinIdleTime
    public var ids: [Id]
    public var ms: Int?
    public var unixTimeMilliseconds: Date?
    public var count: Int?
    public var force: Bool
    public var justid: Bool
    public var lastid: String?

    @inlinable public init(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer,
        minIdleTime: MinIdleTime,
        ids: [Id],
        ms: Int? = nil,
        unixTimeMilliseconds: Date? = nil,
        count: Int? = nil,
        force: Bool = false,
        justid: Bool = false,
        lastid: String? = nil
    ) {
        self.key = key
        self.group = group
        self.consumer = consumer
        self.minIdleTime = minIdleTime
        self.ids = ids
        self.ms = ms
        self.unixTimeMilliseconds = unixTimeMilliseconds
        self.count = count
        self.force = force
        self.justid = justid
        self.lastid = lastid
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "XCLAIM",
            key,
            RESPBulkString(group),
            RESPBulkString(consumer),
            RESPBulkString(minIdleTime),
            ids.map { RESPBulkString($0) },
            RESPWithToken("IDLE", ms),
            RESPWithToken("TIME", unixTimeMilliseconds.map { Int($0.timeIntervalSince1970 * 1000) }),
            RESPWithToken("RETRYCOUNT", count),
            RESPPureToken("FORCE", force),
            RESPPureToken("JUSTID", justid),
            RESPWithToken("LASTID", lastid)
        )
    }
}

/// Returns the number of messages after removing them from a stream.
@_documentation(visibility: internal)
public struct XDEL<Id: RESPStringRenderable>: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey
    public var ids: [Id]

    @inlinable public init(_ key: ValkeyKey, ids: [Id]) {
        self.key = key
        self.ids = ids
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XDEL", key, ids.map { RESPBulkString($0) })
    }
}

/// Return the number of messages in a stream.
@_documentation(visibility: internal)
public struct XLEN: ValkeyCommand {
    public typealias Response = Int

    public var key: ValkeyKey

    @inlinable public init(_ key: ValkeyKey) {
        self.key = key
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XLEN", key)
    }
}

/// Returns the information and entries from a stream consumer group's pending entries list.
@_documentation(visibility: internal)
public struct XPENDING<Group: RESPStringRenderable>: ValkeyCommand {
    public struct Filters: RESPRenderable, Sendable, Hashable {
        @usableFromInline let minIdleTime: Int?
        @usableFromInline let start: String
        @usableFromInline let end: String
        @usableFromInline let count: Int
        @usableFromInline let consumer: String?

        @inlinable public init(minIdleTime: Int? = nil, start: String, end: String, count: Int, consumer: String? = nil) {
            self.minIdleTime = minIdleTime
            self.start = start
            self.end = end
            self.count = count
            self.consumer = consumer
        }

        @inlinable
        public var respEntries: Int {
            RESPWithToken("IDLE", minIdleTime).respEntries + start.respEntries + end.respEntries + count.respEntries + consumer.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPWithToken("IDLE", minIdleTime).encode(into: &commandEncoder)
            start.encode(into: &commandEncoder)
            end.encode(into: &commandEncoder)
            count.encode(into: &commandEncoder)
            consumer.encode(into: &commandEncoder)
        }
    }
    public var key: ValkeyKey
    public var group: Group
    public var filters: Filters?

    @inlinable public init(_ key: ValkeyKey, group: Group, filters: Filters? = nil) {
        self.key = key
        self.group = group
        self.filters = filters
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XPENDING", key, RESPBulkString(group), filters)
    }
}

/// Returns the messages from a stream within a range of IDs.
@_documentation(visibility: internal)
public struct XRANGE<Start: RESPStringRenderable, End: RESPStringRenderable>: ValkeyCommand {
    public var key: ValkeyKey
    public var start: Start
    public var end: End
    public var count: Int?

    @inlinable public init(_ key: ValkeyKey, start: Start, end: End, count: Int? = nil) {
        self.key = key
        self.start = start
        self.end = end
        self.count = count
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XRANGE", key, RESPBulkString(start), RESPBulkString(end), RESPWithToken("COUNT", count))
    }
}

/// Returns messages from multiple streams with IDs greater than the ones requested. Blocks until a message is available otherwise.
@_documentation(visibility: internal)
public struct XREAD<Id: RESPStringRenderable>: ValkeyCommand {
    public struct Streams: RESPRenderable, Sendable, Hashable {
        @usableFromInline let keys: [ValkeyKey]
        @usableFromInline let ids: [Id]

        @inlinable public init(keys: [ValkeyKey], ids: [Id]) {
            self.keys = keys
            self.ids = ids
        }

        @inlinable
        public var respEntries: Int {
            keys.respEntries + ids.map { RESPBulkString($0) }.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            keys.encode(into: &commandEncoder)
            ids.map { RESPBulkString($0) }.encode(into: &commandEncoder)
        }
    }
    public var count: Int?
    public var milliseconds: Int?
    public var streams: Streams

    @inlinable public init(count: Int? = nil, milliseconds: Int? = nil, streams: Streams) {
        self.count = count
        self.milliseconds = milliseconds
        self.streams = streams
    }

    public var keysAffected: [ValkeyKey] { streams.keys }

    public var isBlocking: Bool { true }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XREAD", RESPWithToken("COUNT", count), RESPWithToken("BLOCK", milliseconds), RESPWithToken("STREAMS", streams))
    }
}

/// Returns new or historical messages from a stream for a consumer in a group. Blocks until a message is available otherwise.
@_documentation(visibility: internal)
public struct XREADGROUP<Group: RESPStringRenderable, Consumer: RESPStringRenderable, Id: RESPStringRenderable>: ValkeyCommand {
    public struct GroupBlock: RESPRenderable, Sendable, Hashable {
        @usableFromInline let group: Group
        @usableFromInline let consumer: Consumer

        @inlinable public init(group: Group, consumer: Consumer) {
            self.group = group
            self.consumer = consumer
        }

        @inlinable
        public var respEntries: Int {
            RESPBulkString(group).respEntries + RESPBulkString(consumer).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            RESPBulkString(group).encode(into: &commandEncoder)
            RESPBulkString(consumer).encode(into: &commandEncoder)
        }
    }
    public struct Streams: RESPRenderable, Sendable, Hashable {
        @usableFromInline let keys: [ValkeyKey]
        @usableFromInline let ids: [Id]

        @inlinable public init(keys: [ValkeyKey], ids: [Id]) {
            self.keys = keys
            self.ids = ids
        }

        @inlinable
        public var respEntries: Int {
            keys.respEntries + ids.map { RESPBulkString($0) }.respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            keys.encode(into: &commandEncoder)
            ids.map { RESPBulkString($0) }.encode(into: &commandEncoder)
        }
    }
    public var groupBlock: GroupBlock
    public var count: Int?
    public var milliseconds: Int?
    public var noack: Bool
    public var streams: Streams

    @inlinable public init(groupBlock: GroupBlock, count: Int? = nil, milliseconds: Int? = nil, noack: Bool = false, streams: Streams) {
        self.groupBlock = groupBlock
        self.count = count
        self.milliseconds = milliseconds
        self.noack = noack
        self.streams = streams
    }

    public var keysAffected: [ValkeyKey] { streams.keys }

    public var isBlocking: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "XREADGROUP",
            RESPWithToken("GROUP", groupBlock),
            RESPWithToken("COUNT", count),
            RESPWithToken("BLOCK", milliseconds),
            RESPPureToken("NOACK", noack),
            RESPWithToken("STREAMS", streams)
        )
    }
}

/// Returns the messages from a stream within a range of IDs in reverse order.
@_documentation(visibility: internal)
public struct XREVRANGE<End: RESPStringRenderable, Start: RESPStringRenderable>: ValkeyCommand {
    public var key: ValkeyKey
    public var end: End
    public var start: Start
    public var count: Int?

    @inlinable public init(_ key: ValkeyKey, end: End, start: Start, count: Int? = nil) {
        self.key = key
        self.end = end
        self.start = start
        self.count = count
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    public var isReadOnly: Bool { true }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XREVRANGE", key, RESPBulkString(end), RESPBulkString(start), RESPWithToken("COUNT", count))
    }
}

/// An internal command for replicating stream values.
@_documentation(visibility: internal)
public struct XSETID<LastId: RESPStringRenderable>: ValkeyCommand {
    public var key: ValkeyKey
    public var lastId: LastId
    public var entriesAdded: Int?
    public var maxDeletedId: String?

    @inlinable public init(_ key: ValkeyKey, lastId: LastId, entriesAdded: Int? = nil, maxDeletedId: String? = nil) {
        self.key = key
        self.lastId = lastId
        self.entriesAdded = entriesAdded
        self.maxDeletedId = maxDeletedId
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray(
            "XSETID",
            key,
            RESPBulkString(lastId),
            RESPWithToken("ENTRIESADDED", entriesAdded),
            RESPWithToken("MAXDELETEDID", maxDeletedId)
        )
    }
}

/// Deletes messages from the beginning of a stream.
@_documentation(visibility: internal)
public struct XTRIM<Threshold: RESPStringRenderable>: ValkeyCommand {
    public enum TrimStrategy: RESPRenderable, Sendable, Hashable {
        case maxlen
        case minid

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .maxlen: "MAXLEN".encode(into: &commandEncoder)
            case .minid: "MINID".encode(into: &commandEncoder)
            }
        }
    }
    public enum TrimOperator: RESPRenderable, Sendable, Hashable {
        case equal
        case approximately

        @inlinable
        public var respEntries: Int { 1 }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            switch self {
            case .equal: "=".encode(into: &commandEncoder)
            case .approximately: "~".encode(into: &commandEncoder)
            }
        }
    }
    public struct Trim: RESPRenderable, Sendable, Hashable {
        @usableFromInline let strategy: TrimStrategy
        @usableFromInline let `operator`: TrimOperator?
        @usableFromInline let threshold: Threshold
        @usableFromInline let count: Int?

        @inlinable public init(strategy: TrimStrategy, `operator`: TrimOperator? = nil, threshold: Threshold, count: Int? = nil) {
            self.strategy = strategy
            self.`operator` = `operator`
            self.threshold = threshold
            self.count = count
        }

        @inlinable
        public var respEntries: Int {
            strategy.respEntries + `operator`.respEntries + RESPBulkString(threshold).respEntries + RESPWithToken("LIMIT", count).respEntries
        }

        @inlinable
        public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            strategy.encode(into: &commandEncoder)
            `operator`.encode(into: &commandEncoder)
            RESPBulkString(threshold).encode(into: &commandEncoder)
            RESPWithToken("LIMIT", count).encode(into: &commandEncoder)
        }
    }
    public typealias Response = Int

    public var key: ValkeyKey
    public var trim: Trim

    @inlinable public init(_ key: ValkeyKey, trim: Trim) {
        self.key = key
        self.trim = trim
    }

    public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

    @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
        commandEncoder.encodeArray("XTRIM", key, trim)
    }
}

extension ValkeyConnectionProtocol {
    /// Returns the number of messages that were successfully acknowledged by the consumer group member of a stream.
    ///
    /// - Documentation: [XACK](https://valkey.io/commands/xack)
    /// - Available: 5.0.0
    /// - Complexity: O(1) for each message ID processed.
    /// - Response: [Integer]: The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have already been acknowledged), and XACK will not count them as successfully acknowledged.
    @inlinable
    @discardableResult
    public func xack<Group: RESPStringRenderable, Id: RESPStringRenderable>(_ key: ValkeyKey, group: Group, ids: [Id]) async throws -> Int {
        try await send(command: XACK(key, group: group, ids: ids))
    }

    /// Appends a new message to a stream. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [XADD](https://valkey.io/commands/xadd)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.2.0: Added the `NOMKSTREAM` option, `MINID` trimming strategy and the `LIMIT` option.
    ///     * 7.0.0: Added support for the `<ms>-*` explicit ID form.
    /// - Complexity: O(1) when adding a new entry, O(N) when trimming where N being the number of entries evicted.
    /// - Response: One of the following
    ///     * [String]: The ID of the added entry. The ID is the one auto-generated if * is passed as ID argument, otherwise the command just returns the same ID specified by the user during insertion.
    ///     * [Null]: The NOMKSTREAM option is given and the key doesn't exist.
    @inlinable
    @discardableResult
    public func xadd<Field: RESPStringRenderable, Value: RESPStringRenderable>(
        _ key: ValkeyKey,
        nomkstream: Bool = false,
        trim: XADD<Field, Value>.Trim? = nil,
        idSelector: XADD<Field, Value>.IdSelector,
        datas: [XADD<Field, Value>.Data]
    ) async throws -> ByteBuffer? {
        try await send(command: XADD(key, nomkstream: nomkstream, trim: trim, idSelector: idSelector, datas: datas))
    }

    /// Changes, or acquires, ownership of messages in a consumer group, as if the messages were delivered to as consumer group member.
    ///
    /// - Documentation: [XAUTOCLAIM](https://valkey.io/commands/xautoclaim)
    /// - Available: 6.2.0
    /// - History:
    ///     * 7.0.0: Added an element to the reply array, containing deleted entries the command cleared from the PEL
    /// - Complexity: O(1) if COUNT is small.
    /// - Response: One of the following
    ///     * [Array]: Claimed stream entries (with data, if `JUSTID` was not given).
    ///     * [Array]: Claimed stream entries (without data, if `JUSTID` was given).
    @inlinable
    @discardableResult
    public func xautoclaim<
        Group: RESPStringRenderable,
        Consumer: RESPStringRenderable,
        MinIdleTime: RESPStringRenderable,
        Start: RESPStringRenderable
    >(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer,
        minIdleTime: MinIdleTime,
        start: Start,
        count: Int? = nil,
        justid: Bool = false
    ) async throws -> XAUTOCLAIMResponse {
        try await send(
            command: XAUTOCLAIM(key, group: group, consumer: consumer, minIdleTime: minIdleTime, start: start, count: count, justid: justid)
        )
    }

    /// Changes, or acquires, ownership of a message in a consumer group, as if the message was delivered a consumer group member.
    ///
    /// - Documentation: [XCLAIM](https://valkey.io/commands/xclaim)
    /// - Available: 5.0.0
    /// - Complexity: O(log N) with N being the number of messages in the PEL of the consumer group.
    /// - Response: Stream entries with IDs matching the specified range.
    @inlinable
    @discardableResult
    public func xclaim<Group: RESPStringRenderable, Consumer: RESPStringRenderable, MinIdleTime: RESPStringRenderable, Id: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer,
        minIdleTime: MinIdleTime,
        ids: [Id],
        ms: Int? = nil,
        unixTimeMilliseconds: Date? = nil,
        count: Int? = nil,
        force: Bool = false,
        justid: Bool = false,
        lastid: String? = nil
    ) async throws -> XCLAIMResponse {
        try await send(
            command: XCLAIM(
                key,
                group: group,
                consumer: consumer,
                minIdleTime: minIdleTime,
                ids: ids,
                ms: ms,
                unixTimeMilliseconds: unixTimeMilliseconds,
                count: count,
                force: force,
                justid: justid,
                lastid: lastid
            )
        )
    }

    /// Returns the number of messages after removing them from a stream.
    ///
    /// - Documentation: [XDEL](https://valkey.io/commands/xdel)
    /// - Available: 5.0.0
    /// - Complexity: O(1) for each single item to delete in the stream, regardless of the stream size.
    /// - Response: [Integer]: The number of entries actually deleted
    @inlinable
    @discardableResult
    public func xdel<Id: RESPStringRenderable>(_ key: ValkeyKey, ids: [Id]) async throws -> Int {
        try await send(command: XDEL(key, ids: ids))
    }

    /// Creates a consumer group.
    ///
    /// - Documentation: [XGROUP CREATE](https://valkey.io/commands/xgroup-create)
    /// - Available: 5.0.0
    /// - History:
    ///     * 7.0.0: Added the `entries_read` named argument.
    /// - Complexity: O(1)
    @inlinable
    public func xgroupCreate<Group: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        idSelector: XGROUP.CREATE<Group>.IdSelector,
        mkstream: Bool = false,
        entriesread: Int? = nil
    ) async throws {
        _ = try await send(command: XGROUP.CREATE(key, group: group, idSelector: idSelector, mkstream: mkstream, entriesread: entriesread))
    }

    /// Creates a consumer in a consumer group.
    ///
    /// - Documentation: [XGROUP CREATECONSUMER](https://valkey.io/commands/xgroup-createconsumer)
    /// - Available: 6.2.0
    /// - Complexity: O(1)
    /// - Response: The number of created consumers (0 or 1)
    @inlinable
    @discardableResult
    public func xgroupCreateconsumer<Group: RESPStringRenderable, Consumer: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer
    ) async throws -> Int {
        try await send(command: XGROUP.CREATECONSUMER(key, group: group, consumer: consumer))
    }

    /// Deletes a consumer from a consumer group.
    ///
    /// - Documentation: [XGROUP DELCONSUMER](https://valkey.io/commands/xgroup-delconsumer)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Integer]: The number of pending messages that were yet associated with such a consumer
    @inlinable
    @discardableResult
    public func xgroupDelconsumer<Group: RESPStringRenderable, Consumer: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        consumer: Consumer
    ) async throws -> Int {
        try await send(command: XGROUP.DELCONSUMER(key, group: group, consumer: consumer))
    }

    /// Destroys a consumer group.
    ///
    /// - Documentation: [XGROUP DESTROY](https://valkey.io/commands/xgroup-destroy)
    /// - Available: 5.0.0
    /// - Complexity: O(N) where N is the number of entries in the group's pending entries list (PEL).
    /// - Response: The number of destroyed consumer groups (0 or 1)
    @inlinable
    @discardableResult
    public func xgroupDestroy<Group: RESPStringRenderable>(_ key: ValkeyKey, group: Group) async throws -> Int {
        try await send(command: XGROUP.DESTROY(key, group: group))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [XGROUP HELP](https://valkey.io/commands/xgroup-help)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Array]: Helpful text about subcommands.
    @inlinable
    @discardableResult
    public func xgroupHelp() async throws -> RESPToken.Array {
        try await send(command: XGROUP.HELP())
    }

    /// Sets the last-delivered ID of a consumer group.
    ///
    /// - Documentation: [XGROUP SETID](https://valkey.io/commands/xgroup-setid)
    /// - Available: 5.0.0
    /// - History:
    ///     * 7.0.0: Added the optional `entries_read` argument.
    /// - Complexity: O(1)
    @inlinable
    public func xgroupSetid<Group: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        idSelector: XGROUP.SETID<Group>.IdSelector,
        entriesread: Int? = nil
    ) async throws {
        _ = try await send(command: XGROUP.SETID(key, group: group, idSelector: idSelector, entriesread: entriesread))
    }

    /// Returns a list of the consumers in a consumer group.
    ///
    /// - Documentation: [XINFO CONSUMERS](https://valkey.io/commands/xinfo-consumers)
    /// - Available: 5.0.0
    /// - History:
    ///     * 7.2.0: Added the `inactive` field, and changed the meaning of `idle`.
    /// - Complexity: O(1)
    /// - Response: [Array]: Array list of consumers
    @inlinable
    public func xinfoConsumers<Group: RESPStringRenderable>(_ key: ValkeyKey, group: Group) async throws -> RESPToken.Array {
        try await send(command: XINFO.CONSUMERS(key, group: group))
    }

    /// Returns a list of the consumer groups of a stream.
    ///
    /// - Documentation: [XINFO GROUPS](https://valkey.io/commands/xinfo-groups)
    /// - Available: 5.0.0
    /// - History:
    ///     * 7.0.0: Added the `entries-read` and `lag` fields
    /// - Complexity: O(1)
    @inlinable
    public func xinfoGroups(_ key: ValkeyKey) async throws -> RESPToken.Array {
        try await send(command: XINFO.GROUPS(key))
    }

    /// Returns helpful text about the different subcommands.
    ///
    /// - Documentation: [XINFO HELP](https://valkey.io/commands/xinfo-help)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Array]: Helpful text about subcommands.
    @inlinable
    @discardableResult
    public func xinfoHelp() async throws -> RESPToken.Array {
        try await send(command: XINFO.HELP())
    }

    /// Returns information about a stream.
    ///
    /// - Documentation: [XINFO STREAM](https://valkey.io/commands/xinfo-stream)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.0.0: Added the `FULL` modifier.
    ///     * 7.0.0: Added the `max-deleted-entry-id`, `entries-added`, `recorded-first-entry-id`, `entries-read` and `lag` fields
    ///     * 7.2.0: Added the `active-time` field, and changed the meaning of `seen-time`.
    /// - Complexity: O(1)
    /// - Response: One of the following
    ///     * [Map]: Summary form, in case `FULL` was not given.
    ///     * [Map]: Extended form, in case `FULL` was given.
    @inlinable
    public func xinfoStream(_ key: ValkeyKey, fullBlock: XINFO.STREAM.FullBlock? = nil) async throws -> RESPToken.Map {
        try await send(command: XINFO.STREAM(key, fullBlock: fullBlock))
    }

    /// Return the number of messages in a stream.
    ///
    /// - Documentation: [XLEN](https://valkey.io/commands/xlen)
    /// - Available: 5.0.0
    /// - Complexity: O(1)
    /// - Response: [Integer]: The number of entries of the stream at key
    @inlinable
    public func xlen(_ key: ValkeyKey) async throws -> Int {
        try await send(command: XLEN(key))
    }

    /// Returns the information and entries from a stream consumer group's pending entries list.
    ///
    /// - Documentation: [XPENDING](https://valkey.io/commands/xpending)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.2.0: Added the `IDLE` option and exclusive range intervals.
    /// - Complexity: O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). O(M), where M is the total number of entries scanned when used with the IDLE filter. When the command returns just the summary and the list of consumers is small, it runs in O(1) time; otherwise, an additional O(N) time for iterating every consumer.
    /// - Response: One of the following
    ///     * [Array]: Extended form, in case `start` was given.
    ///     * [Array]: Summary form, in case `start` was not given.
    @inlinable
    public func xpending<Group: RESPStringRenderable>(
        _ key: ValkeyKey,
        group: Group,
        filters: XPENDING<Group>.Filters? = nil
    ) async throws -> XPENDINGResponse {
        try await send(command: XPENDING(key, group: group, filters: filters))
    }

    /// Returns the messages from a stream within a range of IDs.
    ///
    /// - Documentation: [XRANGE](https://valkey.io/commands/xrange)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.2.0: Added exclusive ranges.
    /// - Complexity: O(N) with N being the number of elements being returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
    /// - Response: [Array]: Stream entries with IDs matching the specified range.
    @inlinable
    public func xrange<Start: RESPStringRenderable, End: RESPStringRenderable>(
        _ key: ValkeyKey,
        start: Start,
        end: End,
        count: Int? = nil
    ) async throws -> XRANGEResponse {
        try await send(command: XRANGE(key, start: start, end: end, count: count))
    }

    /// Returns messages from multiple streams with IDs greater than the ones requested. Blocks until a message is available otherwise.
    ///
    /// - Documentation: [XREAD](https://valkey.io/commands/xread)
    /// - Available: 5.0.0
    /// - Response: One of the following
    ///     * [Map]: A map of key-value elements when each element composed of key name and the entries reported for that key.
    ///     * [Null]: If BLOCK option is given, and a timeout occurs, or there is no stream we can serve.
    @inlinable
    public func xread<Id: RESPStringRenderable>(count: Int? = nil, milliseconds: Int? = nil, streams: XREAD<Id>.Streams) async throws -> XREADResponse
    {
        try await send(command: XREAD(count: count, milliseconds: milliseconds, streams: streams))
    }

    /// Returns new or historical messages from a stream for a consumer in a group. Blocks until a message is available otherwise.
    ///
    /// - Documentation: [XREADGROUP](https://valkey.io/commands/xreadgroup)
    /// - Available: 5.0.0
    /// - Complexity: For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data.
    /// - Response: One of the following
    ///     * [Null]: If BLOCK option is specified and the timeout expired
    ///     * [Map]: A map of key-value elements when each element composed of key name and the entries reported for that key
    @inlinable
    @discardableResult
    public func xreadgroup<Group: RESPStringRenderable, Consumer: RESPStringRenderable, Id: RESPStringRenderable>(
        groupBlock: XREADGROUP<Group, Consumer, Id>.GroupBlock,
        count: Int? = nil,
        milliseconds: Int? = nil,
        noack: Bool = false,
        streams: XREADGROUP<Group, Consumer, Id>.Streams
    ) async throws -> XREADGROUPResponse {
        try await send(command: XREADGROUP(groupBlock: groupBlock, count: count, milliseconds: milliseconds, noack: noack, streams: streams))
    }

    /// Returns the messages from a stream within a range of IDs in reverse order.
    ///
    /// - Documentation: [XREVRANGE](https://valkey.io/commands/xrevrange)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.2.0: Added exclusive ranges.
    /// - Complexity: O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).
    /// - Response: [Array]: An array of the entries with IDs matching the specified range
    @inlinable
    public func xrevrange<End: RESPStringRenderable, Start: RESPStringRenderable>(
        _ key: ValkeyKey,
        end: End,
        start: Start,
        count: Int? = nil
    ) async throws -> XREVRANGEResponse {
        try await send(command: XREVRANGE(key, end: end, start: start, count: count))
    }

    /// An internal command for replicating stream values.
    ///
    /// - Documentation: [XSETID](https://valkey.io/commands/xsetid)
    /// - Available: 5.0.0
    /// - History:
    ///     * 7.0.0: Added the `entries_added` and `max_deleted_entry_id` arguments.
    /// - Complexity: O(1)
    @inlinable
    public func xsetid<LastId: RESPStringRenderable>(
        _ key: ValkeyKey,
        lastId: LastId,
        entriesAdded: Int? = nil,
        maxDeletedId: String? = nil
    ) async throws {
        _ = try await send(command: XSETID(key, lastId: lastId, entriesAdded: entriesAdded, maxDeletedId: maxDeletedId))
    }

    /// Deletes messages from the beginning of a stream.
    ///
    /// - Documentation: [XTRIM](https://valkey.io/commands/xtrim)
    /// - Available: 5.0.0
    /// - History:
    ///     * 6.2.0: Added the `MINID` trimming strategy and the `LIMIT` option.
    /// - Complexity: O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.
    /// - Response: [Integer]: The number of entries deleted from the stream.
    @inlinable
    @discardableResult
    public func xtrim<Threshold: RESPStringRenderable>(_ key: ValkeyKey, trim: XTRIM<Threshold>.Trim) async throws -> Int {
        try await send(command: XTRIM(key, trim: trim))
    }

}
