//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-redis open source project
//
// Copyright (c) 2025 Apple Inc. and the swift-redis project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-redis project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// This file is autogenerated by RedisCommandsBuilder

import NIOCore
import Valkey

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// Appends a string to the value of a key. Creates the key if it doesn't exist.
public struct APPEND: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey
    public var value: String

    @inlinable public init(key: RESPKey, value: String) {
        self.key = key
        self.value = value
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("APPEND", key, value)
    }
}

/// Decrements the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
public struct DECR: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey

    @inlinable public init(key: RESPKey) {
        self.key = key
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("DECR", key)
    }
}

/// Decrements a number from the integer value of a key. Uses 0 as initial value if the key doesn't exist.
public struct DECRBY: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey
    public var decrement: Int

    @inlinable public init(key: RESPKey, decrement: Int) {
        self.key = key
        self.decrement = decrement
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("DECRBY", key, decrement)
    }
}

/// Returns the string value of a key.
public struct GET: RESPCommand {
    public typealias Response = String?

    public var key: RESPKey

    @inlinable public init(key: RESPKey) {
        self.key = key
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("GET", key)
    }
}

/// Returns the string value of a key after deleting the key.
public struct GETDEL: RESPCommand {
    public typealias Response = String?

    public var key: RESPKey

    @inlinable public init(key: RESPKey) {
        self.key = key
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("GETDEL", key)
    }
}

/// Returns the string value of a key after setting its expiration time.
public struct GETEX: RESPCommand {
    public enum Expiration: RESPRenderable {
        case seconds(Int)
        case milliseconds(Int)
        case unixTimeSeconds(Date)
        case unixTimeMilliseconds(Date)
        case persist

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .seconds(let seconds): RESPWithToken("EX", seconds).encode(into: &commandEncoder)
            case .milliseconds(let milliseconds): RESPWithToken("PX", milliseconds).encode(into: &commandEncoder)
            case .unixTimeSeconds(let unixTimeSeconds):
                RESPWithToken("EXAT", Int(unixTimeSeconds.timeIntervalSince1970)).encode(into: &commandEncoder)
            case .unixTimeMilliseconds(let unixTimeMilliseconds):
                RESPWithToken("PXAT", Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000)).encode(into: &commandEncoder)
            case .persist: "PERSIST".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = String?

    public var key: RESPKey
    public var expiration: Expiration? = nil

    @inlinable public init(key: RESPKey, expiration: Expiration? = nil) {
        self.key = key
        self.expiration = expiration
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("GETEX", key, expiration)
    }
}

/// Returns a substring of the string stored at a key.
public struct GETRANGE: RESPCommand {
    public typealias Response = String

    public var key: RESPKey
    public var start: Int
    public var end: Int

    @inlinable public init(key: RESPKey, start: Int, end: Int) {
        self.key = key
        self.start = start
        self.end = end
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("GETRANGE", key, start, end)
    }
}

/// Returns the previous string value of a key after setting it to a new value.
public struct GETSET: RESPCommand {
    public typealias Response = String?

    public var key: RESPKey
    public var value: String

    @inlinable public init(key: RESPKey, value: String) {
        self.key = key
        self.value = value
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("GETSET", key, value)
    }
}

/// Increments the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
public struct INCR: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey

    @inlinable public init(key: RESPKey) {
        self.key = key
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("INCR", key)
    }
}

/// Increments the integer value of a key by a number. Uses 0 as initial value if the key doesn't exist.
public struct INCRBY: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey
    public var increment: Int

    @inlinable public init(key: RESPKey, increment: Int) {
        self.key = key
        self.increment = increment
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("INCRBY", key, increment)
    }
}

/// Increment the floating point value of a key by a number. Uses 0 as initial value if the key doesn't exist.
public struct INCRBYFLOAT: RESPCommand {
    public typealias Response = String

    public var key: RESPKey
    public var increment: Double

    @inlinable public init(key: RESPKey, increment: Double) {
        self.key = key
        self.increment = increment
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("INCRBYFLOAT", key, increment)
    }
}

/// Finds the longest common substring.
public struct LCS: RESPCommand {
    public typealias Response = RESPToken

    public var key1: RESPKey
    public var key2: RESPKey
    public var len: Bool = false
    public var idx: Bool = false
    public var minMatchLen: Int? = nil
    public var withmatchlen: Bool = false

    @inlinable public init(key1: RESPKey, key2: RESPKey, len: Bool = false, idx: Bool = false, minMatchLen: Int? = nil, withmatchlen: Bool = false) {
        self.key1 = key1
        self.key2 = key2
        self.len = len
        self.idx = idx
        self.minMatchLen = minMatchLen
        self.withmatchlen = withmatchlen
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray(
            "LCS",
            key1,
            key2,
            RESPPureToken("LEN", len),
            RESPPureToken("IDX", idx),
            RESPWithToken("MINMATCHLEN", minMatchLen),
            RESPPureToken("WITHMATCHLEN", withmatchlen)
        )
    }
}

/// Atomically returns the string values of one or more keys.
public struct MGET: RESPCommand {
    public typealias Response = [RESPToken]

    public var key: [RESPKey]

    @inlinable public init(key: [RESPKey]) {
        self.key = key
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("MGET", key)
    }
}

/// Atomically creates or modifies the string values of one or more keys.
public struct MSET: RESPCommand {
    public struct Data: RESPRenderable {
        @usableFromInline let key: RESPKey
        @usableFromInline let value: String

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += key.encode(into: &commandEncoder)
            count += value.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = RESPToken

    public var data: [Data]

    @inlinable public init(data: [Data]) {
        self.data = data
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("MSET", data)
    }
}

/// Atomically modifies the string values of one or more keys only when all keys don't exist.
public struct MSETNX: RESPCommand {
    public struct Data: RESPRenderable {
        @usableFromInline let key: RESPKey
        @usableFromInline let value: String

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            var count = 0
            count += key.encode(into: &commandEncoder)
            count += value.encode(into: &commandEncoder)
            return count
        }
    }
    public typealias Response = Int

    public var data: [Data]

    @inlinable public init(data: [Data]) {
        self.data = data
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("MSETNX", data)
    }
}

/// Sets both string value and expiration time in milliseconds of a key. The key is created if it doesn't exist.
public struct PSETEX: RESPCommand {
    public typealias Response = RESPToken

    public var key: RESPKey
    public var milliseconds: Int
    public var value: String

    @inlinable public init(key: RESPKey, milliseconds: Int, value: String) {
        self.key = key
        self.milliseconds = milliseconds
        self.value = value
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("PSETEX", key, milliseconds, value)
    }
}

/// Sets the string value of a key, ignoring its type. The key is created if it doesn't exist.
public struct SET: RESPCommand {
    public enum Condition: RESPRenderable {
        case nx
        case xx

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .nx: "NX".encode(into: &commandEncoder)
            case .xx: "XX".encode(into: &commandEncoder)
            }
        }
    }
    public enum Expiration: RESPRenderable {
        case seconds(Int)
        case milliseconds(Int)
        case unixTimeSeconds(Date)
        case unixTimeMilliseconds(Date)
        case keepttl

        @inlinable
        public func encode(into commandEncoder: inout RESPCommandEncoder) -> Int {
            switch self {
            case .seconds(let seconds): RESPWithToken("EX", seconds).encode(into: &commandEncoder)
            case .milliseconds(let milliseconds): RESPWithToken("PX", milliseconds).encode(into: &commandEncoder)
            case .unixTimeSeconds(let unixTimeSeconds):
                RESPWithToken("EXAT", Int(unixTimeSeconds.timeIntervalSince1970)).encode(into: &commandEncoder)
            case .unixTimeMilliseconds(let unixTimeMilliseconds):
                RESPWithToken("PXAT", Int(unixTimeMilliseconds.timeIntervalSince1970 * 1000)).encode(into: &commandEncoder)
            case .keepttl: "KEEPTTL".encode(into: &commandEncoder)
            }
        }
    }
    public typealias Response = String?

    public var key: RESPKey
    public var value: String
    public var condition: Condition? = nil
    public var get: Bool = false
    public var expiration: Expiration? = nil

    @inlinable public init(key: RESPKey, value: String, condition: Condition? = nil, get: Bool = false, expiration: Expiration? = nil) {
        self.key = key
        self.value = value
        self.condition = condition
        self.get = get
        self.expiration = expiration
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SET", key, value, condition, RESPPureToken("GET", get), expiration)
    }
}

/// Sets the string value and expiration time of a key. Creates the key if it doesn't exist.
public struct SETEX: RESPCommand {
    public typealias Response = RESPToken

    public var key: RESPKey
    public var seconds: Int
    public var value: String

    @inlinable public init(key: RESPKey, seconds: Int, value: String) {
        self.key = key
        self.seconds = seconds
        self.value = value
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SETEX", key, seconds, value)
    }
}

/// Set the string value of a key only when the key doesn't exist.
public struct SETNX: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey
    public var value: String

    @inlinable public init(key: RESPKey, value: String) {
        self.key = key
        self.value = value
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SETNX", key, value)
    }
}

/// Overwrites a part of a string value with another by an offset. Creates the key if it doesn't exist.
public struct SETRANGE: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey
    public var offset: Int
    public var value: String

    @inlinable public init(key: RESPKey, offset: Int, value: String) {
        self.key = key
        self.offset = offset
        self.value = value
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SETRANGE", key, offset, value)
    }
}

/// Returns the length of a string value.
public struct STRLEN: RESPCommand {
    public typealias Response = Int

    public var key: RESPKey

    @inlinable public init(key: RESPKey) {
        self.key = key
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("STRLEN", key)
    }
}

/// Returns a substring from a string value.
public struct SUBSTR: RESPCommand {
    public typealias Response = String

    public var key: RESPKey
    public var start: Int
    public var end: Int

    @inlinable public init(key: RESPKey, start: Int, end: Int) {
        self.key = key
        self.start = start
        self.end = end
    }

    @inlinable public func encode(into commandEncoder: inout RESPCommandEncoder) {
        commandEncoder.encodeArray("SUBSTR", key, start, end)
    }
}

extension ValkeyConnection {
    /// Appends a string to the value of a key. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [APPEND](https:/redis.io/docs/latest/commands/append)
    /// - Version: 2.0.0
    /// - Complexity: O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation.
    /// - Categories: @write, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the string after the append operation.
    @inlinable
    public func append(key: RESPKey, value: String) async throws -> Int {
        try await send(command: APPEND(key: key, value: value))
    }

    /// Decrements the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [DECR](https:/redis.io/docs/latest/commands/decr)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after decrementing it.
    @inlinable
    public func decr(key: RESPKey) async throws -> Int {
        try await send(command: DECR(key: key))
    }

    /// Decrements a number from the integer value of a key. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [DECRBY](https:/redis.io/docs/latest/commands/decrby)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after decrementing it.
    @inlinable
    public func decrby(key: RESPKey, decrement: Int) async throws -> Int {
        try await send(command: DECRBY(key: key, decrement: decrement))
    }

    /// Returns the string value of a key.
    ///
    /// - Documentation: [GET](https:/redis.io/docs/latest/commands/get)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @read, @string, @fast
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): key does not exist.
    @inlinable
    public func get(key: RESPKey) async throws -> String? {
        try await send(command: GET(key: key))
    }

    /// Returns the string value of a key after deleting the key.
    ///
    /// - Documentation: [GETDEL](https:/redis.io/docs/latest/commands/getdel)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key does not exist or if the key's value type is not a string.
    @inlinable
    public func getdel(key: RESPKey) async throws -> String? {
        try await send(command: GETDEL(key: key))
    }

    /// Returns the string value of a key after setting its expiration time.
    ///
    /// - Documentation: [GETEX](https:/redis.io/docs/latest/commands/getex)
    /// - Version: 6.2.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of `key`
    ///     [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if `key` does not exist.
    @inlinable
    public func getex(key: RESPKey, expiration: GETEX.Expiration? = nil) async throws -> String? {
        try await send(command: GETEX(key: key, expiration: expiration))
    }

    /// Returns a substring of the string stored at a key.
    ///
    /// - Documentation: [GETRANGE](https:/redis.io/docs/latest/commands/getrange)
    /// - Version: 2.4.0
    /// - Complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
    /// - Categories: @read, @string, @slow
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): The substring of the string value stored at key, determined by the offsets start and end (both are inclusive).
    @inlinable
    public func getrange(key: RESPKey, start: Int, end: Int) async throws -> String {
        try await send(command: GETRANGE(key: key, start: start, end: end))
    }

    /// Returns the previous string value of a key after setting it to a new value.
    ///
    /// - Documentation: [GETSET](https:/redis.io/docs/latest/commands/getset)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the old value stored at the key.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): if the key does not exist.
    @inlinable
    public func getset(key: RESPKey, value: String) async throws -> String? {
        try await send(command: GETSET(key: key, value: value))
    }

    /// Increments the integer value of a key by one. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCR](https:/redis.io/docs/latest/commands/incr)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after the increment.
    @inlinable
    public func incr(key: RESPKey) async throws -> Int {
        try await send(command: INCR(key: key))
    }

    /// Increments the integer value of a key by a number. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCRBY](https:/redis.io/docs/latest/commands/incrby)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the value of the key after the increment.
    @inlinable
    public func incrby(key: RESPKey, increment: Int) async throws -> Int {
        try await send(command: INCRBY(key: key, increment: increment))
    }

    /// Increment the floating point value of a key by a number. Uses 0 as initial value if the key doesn't exist.
    ///
    /// - Documentation: [INCRBYFLOAT](https:/redis.io/docs/latest/commands/incrbyfloat)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the value of the key after the increment.
    @inlinable
    public func incrbyfloat(key: RESPKey, increment: Double) async throws -> String {
        try await send(command: INCRBYFLOAT(key: key, increment: increment))
    }

    /// Finds the longest common substring.
    ///
    /// - Documentation: [LCS](https:/redis.io/docs/latest/commands/lcs)
    /// - Version: 7.0.0
    /// - Complexity: O(N*M) where N and M are the lengths of s1 and s2, respectively
    /// - Categories: @read, @string, @slow
    /// - Returns: One of the following:
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the longest common subsequence.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the longest common subsequence when _LEN_ is given.
    ///     * [Map](https:/redis.io/docs/reference/protocol-spec#maps): a map with the LCS length and all the ranges in both the strings when _IDX_ is given.
    @inlinable
    public func lcs(
        key1: RESPKey,
        key2: RESPKey,
        len: Bool = false,
        idx: Bool = false,
        minMatchLen: Int? = nil,
        withmatchlen: Bool = false
    ) async throws -> RESPToken {
        try await send(command: LCS(key1: key1, key2: key2, len: len, idx: idx, minMatchLen: minMatchLen, withmatchlen: withmatchlen))
    }

    /// Atomically returns the string values of one or more keys.
    ///
    /// - Documentation: [MGET](https:/redis.io/docs/latest/commands/mget)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the number of keys to retrieve.
    /// - Categories: @read, @string, @fast
    /// - Returns: [Array](https:/redis.io/docs/reference/protocol-spec#arrays): a list of values at the specified keys.
    @inlinable
    public func mget(key: [RESPKey]) async throws -> [RESPToken] {
        try await send(command: MGET(key: key))
    }

    /// Atomically creates or modifies the string values of one or more keys.
    ///
    /// - Documentation: [MSET](https:/redis.io/docs/latest/commands/mset)
    /// - Version: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Categories: @write, @string, @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): always `OK` because `MSET` can't fail.
    @inlinable
    public func mset(data: [MSET.Data]) async throws -> RESPToken {
        try await send(command: MSET(data: data))
    }

    /// Atomically modifies the string values of one or more keys only when all keys don't exist.
    ///
    /// - Documentation: [MSETNX](https:/redis.io/docs/latest/commands/msetnx)
    /// - Version: 1.0.1
    /// - Complexity: O(N) where N is the number of keys to set.
    /// - Categories: @write, @string, @slow
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if no key was set (at least one key already existed).
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if all the keys were set.
    @inlinable
    public func msetnx(data: [MSETNX.Data]) async throws -> Int {
        try await send(command: MSETNX(data: data))
    }

    /// Sets both string value and expiration time in milliseconds of a key. The key is created if it doesn't exist.
    ///
    /// - Documentation: [PSETEX](https:/redis.io/docs/latest/commands/psetex)
    /// - Version: 2.6.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func psetex(key: RESPKey, milliseconds: Int, value: String) async throws -> RESPToken {
        try await send(command: PSETEX(key: key, milliseconds: milliseconds, value: value))
    }

    /// Sets the string value of a key, ignoring its type. The key is created if it doesn't exist.
    ///
    /// - Documentation: [SET](https:/redis.io/docs/latest/commands/set)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @slow
    /// - Returns: Any of the following:
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): `GET` not given: Operation was aborted (conflict with one of the `XX`/`NX` options).
    ///     * [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`. `GET` not given: The key was set.
    ///     * [Null](https:/redis.io/docs/reference/protocol-spec#nulls): `GET` given: The key didn't exist before the `SET`.
    ///     * [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): `GET` given: The previous value of the key.
    @inlinable
    public func set(
        key: RESPKey,
        value: String,
        condition: SET.Condition? = nil,
        get: Bool = false,
        expiration: SET.Expiration? = nil
    ) async throws -> String? {
        try await send(command: SET(key: key, value: value, condition: condition, get: get, expiration: expiration))
    }

    /// Sets the string value and expiration time of a key. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETEX](https:/redis.io/docs/latest/commands/setex)
    /// - Version: 2.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @slow
    /// - Returns: [Simple string](https:/redis.io/docs/reference/protocol-spec#simple-strings): `OK`.
    @inlinable
    public func setex(key: RESPKey, seconds: Int, value: String) async throws -> RESPToken {
        try await send(command: SETEX(key: key, seconds: seconds, value: value))
    }

    /// Set the string value of a key only when the key doesn't exist.
    ///
    /// - Documentation: [SETNX](https:/redis.io/docs/latest/commands/setnx)
    /// - Version: 1.0.0
    /// - Complexity: O(1)
    /// - Categories: @write, @string, @fast
    /// - Returns: One of the following:
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `0` if the key was not set.
    ///     * [Integer](https:/redis.io/docs/reference/protocol-spec#integers): `1` if the key was set.
    @inlinable
    public func setnx(key: RESPKey, value: String) async throws -> Int {
        try await send(command: SETNX(key: key, value: value))
    }

    /// Overwrites a part of a string value with another by an offset. Creates the key if it doesn't exist.
    ///
    /// - Documentation: [SETRANGE](https:/redis.io/docs/latest/commands/setrange)
    /// - Version: 2.2.0
    /// - Complexity: O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.
    /// - Categories: @write, @string, @slow
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the string after it was modified by the command.
    @inlinable
    public func setrange(key: RESPKey, offset: Int, value: String) async throws -> Int {
        try await send(command: SETRANGE(key: key, offset: offset, value: value))
    }

    /// Returns the length of a string value.
    ///
    /// - Documentation: [STRLEN](https:/redis.io/docs/latest/commands/strlen)
    /// - Version: 2.2.0
    /// - Complexity: O(1)
    /// - Categories: @read, @string, @fast
    /// - Returns: [Integer](https:/redis.io/docs/reference/protocol-spec#integers): the length of the string stored at key, or 0 when the key does not exist.
    @inlinable
    public func strlen(key: RESPKey) async throws -> Int {
        try await send(command: STRLEN(key: key))
    }

    /// Returns a substring from a string value.
    ///
    /// - Documentation: [SUBSTR](https:/redis.io/docs/latest/commands/substr)
    /// - Version: 1.0.0
    /// - Complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
    /// - Categories: @read, @string, @slow
    /// - Returns: [Bulk string](https:/redis.io/docs/reference/protocol-spec#bulk-strings): the substring of the string value stored at key, determined by the offsets start and end (both are inclusive).
    @inlinable
    public func substr(key: RESPKey, start: Int, end: Int) async throws -> String {
        try await send(command: SUBSTR(key: key, start: start, end: end))
    }

}
