//
// This source file is part of the valkey-swift project
// Copyright (c) 2025 the valkey-swift project authors
//
// See LICENSE.txt for license information
// SPDX-License-Identifier: Apache-2.0
//
// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore
import Valkey

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

@_documentation(visibility: internal)
public enum FT {
    /// Performs a search of the specified index. The keys which match the query expression are subjected to further processing as specified
    @_documentation(visibility: internal)
    public struct AGGREGATE<Query: RESPStringRenderable>: ValkeyCommand {
        @inlinable public static var name: String { "FT.AGGREGATE" }

        public var index: ValkeyKey
        public var query: Query

        @inlinable public init(index: ValkeyKey, query: Query) {
            self.index = index
            self.query = query
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(index) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT.AGGREGATE", index, RESPBulkString(query))
        }
    }

    /// Creates an empty search index and initiates the backfill process
    @_documentation(visibility: internal)
    public struct CREATE<IndexName: RESPStringRenderable, FieldIdentifier: RESPStringRenderable>: ValkeyCommand {
        public enum On_Type: RESPRenderable, Sendable, Hashable {
            case hash
            case json

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .hash: "HASH".encode(into: &commandEncoder)
                case .json: "JSON".encode(into: &commandEncoder)
                }
            }
        }
        public struct On: RESPRenderable, Sendable, Hashable {
            public var type: On_Type

            @inlinable
            public init(type: On_Type) {
                self.type = type
            }

            @inlinable
            public var respEntries: Int {
                "ON".respEntries + type.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "ON".encode(into: &commandEncoder)
                type.encode(into: &commandEncoder)
            }
        }
        public struct Prefix: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var prefixes: [String]

            @inlinable
            public init(count: Int, prefixes: [String]) {
                self.count = count
                self.prefixes = prefixes
            }

            @inlinable
            public var respEntries: Int {
                "PREFIX".respEntries + count.respEntries + prefixes.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "PREFIX".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                prefixes.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsAlias: RESPRenderable, Sendable, Hashable {
            public var fieldIdentifier: FieldIdentifier

            @inlinable
            public init(fieldIdentifier: FieldIdentifier) {
                self.fieldIdentifier = fieldIdentifier
            }

            @inlinable
            public var respEntries: Int {
                "AS".respEntries + RESPBulkString(fieldIdentifier).respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "AS".encode(into: &commandEncoder)
                RESPBulkString(fieldIdentifier).encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeTagSeparator: RESPRenderable, Sendable, Hashable {
            public var sep: String

            @inlinable
            public init(sep: String) {
                self.sep = sep
            }

            @inlinable
            public var respEntries: Int {
                "SEPARATOR".respEntries + sep.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SEPARATOR".encode(into: &commandEncoder)
                sep.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeTag: RESPRenderable, Sendable, Hashable {
            public var separator: SchemaFieldsFieldTypeTagSeparator?
            public var casesensitive: Bool

            @inlinable
            public init(separator: SchemaFieldsFieldTypeTagSeparator? = nil, casesensitive: Bool = false) {
                self.separator = separator
                self.casesensitive = casesensitive
            }

            @inlinable
            public var respEntries: Int {
                "TAG".respEntries + separator.respEntries + RESPPureToken("CASESENSITIVE", casesensitive).respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TAG".encode(into: &commandEncoder)
                separator.encode(into: &commandEncoder)
                RESPPureToken("CASESENSITIVE", casesensitive).encode(into: &commandEncoder)
            }
        }
        public enum SchemaFieldsFieldTypeVectorAlgorithm: RESPRenderable, Sendable, Hashable {
            case hnsw
            case flat

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .hnsw: "HNSW".encode(into: &commandEncoder)
                case .flat: "FLAT".encode(into: &commandEncoder)
                }
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParams_Type: RESPRenderable, Sendable, Hashable {

            @inlinable
            public init() {
            }

            @inlinable
            public var respEntries: Int {
                "TYPE".respEntries + "FLOAT32".respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TYPE".encode(into: &commandEncoder)
                "FLOAT32".encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsDim: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "DIM".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DIM".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public enum SchemaFieldsFieldTypeVectorVectorParamsDistanceMetricMetric: RESPRenderable, Sendable, Hashable {
            case l2
            case ip
            case cosine

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .l2: "L2".encode(into: &commandEncoder)
                case .ip: "IP".encode(into: &commandEncoder)
                case .cosine: "COSINE".encode(into: &commandEncoder)
                }
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsDistanceMetric: RESPRenderable, Sendable, Hashable {
            public var metric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetricMetric

            @inlinable
            public init(metric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetricMetric) {
                self.metric = metric
            }

            @inlinable
            public var respEntries: Int {
                "DISTANCE_METRIC".respEntries + metric.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DISTANCE_METRIC".encode(into: &commandEncoder)
                metric.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsM: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "M".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "M".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsEfConstruction: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "EF_CONSTRUCTION".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "EF_CONSTRUCTION".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsBlockSize: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "BLOCK_SIZE".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "BLOCK_SIZE".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParams: RESPRenderable, Sendable, Hashable {
            public var type: SchemaFieldsFieldTypeVectorVectorParams_Type
            public var dim: SchemaFieldsFieldTypeVectorVectorParamsDim
            public var distanceMetric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetric
            public var m: SchemaFieldsFieldTypeVectorVectorParamsM?
            public var efConstruction: SchemaFieldsFieldTypeVectorVectorParamsEfConstruction?
            public var blockSize: SchemaFieldsFieldTypeVectorVectorParamsBlockSize?

            @inlinable
            public init(
                type: SchemaFieldsFieldTypeVectorVectorParams_Type,
                dim: SchemaFieldsFieldTypeVectorVectorParamsDim,
                distanceMetric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetric,
                m: SchemaFieldsFieldTypeVectorVectorParamsM? = nil,
                efConstruction: SchemaFieldsFieldTypeVectorVectorParamsEfConstruction? = nil,
                blockSize: SchemaFieldsFieldTypeVectorVectorParamsBlockSize? = nil
            ) {
                self.type = type
                self.dim = dim
                self.distanceMetric = distanceMetric
                self.m = m
                self.efConstruction = efConstruction
                self.blockSize = blockSize
            }

            @inlinable
            public var respEntries: Int {
                type.respEntries + dim.respEntries + distanceMetric.respEntries + m.respEntries + efConstruction.respEntries + blockSize.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                type.encode(into: &commandEncoder)
                dim.encode(into: &commandEncoder)
                distanceMetric.encode(into: &commandEncoder)
                m.encode(into: &commandEncoder)
                efConstruction.encode(into: &commandEncoder)
                blockSize.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVector: RESPRenderable, Sendable, Hashable {
            public var algorithm: SchemaFieldsFieldTypeVectorAlgorithm
            public var attrCount: Int
            public var vectorParams: SchemaFieldsFieldTypeVectorVectorParams

            @inlinable
            public init(algorithm: SchemaFieldsFieldTypeVectorAlgorithm, attrCount: Int, vectorParams: SchemaFieldsFieldTypeVectorVectorParams) {
                self.algorithm = algorithm
                self.attrCount = attrCount
                self.vectorParams = vectorParams
            }

            @inlinable
            public var respEntries: Int {
                "VECTOR".respEntries + algorithm.respEntries + attrCount.respEntries + vectorParams.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "VECTOR".encode(into: &commandEncoder)
                algorithm.encode(into: &commandEncoder)
                attrCount.encode(into: &commandEncoder)
                vectorParams.encode(into: &commandEncoder)
            }
        }
        public enum SchemaFieldsFieldType: RESPRenderable, Sendable, Hashable {
            case numeric
            case text
            case tag(SchemaFieldsFieldTypeTag)
            case vector(SchemaFieldsFieldTypeVector)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .numeric: "NUMERIC".respEntries
                case .text: "TEXT".respEntries
                case .tag(let tag): tag.respEntries
                case .vector(let vector): vector.respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .numeric: "NUMERIC".encode(into: &commandEncoder)
                case .text: "TEXT".encode(into: &commandEncoder)
                case .tag(let tag): tag.encode(into: &commandEncoder)
                case .vector(let vector): vector.encode(into: &commandEncoder)
                }
            }
        }
        public struct SchemaFields: RESPRenderable, Sendable, Hashable {
            public var fieldIdentifier: FieldIdentifier
            public var alias: SchemaFieldsAlias?
            public var fieldType: SchemaFieldsFieldType

            @inlinable
            public init(fieldIdentifier: FieldIdentifier, alias: SchemaFieldsAlias? = nil, fieldType: SchemaFieldsFieldType) {
                self.fieldIdentifier = fieldIdentifier
                self.alias = alias
                self.fieldType = fieldType
            }

            @inlinable
            public var respEntries: Int {
                RESPBulkString(fieldIdentifier).respEntries + alias.respEntries + fieldType.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                RESPBulkString(fieldIdentifier).encode(into: &commandEncoder)
                alias.encode(into: &commandEncoder)
                fieldType.encode(into: &commandEncoder)
            }
        }
        public struct Schema: RESPRenderable, Sendable, Hashable {
            public var fields: [SchemaFields]

            @inlinable
            public init(fields: [SchemaFields]) {
                self.fields = fields
            }

            @inlinable
            public var respEntries: Int {
                "SCHEMA".respEntries + fields.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SCHEMA".encode(into: &commandEncoder)
                fields.encode(into: &commandEncoder)
            }
        }
        @inlinable public static var name: String { "FT.CREATE" }

        public var indexName: IndexName
        public var on: On?
        public var prefix: Prefix?
        public var schema: Schema

        @inlinable public init(indexName: IndexName, on: On? = nil, prefix: Prefix? = nil, schema: Schema) {
            self.indexName = indexName
            self.on = on
            self.prefix = prefix
            self.schema = schema
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT.CREATE", RESPBulkString(indexName), on, prefix, schema)
        }
    }

    /// Drop the index created by FT.CREATE command. It is an error if the index doesn't exist
    @_documentation(visibility: internal)
    public struct DROPINDEX: ValkeyCommand {
        @inlinable public static var name: String { "FT.DROPINDEX" }

        public var key: ValkeyKey

        @inlinable public init(_ key: ValkeyKey) {
            self.key = key
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT.DROPINDEX", key)
        }
    }

    /// Detailed information about the specified index is returned
    @_documentation(visibility: internal)
    public struct INFO: ValkeyCommand {
        public enum Scope: RESPRenderable, Sendable, Hashable {
            case local
            case global

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .local: "LOCAL".encode(into: &commandEncoder)
                case .global: "GLOBAL".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "FT.INFO" }

        public var key: ValkeyKey
        public var scope: Scope?

        @inlinable public init(_ key: ValkeyKey, scope: Scope? = nil) {
            self.key = key
            self.scope = scope
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT.INFO", key, scope)
        }
    }

    /// Performs a search of the specified index. The keys which match the query expression are returned
    @_documentation(visibility: internal)
    public struct SEARCH<Query: RESPStringRenderable>: ValkeyCommand {
        public struct Timeout: RESPRenderable, Sendable, Hashable {
            public var timeoutMs: Int

            @inlinable
            public init(timeoutMs: Int) {
                self.timeoutMs = timeoutMs
            }

            @inlinable
            public var respEntries: Int {
                "TIMEOUT".respEntries + timeoutMs.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TIMEOUT".encode(into: &commandEncoder)
                timeoutMs.encode(into: &commandEncoder)
            }
        }
        public struct Params: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var pairs: [String]

            @inlinable
            public init(count: Int, pairs: [String]) {
                self.count = count
                self.pairs = pairs
            }

            @inlinable
            public var respEntries: Int {
                "PARAMS".respEntries + count.respEntries + pairs.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "PARAMS".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                pairs.encode(into: &commandEncoder)
            }
        }
        public struct ReturnFields: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var fields: [String]

            @inlinable
            public init(count: Int, fields: [String]) {
                self.count = count
                self.fields = fields
            }

            @inlinable
            public var respEntries: Int {
                "RETURN".respEntries + count.respEntries + fields.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "RETURN".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                fields.encode(into: &commandEncoder)
            }
        }
        public struct Limit: RESPRenderable, Sendable, Hashable {
            public var offset: Int
            public var count: Int

            @inlinable
            public init(offset: Int, count: Int) {
                self.offset = offset
                self.count = count
            }

            @inlinable
            public var respEntries: Int {
                "LIMIT".respEntries + offset.respEntries + count.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "LIMIT".encode(into: &commandEncoder)
                offset.encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
            }
        }
        public struct Dialect: RESPRenderable, Sendable, Hashable {
            public var dialect: Int

            @inlinable
            public init(dialect: Int) {
                self.dialect = dialect
            }

            @inlinable
            public var respEntries: Int {
                "DIALECT".respEntries + dialect.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DIALECT".encode(into: &commandEncoder)
                dialect.encode(into: &commandEncoder)
            }
        }
        @inlinable public static var name: String { "FT.SEARCH" }

        public var index: ValkeyKey
        public var query: Query
        public var nocontent: Bool
        public var timeout: Timeout?
        public var params: Params?
        public var returnFields: ReturnFields?
        public var limit: Limit?
        public var dialect: Dialect?
        public var localonly: Bool

        @inlinable public init(
            index: ValkeyKey,
            query: Query,
            nocontent: Bool = false,
            timeout: Timeout? = nil,
            params: Params? = nil,
            returnFields: ReturnFields? = nil,
            limit: Limit? = nil,
            dialect: Dialect? = nil,
            localonly: Bool = false
        ) {
            self.index = index
            self.query = query
            self.nocontent = nocontent
            self.timeout = timeout
            self.params = params
            self.returnFields = returnFields
            self.limit = limit
            self.dialect = dialect
            self.localonly = localonly
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(index) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "FT.SEARCH",
                index,
                RESPBulkString(query),
                RESPPureToken("NOCONTENT", nocontent),
                timeout,
                params,
                returnFields,
                limit,
                dialect,
                RESPPureToken("LOCALONLY", localonly)
            )
        }
    }

    /// Developer access, not for production use
    @_documentation(visibility: internal)
    public struct DEBUG: ValkeyCommand {
        @inlinable public static var name: String { "FT._DEBUG" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT._DEBUG")
        }
    }

    /// Lists the currently defined indexes
    @_documentation(visibility: internal)
    public struct LIST: ValkeyCommand {
        @inlinable public static var name: String { "FT._LIST" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT._LIST")
        }
    }

}

@available(valkeySwift 1.0, *)
extension ValkeyClientProtocol {
    /// Performs a search of the specified index. The keys which match the query expression are subjected to further processing as specified
    ///
    /// - Documentation: [FT.AGGREGATE](https://valkey.io/commands/ft.aggregate)
    /// - Complexity: O(log N)
    @inlinable
    @discardableResult
    public func ftAggregate<Query: RESPStringRenderable>(index: ValkeyKey, query: Query) async throws -> RESPToken {
        try await execute(FT.AGGREGATE(index: index, query: query))
    }

    /// Creates an empty search index and initiates the backfill process
    ///
    /// - Documentation: [FT.CREATE](https://valkey.io/commands/ft.create)
    /// - Complexity: Construction time O(N log N), where N is the number of indexed items
    @inlinable
    @discardableResult
    public func ftCreate<IndexName: RESPStringRenderable, FieldIdentifier: RESPStringRenderable>(
        indexName: IndexName,
        on: FT.CREATE<IndexName, FieldIdentifier>.On? = nil,
        prefix: FT.CREATE<IndexName, FieldIdentifier>.Prefix? = nil,
        schema: FT.CREATE<IndexName, FieldIdentifier>.Schema
    ) async throws -> RESPToken {
        try await execute(FT.CREATE(indexName: indexName, on: on, prefix: prefix, schema: schema))
    }

    /// Drop the index created by FT.CREATE command. It is an error if the index doesn't exist
    ///
    /// - Documentation: [FT.DROPINDEX](https://valkey.io/commands/ft.dropindex)
    /// - Complexity: O(N)
    @inlinable
    @discardableResult
    public func ftDropindex(_ key: ValkeyKey) async throws -> FT.DROPINDEX.Response {
        try await execute(FT.DROPINDEX(key))
    }

    /// Detailed information about the specified index is returned
    ///
    /// - Documentation: [FT.INFO](https://valkey.io/commands/ft.info)
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func ftInfo(_ key: ValkeyKey, scope: FT.INFO.Scope? = nil) async throws -> FT.INFO.Response {
        try await execute(FT.INFO(key, scope: scope))
    }

    /// Performs a search of the specified index. The keys which match the query expression are returned
    ///
    /// - Documentation: [FT.SEARCH](https://valkey.io/commands/ft.search)
    /// - Complexity: O(log N)
    @inlinable
    @discardableResult
    public func ftSearch<Query: RESPStringRenderable>(
        index: ValkeyKey,
        query: Query,
        nocontent: Bool = false,
        timeout: FT.SEARCH<Query>.Timeout? = nil,
        params: FT.SEARCH<Query>.Params? = nil,
        returnFields: FT.SEARCH<Query>.ReturnFields? = nil,
        limit: FT.SEARCH<Query>.Limit? = nil,
        dialect: FT.SEARCH<Query>.Dialect? = nil,
        localonly: Bool = false
    ) async throws -> RESPToken {
        try await execute(
            FT.SEARCH(
                index: index,
                query: query,
                nocontent: nocontent,
                timeout: timeout,
                params: params,
                returnFields: returnFields,
                limit: limit,
                dialect: dialect,
                localonly: localonly
            )
        )
    }

    /// Developer access, not for production use
    ///
    /// - Documentation: [FT._DEBUG](https://valkey.io/commands/ft._debug)
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func ftDebug() async throws -> FT.DEBUG.Response {
        try await execute(FT.DEBUG())
    }

    /// Lists the currently defined indexes
    ///
    /// - Documentation: [FT._LIST](https://valkey.io/commands/ft._list)
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func ftList() async throws -> FT.LIST.Response {
        try await execute(FT.LIST())
    }

}
