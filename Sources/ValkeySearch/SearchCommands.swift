//
// This source file is part of the valkey-swift project
// Copyright (c) 2025-2026 the valkey-swift project authors
//
// See LICENSE.txt for license information
// SPDX-License-Identifier: Apache-2.0
//
// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore
import Valkey

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

@_documentation(visibility: internal)
public enum FT {
    /// Performs a search of the specified index. The keys which match the query expression are subjected to further processing as specified
    @_documentation(visibility: internal)
    public struct AGGREGATE<Query: RESPStringRenderable>: ValkeyCommand {
        public struct Dialect: RESPRenderable, Sendable, Hashable {
            public var dialectVersion: Int

            @inlinable
            public init(dialectVersion: Int) {
                self.dialectVersion = dialectVersion
            }

            @inlinable
            public var respEntries: Int {
                "DIALECT".respEntries + dialectVersion.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DIALECT".encode(into: &commandEncoder)
                dialectVersion.encode(into: &commandEncoder)
            }
        }
        public struct LoadLoadArgsFields: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var fields: [String]

            @inlinable
            public init(count: Int, fields: [String]) {
                self.count = count
                self.fields = fields
            }

            @inlinable
            public var respEntries: Int {
                count.respEntries + fields.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                count.encode(into: &commandEncoder)
                fields.encode(into: &commandEncoder)
            }
        }
        public enum LoadLoadArgs: RESPRenderable, Sendable, Hashable {
            case all
            case fields(LoadLoadArgsFields)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .all: "*".respEntries
                case .fields(let fields): fields.respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .all: "*".encode(into: &commandEncoder)
                case .fields(let fields): fields.encode(into: &commandEncoder)
                }
            }
        }
        public struct Load: RESPRenderable, Sendable, Hashable {
            public var loadArgs: LoadLoadArgs

            @inlinable
            public init(loadArgs: LoadLoadArgs) {
                self.loadArgs = loadArgs
            }

            @inlinable
            public var respEntries: Int {
                "LOAD".respEntries + loadArgs.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "LOAD".encode(into: &commandEncoder)
                loadArgs.encode(into: &commandEncoder)
            }
        }
        public struct ParamsParameters: RESPRenderable, Sendable, Hashable {
            public var name: String
            public var value: String

            @inlinable
            public init(name: String, value: String) {
                self.name = name
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                name.respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                name.encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct Params: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var parameters: [ParamsParameters]

            @inlinable
            public init(count: Int, parameters: [ParamsParameters]) {
                self.count = count
                self.parameters = parameters
            }

            @inlinable
            public var respEntries: Int {
                "PARAMS".respEntries + count.respEntries + parameters.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "PARAMS".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                parameters.encode(into: &commandEncoder)
            }
        }
        public struct Slop: RESPRenderable, Sendable, Hashable {
            public var slop: Int

            @inlinable
            public init(slop: Int) {
                self.slop = slop
            }

            @inlinable
            public var respEntries: Int {
                "SLOP".respEntries + slop.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SLOP".encode(into: &commandEncoder)
                slop.encode(into: &commandEncoder)
            }
        }
        public struct Timeout: RESPRenderable, Sendable, Hashable {
            public var milliseconds: Int

            @inlinable
            public init(milliseconds: Int) {
                self.milliseconds = milliseconds
            }

            @inlinable
            public var respEntries: Int {
                "TIMEOUT".respEntries + milliseconds.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TIMEOUT".encode(into: &commandEncoder)
                milliseconds.encode(into: &commandEncoder)
            }
        }
        public struct Apply: RESPRenderable, Sendable, Hashable {
            public var expression: String
            public var field: String

            @inlinable
            public init(expression: String, field: String) {
                self.expression = expression
                self.field = field
            }

            @inlinable
            public var respEntries: Int {
                "APPLY".respEntries + expression.respEntries + "AS".respEntries + field.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "APPLY".encode(into: &commandEncoder)
                expression.encode(into: &commandEncoder)
                "AS".encode(into: &commandEncoder)
                field.encode(into: &commandEncoder)
            }
        }
        public struct Filter: RESPRenderable, Sendable, Hashable {
            public var expression: String

            @inlinable
            public init(expression: String) {
                self.expression = expression
            }

            @inlinable
            public var respEntries: Int {
                "FILTER".respEntries + expression.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "FILTER".encode(into: &commandEncoder)
                expression.encode(into: &commandEncoder)
            }
        }
        public enum GroupbyReduceFunction: RESPRenderable, Sendable, Hashable {
            case count
            case countDistinct
            case sum
            case min
            case max
            case avg
            case stddev

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .count: "COUNT".encode(into: &commandEncoder)
                case .countDistinct: "COUNT_DISTINCT".encode(into: &commandEncoder)
                case .sum: "SUM".encode(into: &commandEncoder)
                case .min: "MIN".encode(into: &commandEncoder)
                case .max: "MAX".encode(into: &commandEncoder)
                case .avg: "AVG".encode(into: &commandEncoder)
                case .stddev: "STDDEV".encode(into: &commandEncoder)
                }
            }
        }
        public struct GroupbyReduceAlias: RESPRenderable, Sendable, Hashable {
            public var name: String

            @inlinable
            public init(name: String) {
                self.name = name
            }

            @inlinable
            public var respEntries: Int {
                "AS".respEntries + name.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "AS".encode(into: &commandEncoder)
                name.encode(into: &commandEncoder)
            }
        }
        public struct GroupbyReduce: RESPRenderable, Sendable, Hashable {
            public var function: GroupbyReduceFunction
            public var count: Int
            public var expressions: [String]
            public var alias: GroupbyReduceAlias?

            @inlinable
            public init(function: GroupbyReduceFunction, count: Int, expressions: [String] = [], alias: GroupbyReduceAlias? = nil) {
                self.function = function
                self.count = count
                self.expressions = expressions
                self.alias = alias
            }

            @inlinable
            public var respEntries: Int {
                "REDUCE".respEntries + function.respEntries + count.respEntries + expressions.respEntries + alias.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "REDUCE".encode(into: &commandEncoder)
                function.encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                expressions.encode(into: &commandEncoder)
                alias.encode(into: &commandEncoder)
            }
        }
        public struct Groupby: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var fields: [String]
            public var reduces: [GroupbyReduce]

            @inlinable
            public init(count: Int, fields: [String], reduces: [GroupbyReduce] = []) {
                self.count = count
                self.fields = fields
                self.reduces = reduces
            }

            @inlinable
            public var respEntries: Int {
                "GROUPBY".respEntries + count.respEntries + fields.respEntries + reduces.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "GROUPBY".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                fields.encode(into: &commandEncoder)
                reduces.encode(into: &commandEncoder)
            }
        }
        public struct Limit: RESPRenderable, Sendable, Hashable {
            public var offset: Int
            public var count: Int

            @inlinable
            public init(offset: Int, count: Int) {
                self.offset = offset
                self.count = count
            }

            @inlinable
            public var respEntries: Int {
                "LIMIT".respEntries + offset.respEntries + count.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "LIMIT".encode(into: &commandEncoder)
                offset.encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
            }
        }
        public struct SortbyMax: RESPRenderable, Sendable, Hashable {
            public var num: Int

            @inlinable
            public init(num: Int) {
                self.num = num
            }

            @inlinable
            public var respEntries: Int {
                "MAX".respEntries + num.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "MAX".encode(into: &commandEncoder)
                num.encode(into: &commandEncoder)
            }
        }
        public struct Sortby: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var sortParams: [String]
            public var max: SortbyMax?

            @inlinable
            public init(count: Int, sortParams: [String], max: SortbyMax? = nil) {
                self.count = count
                self.sortParams = sortParams
                self.max = max
            }

            @inlinable
            public var respEntries: Int {
                "SORTBY".respEntries + count.respEntries + sortParams.respEntries + max.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SORTBY".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                sortParams.encode(into: &commandEncoder)
                max.encode(into: &commandEncoder)
            }
        }
        @inlinable public static var name: String { "FT.AGGREGATE" }

        public var index: ValkeyKey
        public var query: Query
        public var dialect: Dialect?
        public var inorder: Bool
        public var load: Load?
        public var params: Params?
        public var slop: Slop?
        public var timeout: Timeout?
        public var verbatim: Bool
        public var applys: [Apply]
        public var filters: [Filter]
        public var groupbys: [Groupby]
        public var limits: [Limit]
        public var sortby: Sortby?

        @inlinable public init(
            index: ValkeyKey,
            query: Query,
            dialect: Dialect? = nil,
            inorder: Bool = false,
            load: Load? = nil,
            params: Params? = nil,
            slop: Slop? = nil,
            timeout: Timeout? = nil,
            verbatim: Bool = false,
            applys: [Apply] = [],
            filters: [Filter] = [],
            groupbys: [Groupby] = [],
            limits: [Limit] = [],
            sortby: Sortby? = nil
        ) {
            self.index = index
            self.query = query
            self.dialect = dialect
            self.inorder = inorder
            self.load = load
            self.params = params
            self.slop = slop
            self.timeout = timeout
            self.verbatim = verbatim
            self.applys = applys
            self.filters = filters
            self.groupbys = groupbys
            self.limits = limits
            self.sortby = sortby
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(index) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "FT.AGGREGATE",
                index,
                RESPRenderableBulkString(query),
                dialect,
                RESPPureToken("INORDER", inorder),
                load,
                params,
                slop,
                timeout,
                RESPPureToken("VERBATIM", verbatim),
                applys,
                filters,
                groupbys,
                limits,
                sortby
            )
        }
    }

    /// Creates an empty search index and initiates the backfill process
    @_documentation(visibility: internal)
    public struct CREATE<IndexName: RESPStringRenderable, FieldIdentifier: RESPStringRenderable>: ValkeyCommand {
        public enum On_Type: RESPRenderable, Sendable, Hashable {
            case hash
            case json

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .hash: "HASH".encode(into: &commandEncoder)
                case .json: "JSON".encode(into: &commandEncoder)
                }
            }
        }
        public struct On: RESPRenderable, Sendable, Hashable {
            public var type: On_Type

            @inlinable
            public init(type: On_Type) {
                self.type = type
            }

            @inlinable
            public var respEntries: Int {
                "ON".respEntries + type.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "ON".encode(into: &commandEncoder)
                type.encode(into: &commandEncoder)
            }
        }
        public struct Prefix: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var prefixes: [String]

            @inlinable
            public init(count: Int, prefixes: [String]) {
                self.count = count
                self.prefixes = prefixes
            }

            @inlinable
            public var respEntries: Int {
                "PREFIX".respEntries + count.respEntries + prefixes.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "PREFIX".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                prefixes.encode(into: &commandEncoder)
            }
        }
        public struct Score: RESPRenderable, Sendable, Hashable {
            public var defaultValue: String

            @inlinable
            public init(defaultValue: String) {
                self.defaultValue = defaultValue
            }

            @inlinable
            public var respEntries: Int {
                "SCORE".respEntries + defaultValue.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SCORE".encode(into: &commandEncoder)
                defaultValue.encode(into: &commandEncoder)
            }
        }
        public struct Language: RESPRenderable, Sendable, Hashable {
            public var language: String

            @inlinable
            public init(language: String) {
                self.language = language
            }

            @inlinable
            public var respEntries: Int {
                "LANGUAGE".respEntries + language.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "LANGUAGE".encode(into: &commandEncoder)
                language.encode(into: &commandEncoder)
            }
        }
        public struct Minstemsize: RESPRenderable, Sendable, Hashable {
            public var minStemSize: Int

            @inlinable
            public init(minStemSize: Int) {
                self.minStemSize = minStemSize
            }

            @inlinable
            public var respEntries: Int {
                "MINSTEMSIZE".respEntries + minStemSize.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "MINSTEMSIZE".encode(into: &commandEncoder)
                minStemSize.encode(into: &commandEncoder)
            }
        }
        public enum Offsets: RESPRenderable, Sendable, Hashable {
            case withoffsets
            case nooffsets

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .withoffsets: "WITHOFFSETS".encode(into: &commandEncoder)
                case .nooffsets: "NOOFFSETS".encode(into: &commandEncoder)
                }
            }
        }
        public struct StopwordsStopwordsList: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var words: [String]

            @inlinable
            public init(count: Int, words: [String]) {
                self.count = count
                self.words = words
            }

            @inlinable
            public var respEntries: Int {
                "STOPWORDS".respEntries + count.respEntries + words.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "STOPWORDS".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                words.encode(into: &commandEncoder)
            }
        }
        public enum Stopwords: RESPRenderable, Sendable, Hashable {
            case nostopwords
            case stopwordsList(StopwordsStopwordsList)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .nostopwords: "NOSTOPWORDS".respEntries
                case .stopwordsList(let stopwordsList): stopwordsList.respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .nostopwords: "NOSTOPWORDS".encode(into: &commandEncoder)
                case .stopwordsList(let stopwordsList): stopwordsList.encode(into: &commandEncoder)
                }
            }
        }
        public struct Punctuation: RESPRenderable, Sendable, Hashable {
            public var punctuation: String

            @inlinable
            public init(punctuation: String) {
                self.punctuation = punctuation
            }

            @inlinable
            public var respEntries: Int {
                "PUNCTUATION".respEntries + punctuation.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "PUNCTUATION".encode(into: &commandEncoder)
                punctuation.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsAlias: RESPRenderable, Sendable, Hashable {
            public var fieldAlias: String

            @inlinable
            public init(fieldAlias: String) {
                self.fieldAlias = fieldAlias
            }

            @inlinable
            public var respEntries: Int {
                "AS".respEntries + fieldAlias.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "AS".encode(into: &commandEncoder)
                fieldAlias.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeTagSeparator: RESPRenderable, Sendable, Hashable {
            public var sep: String

            @inlinable
            public init(sep: String) {
                self.sep = sep
            }

            @inlinable
            public var respEntries: Int {
                "SEPARATOR".respEntries + sep.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SEPARATOR".encode(into: &commandEncoder)
                sep.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeTag: RESPRenderable, Sendable, Hashable {
            public var separator: SchemaFieldsFieldTypeTagSeparator?
            public var casesensitive: Bool

            @inlinable
            public init(separator: SchemaFieldsFieldTypeTagSeparator? = nil, casesensitive: Bool = false) {
                self.separator = separator
                self.casesensitive = casesensitive
            }

            @inlinable
            public var respEntries: Int {
                "TAG".respEntries + separator.respEntries + RESPPureToken("CASESENSITIVE", casesensitive).respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TAG".encode(into: &commandEncoder)
                separator.encode(into: &commandEncoder)
                RESPPureToken("CASESENSITIVE", casesensitive).encode(into: &commandEncoder)
            }
        }
        public enum SchemaFieldsFieldTypeTextSuffixTrie: RESPRenderable, Sendable, Hashable {
            case withsuffixtrie
            case nosuffixtrie

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .withsuffixtrie: "WITHSUFFIXTRIE".encode(into: &commandEncoder)
                case .nosuffixtrie: "NOSUFFIXTRIE".encode(into: &commandEncoder)
                }
            }
        }
        public struct SchemaFieldsFieldTypeTextWeight: RESPRenderable, Sendable, Hashable {
            public var weight: String

            @inlinable
            public init(weight: String) {
                self.weight = weight
            }

            @inlinable
            public var respEntries: Int {
                "WEIGHT".respEntries + weight.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "WEIGHT".encode(into: &commandEncoder)
                weight.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeText: RESPRenderable, Sendable, Hashable {
            public var nostem: Bool
            public var suffixTrie: SchemaFieldsFieldTypeTextSuffixTrie?
            public var weight: SchemaFieldsFieldTypeTextWeight?

            @inlinable
            public init(nostem: Bool = false, suffixTrie: SchemaFieldsFieldTypeTextSuffixTrie? = nil, weight: SchemaFieldsFieldTypeTextWeight? = nil)
            {
                self.nostem = nostem
                self.suffixTrie = suffixTrie
                self.weight = weight
            }

            @inlinable
            public var respEntries: Int {
                "TEXT".respEntries + RESPPureToken("NOSTEM", nostem).respEntries + suffixTrie.respEntries + weight.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TEXT".encode(into: &commandEncoder)
                RESPPureToken("NOSTEM", nostem).encode(into: &commandEncoder)
                suffixTrie.encode(into: &commandEncoder)
                weight.encode(into: &commandEncoder)
            }
        }
        public enum SchemaFieldsFieldTypeVectorAlgorithm: RESPRenderable, Sendable, Hashable {
            case hnsw
            case flat

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .hnsw: "HNSW".encode(into: &commandEncoder)
                case .flat: "FLAT".encode(into: &commandEncoder)
                }
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParams_Type: RESPRenderable, Sendable, Hashable {

            @inlinable
            public init() {
            }

            @inlinable
            public var respEntries: Int {
                "TYPE".respEntries + "FLOAT32".respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TYPE".encode(into: &commandEncoder)
                "FLOAT32".encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsDim: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "DIM".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DIM".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public enum SchemaFieldsFieldTypeVectorVectorParamsDistanceMetricMetric: RESPRenderable, Sendable, Hashable {
            case l2
            case ip
            case cosine

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .l2: "L2".encode(into: &commandEncoder)
                case .ip: "IP".encode(into: &commandEncoder)
                case .cosine: "COSINE".encode(into: &commandEncoder)
                }
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsDistanceMetric: RESPRenderable, Sendable, Hashable {
            public var metric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetricMetric

            @inlinable
            public init(metric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetricMetric) {
                self.metric = metric
            }

            @inlinable
            public var respEntries: Int {
                "DISTANCE_METRIC".respEntries + metric.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DISTANCE_METRIC".encode(into: &commandEncoder)
                metric.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsInitialCap: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "INITIAL_CAP".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "INITIAL_CAP".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsM: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "M".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "M".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsEfConstruction: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "EF_CONSTRUCTION".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "EF_CONSTRUCTION".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsEfRuntime: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "EF_RUNTIME".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "EF_RUNTIME".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParams: RESPRenderable, Sendable, Hashable {
            public var type: SchemaFieldsFieldTypeVectorVectorParams_Type
            public var dim: SchemaFieldsFieldTypeVectorVectorParamsDim
            public var distanceMetric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetric
            public var initialCap: SchemaFieldsFieldTypeVectorVectorParamsInitialCap?
            public var m: SchemaFieldsFieldTypeVectorVectorParamsM?
            public var efConstruction: SchemaFieldsFieldTypeVectorVectorParamsEfConstruction?
            public var efRuntime: SchemaFieldsFieldTypeVectorVectorParamsEfRuntime?

            @inlinable
            public init(
                type: SchemaFieldsFieldTypeVectorVectorParams_Type,
                dim: SchemaFieldsFieldTypeVectorVectorParamsDim,
                distanceMetric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetric,
                initialCap: SchemaFieldsFieldTypeVectorVectorParamsInitialCap? = nil,
                m: SchemaFieldsFieldTypeVectorVectorParamsM? = nil,
                efConstruction: SchemaFieldsFieldTypeVectorVectorParamsEfConstruction? = nil,
                efRuntime: SchemaFieldsFieldTypeVectorVectorParamsEfRuntime? = nil
            ) {
                self.type = type
                self.dim = dim
                self.distanceMetric = distanceMetric
                self.initialCap = initialCap
                self.m = m
                self.efConstruction = efConstruction
                self.efRuntime = efRuntime
            }

            @inlinable
            public var respEntries: Int {
                type.respEntries + dim.respEntries + distanceMetric.respEntries + initialCap.respEntries + m.respEntries + efConstruction.respEntries
                    + efRuntime.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                type.encode(into: &commandEncoder)
                dim.encode(into: &commandEncoder)
                distanceMetric.encode(into: &commandEncoder)
                initialCap.encode(into: &commandEncoder)
                m.encode(into: &commandEncoder)
                efConstruction.encode(into: &commandEncoder)
                efRuntime.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVector: RESPRenderable, Sendable, Hashable {
            public var algorithm: SchemaFieldsFieldTypeVectorAlgorithm
            public var attrCount: Int
            public var vectorParams: SchemaFieldsFieldTypeVectorVectorParams

            @inlinable
            public init(algorithm: SchemaFieldsFieldTypeVectorAlgorithm, attrCount: Int, vectorParams: SchemaFieldsFieldTypeVectorVectorParams) {
                self.algorithm = algorithm
                self.attrCount = attrCount
                self.vectorParams = vectorParams
            }

            @inlinable
            public var respEntries: Int {
                "VECTOR".respEntries + algorithm.respEntries + attrCount.respEntries + vectorParams.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "VECTOR".encode(into: &commandEncoder)
                algorithm.encode(into: &commandEncoder)
                attrCount.encode(into: &commandEncoder)
                vectorParams.encode(into: &commandEncoder)
            }
        }
        public enum SchemaFieldsFieldType: RESPRenderable, Sendable, Hashable {
            case numeric
            case tag(SchemaFieldsFieldTypeTag)
            case text(SchemaFieldsFieldTypeText)
            case vector(SchemaFieldsFieldTypeVector)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .numeric: "NUMERIC".respEntries
                case .tag(let tag): tag.respEntries
                case .text(let text): text.respEntries
                case .vector(let vector): vector.respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .numeric: "NUMERIC".encode(into: &commandEncoder)
                case .tag(let tag): tag.encode(into: &commandEncoder)
                case .text(let text): text.encode(into: &commandEncoder)
                case .vector(let vector): vector.encode(into: &commandEncoder)
                }
            }
        }
        public struct SchemaFields: RESPRenderable, Sendable, Hashable {
            public var fieldIdentifier: FieldIdentifier
            public var alias: SchemaFieldsAlias?
            public var fieldType: SchemaFieldsFieldType
            public var sortable: Bool

            @inlinable
            public init(fieldIdentifier: FieldIdentifier, alias: SchemaFieldsAlias? = nil, fieldType: SchemaFieldsFieldType, sortable: Bool = false) {
                self.fieldIdentifier = fieldIdentifier
                self.alias = alias
                self.fieldType = fieldType
                self.sortable = sortable
            }

            @inlinable
            public var respEntries: Int {
                RESPRenderableBulkString(fieldIdentifier).respEntries + alias.respEntries + fieldType.respEntries
                    + RESPPureToken("SORTABLE", sortable).respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                RESPRenderableBulkString(fieldIdentifier).encode(into: &commandEncoder)
                alias.encode(into: &commandEncoder)
                fieldType.encode(into: &commandEncoder)
                RESPPureToken("SORTABLE", sortable).encode(into: &commandEncoder)
            }
        }
        public struct Schema: RESPRenderable, Sendable, Hashable {
            public var fields: [SchemaFields]

            @inlinable
            public init(fields: [SchemaFields]) {
                self.fields = fields
            }

            @inlinable
            public var respEntries: Int {
                "SCHEMA".respEntries + fields.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SCHEMA".encode(into: &commandEncoder)
                fields.encode(into: &commandEncoder)
            }
        }
        @inlinable public static var name: String { "FT.CREATE" }

        public var indexName: IndexName
        public var on: On?
        public var prefix: Prefix?
        public var score: Score?
        public var language: Language?
        public var skipinitialscan: Bool
        public var minstemsize: Minstemsize?
        public var offsets: Offsets?
        public var stopwords: Stopwords?
        public var punctuation: Punctuation?
        public var schema: Schema

        @inlinable public init(
            indexName: IndexName,
            on: On? = nil,
            prefix: Prefix? = nil,
            score: Score? = nil,
            language: Language? = nil,
            skipinitialscan: Bool = false,
            minstemsize: Minstemsize? = nil,
            offsets: Offsets? = nil,
            stopwords: Stopwords? = nil,
            punctuation: Punctuation? = nil,
            schema: Schema
        ) {
            self.indexName = indexName
            self.on = on
            self.prefix = prefix
            self.score = score
            self.language = language
            self.skipinitialscan = skipinitialscan
            self.minstemsize = minstemsize
            self.offsets = offsets
            self.stopwords = stopwords
            self.punctuation = punctuation
            self.schema = schema
        }

        public var keysAffected: [ValkeyKey] { [] }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "FT.CREATE",
                RESPRenderableBulkString(indexName),
                on,
                prefix,
                score,
                language,
                RESPPureToken("SKIPINITIALSCAN", skipinitialscan),
                minstemsize,
                offsets,
                stopwords,
                punctuation,
                schema
            )
        }
    }

    /// Drop the index created by FT.CREATE command. It is an error if the index doesn't exist
    @_documentation(visibility: internal)
    public struct DROPINDEX: ValkeyCommand {
        @inlinable public static var name: String { "FT.DROPINDEX" }

        public var indexName: ValkeyKey

        @inlinable public init(indexName: ValkeyKey) {
            self.indexName = indexName
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(indexName) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT.DROPINDEX", indexName)
        }
    }

    /// Detailed information about the specified index is returned
    @_documentation(visibility: internal)
    public struct INFO: ValkeyCommand {
        public enum Scope: RESPRenderable, Sendable, Hashable {
            case local
            case primary
            case cluster

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .local: "LOCAL".encode(into: &commandEncoder)
                case .primary: "PRIMARY".encode(into: &commandEncoder)
                case .cluster: "CLUSTER".encode(into: &commandEncoder)
                }
            }
        }
        public enum ShardPolicy: RESPRenderable, Sendable, Hashable {
            case allshards
            case someshards

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .allshards: "ALLSHARDS".encode(into: &commandEncoder)
                case .someshards: "SOMESHARDS".encode(into: &commandEncoder)
                }
            }
        }
        public enum Consistency: RESPRenderable, Sendable, Hashable {
            case consistent
            case inconsistent

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .consistent: "CONSISTENT".encode(into: &commandEncoder)
                case .inconsistent: "INCONSISTENT".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "FT.INFO" }

        public var indexName: ValkeyKey
        public var scope: Scope?
        public var shardPolicy: ShardPolicy?
        public var consistency: Consistency?

        @inlinable public init(indexName: ValkeyKey, scope: Scope? = nil, shardPolicy: ShardPolicy? = nil, consistency: Consistency? = nil) {
            self.indexName = indexName
            self.scope = scope
            self.shardPolicy = shardPolicy
            self.consistency = consistency
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(indexName) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT.INFO", indexName, scope, shardPolicy, consistency)
        }
    }

    /// Performs a search of the specified index. The keys which match the query expression are returned
    @_documentation(visibility: internal)
    public struct SEARCH<Query: RESPStringRenderable>: ValkeyCommand {
        public enum ShardPolicy: RESPRenderable, Sendable, Hashable {
            case allshards
            case someshards

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .allshards: "ALLSHARDS".encode(into: &commandEncoder)
                case .someshards: "SOMESHARDS".encode(into: &commandEncoder)
                }
            }
        }
        public enum Consistency: RESPRenderable, Sendable, Hashable {
            case consistent
            case inconsistent

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .consistent: "CONSISTENT".encode(into: &commandEncoder)
                case .inconsistent: "INCONSISTENT".encode(into: &commandEncoder)
                }
            }
        }
        public struct Dialect: RESPRenderable, Sendable, Hashable {
            public var dialect: Int

            @inlinable
            public init(dialect: Int) {
                self.dialect = dialect
            }

            @inlinable
            public var respEntries: Int {
                "DIALECT".respEntries + dialect.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DIALECT".encode(into: &commandEncoder)
                dialect.encode(into: &commandEncoder)
            }
        }
        public struct Limit: RESPRenderable, Sendable, Hashable {
            public var offset: Int
            public var count: Int

            @inlinable
            public init(offset: Int, count: Int) {
                self.offset = offset
                self.count = count
            }

            @inlinable
            public var respEntries: Int {
                "LIMIT".respEntries + offset.respEntries + count.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "LIMIT".encode(into: &commandEncoder)
                offset.encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
            }
        }
        public struct ParamsParameters: RESPRenderable, Sendable, Hashable {
            public var name: String
            public var value: String

            @inlinable
            public init(name: String, value: String) {
                self.name = name
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                name.respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                name.encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct Params: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var parameters: [ParamsParameters]

            @inlinable
            public init(count: Int, parameters: [ParamsParameters]) {
                self.count = count
                self.parameters = parameters
            }

            @inlinable
            public var respEntries: Int {
                "PARAMS".respEntries + count.respEntries + parameters.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "PARAMS".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                parameters.encode(into: &commandEncoder)
            }
        }
        public struct ReturnFieldsAlias: RESPRenderable, Sendable, Hashable {
            public var name: String

            @inlinable
            public init(name: String) {
                self.name = name
            }

            @inlinable
            public var respEntries: Int {
                "AS".respEntries + name.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "AS".encode(into: &commandEncoder)
                name.encode(into: &commandEncoder)
            }
        }
        public struct ReturnFields: RESPRenderable, Sendable, Hashable {
            public var field: String
            public var alias: ReturnFieldsAlias?

            @inlinable
            public init(field: String, alias: ReturnFieldsAlias? = nil) {
                self.field = field
                self.alias = alias
            }

            @inlinable
            public var respEntries: Int {
                field.respEntries + alias.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                field.encode(into: &commandEncoder)
                alias.encode(into: &commandEncoder)
            }
        }
        public struct Return: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var fields: [ReturnFields]

            @inlinable
            public init(count: Int, fields: [ReturnFields]) {
                self.count = count
                self.fields = fields
            }

            @inlinable
            public var respEntries: Int {
                "RETURN".respEntries + count.respEntries + fields.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "RETURN".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                fields.encode(into: &commandEncoder)
            }
        }
        public struct Slop: RESPRenderable, Sendable, Hashable {
            public var slop: Int

            @inlinable
            public init(slop: Int) {
                self.slop = slop
            }

            @inlinable
            public var respEntries: Int {
                "SLOP".respEntries + slop.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SLOP".encode(into: &commandEncoder)
                slop.encode(into: &commandEncoder)
            }
        }
        public enum SortbyDirection: RESPRenderable, Sendable, Hashable {
            case asc
            case desc

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .asc: "ASC".encode(into: &commandEncoder)
                case .desc: "DESC".encode(into: &commandEncoder)
                }
            }
        }
        public struct Sortby: RESPRenderable, Sendable, Hashable {
            public var field: String
            public var direction: SortbyDirection?

            @inlinable
            public init(field: String, direction: SortbyDirection? = nil) {
                self.field = field
                self.direction = direction
            }

            @inlinable
            public var respEntries: Int {
                "SORTBY".respEntries + field.respEntries + direction.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SORTBY".encode(into: &commandEncoder)
                field.encode(into: &commandEncoder)
                direction.encode(into: &commandEncoder)
            }
        }
        public struct Timeout: RESPRenderable, Sendable, Hashable {
            public var timeoutMs: Int

            @inlinable
            public init(timeoutMs: Int) {
                self.timeoutMs = timeoutMs
            }

            @inlinable
            public var respEntries: Int {
                "TIMEOUT".respEntries + timeoutMs.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TIMEOUT".encode(into: &commandEncoder)
                timeoutMs.encode(into: &commandEncoder)
            }
        }
        @inlinable public static var name: String { "FT.SEARCH" }

        public var index: ValkeyKey
        public var query: Query
        public var shardPolicy: ShardPolicy?
        public var consistency: Consistency?
        public var dialect: Dialect?
        public var inorder: Bool
        public var limit: Limit?
        public var nocontent: Bool
        public var params: Params?
        public var `return`: Return?
        public var slop: Slop?
        public var sortby: Sortby?
        public var timeout: Timeout?
        public var verbatim: Bool
        public var withsortkeys: Bool

        @inlinable public init(
            index: ValkeyKey,
            query: Query,
            shardPolicy: ShardPolicy? = nil,
            consistency: Consistency? = nil,
            dialect: Dialect? = nil,
            inorder: Bool = false,
            limit: Limit? = nil,
            nocontent: Bool = false,
            params: Params? = nil,
            `return`: Return? = nil,
            slop: Slop? = nil,
            sortby: Sortby? = nil,
            timeout: Timeout? = nil,
            verbatim: Bool = false,
            withsortkeys: Bool = false
        ) {
            self.index = index
            self.query = query
            self.shardPolicy = shardPolicy
            self.consistency = consistency
            self.dialect = dialect
            self.inorder = inorder
            self.limit = limit
            self.nocontent = nocontent
            self.params = params
            self.`return` = `return`
            self.slop = slop
            self.sortby = sortby
            self.timeout = timeout
            self.verbatim = verbatim
            self.withsortkeys = withsortkeys
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(index) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "FT.SEARCH",
                index,
                RESPRenderableBulkString(query),
                shardPolicy,
                consistency,
                dialect,
                RESPPureToken("INORDER", inorder),
                limit,
                RESPPureToken("NOCONTENT", nocontent),
                params,
                `return`,
                slop,
                sortby,
                timeout,
                RESPPureToken("VERBATIM", verbatim),
                RESPPureToken("WITHSORTKEYS", withsortkeys)
            )
        }
    }

    /// Developer access, not for production use
    @_documentation(visibility: internal)
    public struct DEBUG: ValkeyCommand {
        @inlinable public static var name: String { "FT._DEBUG" }

        @inlinable public init() {
        }

        public var keysAffected: [ValkeyKey] { [] }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT._DEBUG")
        }
    }

    /// Lists the currently defined indexes
    @_documentation(visibility: internal)
    public struct LIST: ValkeyCommand {
        @inlinable public static var name: String { "FT._LIST" }

        @inlinable public init() {
        }

        public var keysAffected: [ValkeyKey] { [] }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT._LIST")
        }
    }

}

@available(valkeySwift 1.0, *)
extension ValkeyClientProtocol {
    /// Performs a search of the specified index. The keys which match the query expression are subjected to further processing as specified
    ///
    /// - Documentation: [FT.AGGREGATE](https://valkey.io/commands/ft.aggregate)
    /// - Complexity: O(log N)
    @inlinable
    @discardableResult
    public func ftAggregate<Query: RESPStringRenderable>(
        index: ValkeyKey,
        query: Query,
        dialect: FT.AGGREGATE<Query>.Dialect? = nil,
        inorder: Bool = false,
        load: FT.AGGREGATE<Query>.Load? = nil,
        params: FT.AGGREGATE<Query>.Params? = nil,
        slop: FT.AGGREGATE<Query>.Slop? = nil,
        timeout: FT.AGGREGATE<Query>.Timeout? = nil,
        verbatim: Bool = false,
        applys: [FT.AGGREGATE<Query>.Apply] = [],
        filters: [FT.AGGREGATE<Query>.Filter] = [],
        groupbys: [FT.AGGREGATE<Query>.Groupby] = [],
        limits: [FT.AGGREGATE<Query>.Limit] = [],
        sortby: FT.AGGREGATE<Query>.Sortby? = nil
    ) async throws(ValkeyClientError) -> RESPToken {
        try await execute(
            FT.AGGREGATE(
                index: index,
                query: query,
                dialect: dialect,
                inorder: inorder,
                load: load,
                params: params,
                slop: slop,
                timeout: timeout,
                verbatim: verbatim,
                applys: applys,
                filters: filters,
                groupbys: groupbys,
                limits: limits,
                sortby: sortby
            )
        )
    }

    /// Creates an empty search index and initiates the backfill process
    ///
    /// - Documentation: [FT.CREATE](https://valkey.io/commands/ft.create)
    /// - Complexity: Construction time O(N log N), where N is the number of indexed items
    @inlinable
    @discardableResult
    public func ftCreate<IndexName: RESPStringRenderable, FieldIdentifier: RESPStringRenderable>(
        indexName: IndexName,
        on: FT.CREATE<IndexName, FieldIdentifier>.On? = nil,
        prefix: FT.CREATE<IndexName, FieldIdentifier>.Prefix? = nil,
        score: FT.CREATE<IndexName, FieldIdentifier>.Score? = nil,
        language: FT.CREATE<IndexName, FieldIdentifier>.Language? = nil,
        skipinitialscan: Bool = false,
        minstemsize: FT.CREATE<IndexName, FieldIdentifier>.Minstemsize? = nil,
        offsets: FT.CREATE<IndexName, FieldIdentifier>.Offsets? = nil,
        stopwords: FT.CREATE<IndexName, FieldIdentifier>.Stopwords? = nil,
        punctuation: FT.CREATE<IndexName, FieldIdentifier>.Punctuation? = nil,
        schema: FT.CREATE<IndexName, FieldIdentifier>.Schema
    ) async throws(ValkeyClientError) -> RESPToken {
        try await execute(
            FT.CREATE(
                indexName: indexName,
                on: on,
                prefix: prefix,
                score: score,
                language: language,
                skipinitialscan: skipinitialscan,
                minstemsize: minstemsize,
                offsets: offsets,
                stopwords: stopwords,
                punctuation: punctuation,
                schema: schema
            )
        )
    }

    /// Drop the index created by FT.CREATE command. It is an error if the index doesn't exist
    ///
    /// - Documentation: [FT.DROPINDEX](https://valkey.io/commands/ft.dropindex)
    /// - Complexity: O(N)
    @inlinable
    @discardableResult
    public func ftDropindex(indexName: ValkeyKey) async throws(ValkeyClientError) -> FT.DROPINDEX.Response {
        try await execute(FT.DROPINDEX(indexName: indexName))
    }

    /// Detailed information about the specified index is returned
    ///
    /// - Documentation: [FT.INFO](https://valkey.io/commands/ft.info)
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func ftInfo(
        indexName: ValkeyKey,
        scope: FT.INFO.Scope? = nil,
        shardPolicy: FT.INFO.ShardPolicy? = nil,
        consistency: FT.INFO.Consistency? = nil
    ) async throws(ValkeyClientError) -> FT.INFO.Response {
        try await execute(FT.INFO(indexName: indexName, scope: scope, shardPolicy: shardPolicy, consistency: consistency))
    }

    /// Performs a search of the specified index. The keys which match the query expression are returned
    ///
    /// - Documentation: [FT.SEARCH](https://valkey.io/commands/ft.search)
    /// - Complexity: O(log N)
    @inlinable
    @discardableResult
    public func ftSearch<Query: RESPStringRenderable>(
        index: ValkeyKey,
        query: Query,
        shardPolicy: FT.SEARCH<Query>.ShardPolicy? = nil,
        consistency: FT.SEARCH<Query>.Consistency? = nil,
        dialect: FT.SEARCH<Query>.Dialect? = nil,
        inorder: Bool = false,
        limit: FT.SEARCH<Query>.Limit? = nil,
        nocontent: Bool = false,
        params: FT.SEARCH<Query>.Params? = nil,
        return: FT.SEARCH<Query>.Return? = nil,
        slop: FT.SEARCH<Query>.Slop? = nil,
        sortby: FT.SEARCH<Query>.Sortby? = nil,
        timeout: FT.SEARCH<Query>.Timeout? = nil,
        verbatim: Bool = false,
        withsortkeys: Bool = false
    ) async throws(ValkeyClientError) -> RESPToken {
        try await execute(
            FT.SEARCH(
                index: index,
                query: query,
                shardPolicy: shardPolicy,
                consistency: consistency,
                dialect: dialect,
                inorder: inorder,
                limit: limit,
                nocontent: nocontent,
                params: params,
                return: `return`,
                slop: slop,
                sortby: sortby,
                timeout: timeout,
                verbatim: verbatim,
                withsortkeys: withsortkeys
            )
        )
    }

    /// Developer access, not for production use
    ///
    /// - Documentation: [FT._DEBUG](https://valkey.io/commands/ft._debug)
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func ftDebug() async throws(ValkeyClientError) -> FT.DEBUG.Response {
        try await execute(FT.DEBUG())
    }

    /// Lists the currently defined indexes
    ///
    /// - Documentation: [FT._LIST](https://valkey.io/commands/ft._list)
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func ftList() async throws(ValkeyClientError) -> FT.LIST.Response {
        try await execute(FT.LIST())
    }

}
