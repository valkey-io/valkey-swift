//
// This source file is part of the valkey-swift project
// Copyright (c) 2025-2026 the valkey-swift project authors
//
// See LICENSE.txt for license information
// SPDX-License-Identifier: Apache-2.0
//
// This file is autogenerated by ValkeyCommandsBuilder

import NIOCore
import Valkey

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

@_documentation(visibility: internal)
public enum FT {
    /// Performs a search of the specified index. The keys which match the query expression are subjected to further processing as specified
    @_documentation(visibility: internal)
    public struct AGGREGATE<Query: RESPStringRenderable>: ValkeyCommand {
        public struct LoadItemsAlias: RESPRenderable, Sendable, Hashable {
            public var property: String

            @inlinable
            public init(property: String) {
                self.property = property
            }

            @inlinable
            public var respEntries: Int {
                "AS".respEntries + property.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "AS".encode(into: &commandEncoder)
                property.encode(into: &commandEncoder)
            }
        }
        public struct LoadItems: RESPRenderable, Sendable, Hashable {
            public var identifier: String
            public var alias: LoadItemsAlias?

            @inlinable
            public init(identifier: String, alias: LoadItemsAlias? = nil) {
                self.identifier = identifier
                self.alias = alias
            }

            @inlinable
            public var respEntries: Int {
                identifier.respEntries + alias.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                identifier.encode(into: &commandEncoder)
                alias.encode(into: &commandEncoder)
            }
        }
        public struct Load: RESPRenderable, Sendable, Hashable {
            public var nargs: Int
            public var items: [LoadItems]

            @inlinable
            public init(nargs: Int, items: [LoadItems]) {
                self.nargs = nargs
                self.items = items
            }

            @inlinable
            public var respEntries: Int {
                "LOAD".respEntries + nargs.respEntries + items.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "LOAD".encode(into: &commandEncoder)
                nargs.encode(into: &commandEncoder)
                items.encode(into: &commandEncoder)
            }
        }
        public struct Groupby: RESPRenderable, Sendable, Hashable {
            public var nargs: Int
            public var groupFields: [String]

            @inlinable
            public init(nargs: Int, groupFields: [String]) {
                self.nargs = nargs
                self.groupFields = groupFields
            }

            @inlinable
            public var respEntries: Int {
                "GROUPBY".respEntries + nargs.respEntries + groupFields.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "GROUPBY".encode(into: &commandEncoder)
                nargs.encode(into: &commandEncoder)
                groupFields.encode(into: &commandEncoder)
            }
        }
        public enum ReduceFunction: RESPRenderable, Sendable, Hashable {
            case count
            case countDistinct
            case countDistinctish
            case sum
            case min
            case max
            case avg
            case stddev
            case quantile
            case tolist
            case firstValue
            case randomSample

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .count: "COUNT".encode(into: &commandEncoder)
                case .countDistinct: "COUNT_DISTINCT".encode(into: &commandEncoder)
                case .countDistinctish: "COUNT_DISTINCT_ISH".encode(into: &commandEncoder)
                case .sum: "SUM".encode(into: &commandEncoder)
                case .min: "MIN".encode(into: &commandEncoder)
                case .max: "MAX".encode(into: &commandEncoder)
                case .avg: "AVG".encode(into: &commandEncoder)
                case .stddev: "STDDEV".encode(into: &commandEncoder)
                case .quantile: "QUANTILE".encode(into: &commandEncoder)
                case .tolist: "TOLIST".encode(into: &commandEncoder)
                case .firstValue: "FIRST_VALUE".encode(into: &commandEncoder)
                case .randomSample: "RANDOM_SAMPLE".encode(into: &commandEncoder)
                }
            }
        }
        public struct ReduceAlias: RESPRenderable, Sendable, Hashable {
            public var identifier: String

            @inlinable
            public init(identifier: String) {
                self.identifier = identifier
            }

            @inlinable
            public var respEntries: Int {
                "AS".respEntries + identifier.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "AS".encode(into: &commandEncoder)
                identifier.encode(into: &commandEncoder)
            }
        }
        public struct Reduce: RESPRenderable, Sendable, Hashable {
            public var function: ReduceFunction
            public var nargs: Int
            public var identifiers: [String]
            public var alias: ReduceAlias?

            @inlinable
            public init(function: ReduceFunction, nargs: Int, identifiers: [String], alias: ReduceAlias? = nil) {
                self.function = function
                self.nargs = nargs
                self.identifiers = identifiers
                self.alias = alias
            }

            @inlinable
            public var respEntries: Int {
                "REDUCE".respEntries + function.respEntries + nargs.respEntries + identifiers.respEntries + alias.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "REDUCE".encode(into: &commandEncoder)
                function.encode(into: &commandEncoder)
                nargs.encode(into: &commandEncoder)
                identifiers.encode(into: &commandEncoder)
                alias.encode(into: &commandEncoder)
            }
        }
        public struct SortbyMax: RESPRenderable, Sendable, Hashable {
            public var num: Int

            @inlinable
            public init(num: Int) {
                self.num = num
            }

            @inlinable
            public var respEntries: Int {
                "MAX".respEntries + num.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "MAX".encode(into: &commandEncoder)
                num.encode(into: &commandEncoder)
            }
        }
        public struct Sortby: RESPRenderable, Sendable, Hashable {
            public var nargs: Int
            public var sortParams: [String]
            public var max: SortbyMax?
            public var withcount: Bool

            @inlinable
            public init(nargs: Int, sortParams: [String], max: SortbyMax? = nil, withcount: Bool = false) {
                self.nargs = nargs
                self.sortParams = sortParams
                self.max = max
                self.withcount = withcount
            }

            @inlinable
            public var respEntries: Int {
                "SORTBY".respEntries + nargs.respEntries + sortParams.respEntries + max.respEntries
                    + RESPPureToken("WITHCOUNT", withcount).respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SORTBY".encode(into: &commandEncoder)
                nargs.encode(into: &commandEncoder)
                sortParams.encode(into: &commandEncoder)
                max.encode(into: &commandEncoder)
                RESPPureToken("WITHCOUNT", withcount).encode(into: &commandEncoder)
            }
        }
        public struct Apply: RESPRenderable, Sendable, Hashable {
            public var expr: String
            public var name: String

            @inlinable
            public init(expr: String, name: String) {
                self.expr = expr
                self.name = name
            }

            @inlinable
            public var respEntries: Int {
                "APPLY".respEntries + expr.respEntries + "AS".respEntries + name.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "APPLY".encode(into: &commandEncoder)
                expr.encode(into: &commandEncoder)
                "AS".encode(into: &commandEncoder)
                name.encode(into: &commandEncoder)
            }
        }
        public struct Limit: RESPRenderable, Sendable, Hashable {
            public var offset: Int
            public var num: Int

            @inlinable
            public init(offset: Int, num: Int) {
                self.offset = offset
                self.num = num
            }

            @inlinable
            public var respEntries: Int {
                "LIMIT".respEntries + offset.respEntries + num.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "LIMIT".encode(into: &commandEncoder)
                offset.encode(into: &commandEncoder)
                num.encode(into: &commandEncoder)
            }
        }
        public struct Filter: RESPRenderable, Sendable, Hashable {
            public var expr: String

            @inlinable
            public init(expr: String) {
                self.expr = expr
            }

            @inlinable
            public var respEntries: Int {
                "FILTER".respEntries + expr.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "FILTER".encode(into: &commandEncoder)
                expr.encode(into: &commandEncoder)
            }
        }
        public struct WithcursorCount: RESPRenderable, Sendable, Hashable {
            public var readSize: Int

            @inlinable
            public init(readSize: Int) {
                self.readSize = readSize
            }

            @inlinable
            public var respEntries: Int {
                "COUNT".respEntries + readSize.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "COUNT".encode(into: &commandEncoder)
                readSize.encode(into: &commandEncoder)
            }
        }
        public struct WithcursorMaxidle: RESPRenderable, Sendable, Hashable {
            public var idleTime: Int

            @inlinable
            public init(idleTime: Int) {
                self.idleTime = idleTime
            }

            @inlinable
            public var respEntries: Int {
                "MAXIDLE".respEntries + idleTime.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "MAXIDLE".encode(into: &commandEncoder)
                idleTime.encode(into: &commandEncoder)
            }
        }
        public struct Withcursor: RESPRenderable, Sendable, Hashable {
            public var count: WithcursorCount
            public var maxidle: WithcursorMaxidle?

            @inlinable
            public init(count: WithcursorCount, maxidle: WithcursorMaxidle? = nil) {
                self.count = count
                self.maxidle = maxidle
            }

            @inlinable
            public var respEntries: Int {
                "WITHCURSOR".respEntries + count.respEntries + maxidle.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "WITHCURSOR".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                maxidle.encode(into: &commandEncoder)
            }
        }
        public struct Timeout: RESPRenderable, Sendable, Hashable {
            public var milliseconds: Int

            @inlinable
            public init(milliseconds: Int) {
                self.milliseconds = milliseconds
            }

            @inlinable
            public var respEntries: Int {
                "TIMEOUT".respEntries + milliseconds.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TIMEOUT".encode(into: &commandEncoder)
                milliseconds.encode(into: &commandEncoder)
            }
        }
        public struct ParamsParameters: RESPRenderable, Sendable, Hashable {
            public var name: String
            public var value: String

            @inlinable
            public init(name: String, value: String) {
                self.name = name
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                name.respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                name.encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct Params: RESPRenderable, Sendable, Hashable {
            public var nargs: Int
            public var parameters: [ParamsParameters]

            @inlinable
            public init(nargs: Int, parameters: [ParamsParameters]) {
                self.nargs = nargs
                self.parameters = parameters
            }

            @inlinable
            public var respEntries: Int {
                "PARAMS".respEntries + nargs.respEntries + parameters.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "PARAMS".encode(into: &commandEncoder)
                nargs.encode(into: &commandEncoder)
                parameters.encode(into: &commandEncoder)
            }
        }
        public struct Scorer: RESPRenderable, Sendable, Hashable {
            public var scorer: String

            @inlinable
            public init(scorer: String) {
                self.scorer = scorer
            }

            @inlinable
            public var respEntries: Int {
                "SCORER".respEntries + scorer.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SCORER".encode(into: &commandEncoder)
                scorer.encode(into: &commandEncoder)
            }
        }
        public struct Dialect: RESPRenderable, Sendable, Hashable {
            public var dialectVersion: Int

            @inlinable
            public init(dialectVersion: Int) {
                self.dialectVersion = dialectVersion
            }

            @inlinable
            public var respEntries: Int {
                "DIALECT".respEntries + dialectVersion.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DIALECT".encode(into: &commandEncoder)
                dialectVersion.encode(into: &commandEncoder)
            }
        }
        @inlinable public static var name: String { "FT.AGGREGATE" }

        public var index: ValkeyKey
        public var query: Query
        public var verbatim: Bool
        public var load: Load?
        public var groupbys: [Groupby]
        public var reduces: [Reduce]
        public var sortby: Sortby?
        public var applys: [Apply]
        public var limit: Limit?
        public var filters: [Filter]
        public var withcursor: Withcursor?
        public var timeout: Timeout?
        public var params: Params?
        public var scorer: Scorer?
        public var addscores: Bool
        public var dialect: Dialect?

        @inlinable public init(
            index: ValkeyKey,
            query: Query,
            verbatim: Bool = false,
            load: Load? = nil,
            groupbys: [Groupby] = [],
            reduces: [Reduce] = [],
            sortby: Sortby? = nil,
            applys: [Apply] = [],
            limit: Limit? = nil,
            filters: [Filter] = [],
            withcursor: Withcursor? = nil,
            timeout: Timeout? = nil,
            params: Params? = nil,
            scorer: Scorer? = nil,
            addscores: Bool = false,
            dialect: Dialect? = nil
        ) {
            self.index = index
            self.query = query
            self.verbatim = verbatim
            self.load = load
            self.groupbys = groupbys
            self.reduces = reduces
            self.sortby = sortby
            self.applys = applys
            self.limit = limit
            self.filters = filters
            self.withcursor = withcursor
            self.timeout = timeout
            self.params = params
            self.scorer = scorer
            self.addscores = addscores
            self.dialect = dialect
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(index) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "FT.AGGREGATE",
                index,
                RESPRenderableBulkString(query),
                RESPPureToken("VERBATIM", verbatim),
                load,
                groupbys,
                reduces,
                sortby,
                applys,
                limit,
                filters,
                withcursor,
                timeout,
                params,
                scorer,
                RESPPureToken("ADDSCORES", addscores),
                dialect
            )
        }
    }

    /// Creates an empty search index and initiates the backfill process
    @_documentation(visibility: internal)
    public struct CREATE<IndexName: RESPStringRenderable, FieldIdentifier: RESPStringRenderable>: ValkeyCommand {
        public enum On_Type: RESPRenderable, Sendable, Hashable {
            case hash
            case json

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .hash: "HASH".encode(into: &commandEncoder)
                case .json: "JSON".encode(into: &commandEncoder)
                }
            }
        }
        public struct On: RESPRenderable, Sendable, Hashable {
            public var type: On_Type

            @inlinable
            public init(type: On_Type) {
                self.type = type
            }

            @inlinable
            public var respEntries: Int {
                "ON".respEntries + type.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "ON".encode(into: &commandEncoder)
                type.encode(into: &commandEncoder)
            }
        }
        public struct Prefix: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var prefixes: [String]

            @inlinable
            public init(count: Int, prefixes: [String]) {
                self.count = count
                self.prefixes = prefixes
            }

            @inlinable
            public var respEntries: Int {
                "PREFIX".respEntries + count.respEntries + prefixes.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "PREFIX".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                prefixes.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsAlias: RESPRenderable, Sendable, Hashable {
            public var fieldIdentifier: FieldIdentifier

            @inlinable
            public init(fieldIdentifier: FieldIdentifier) {
                self.fieldIdentifier = fieldIdentifier
            }

            @inlinable
            public var respEntries: Int {
                "AS".respEntries + RESPRenderableBulkString(fieldIdentifier).respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "AS".encode(into: &commandEncoder)
                RESPRenderableBulkString(fieldIdentifier).encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeTagSeparator: RESPRenderable, Sendable, Hashable {
            public var sep: String

            @inlinable
            public init(sep: String) {
                self.sep = sep
            }

            @inlinable
            public var respEntries: Int {
                "SEPARATOR".respEntries + sep.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SEPARATOR".encode(into: &commandEncoder)
                sep.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeTag: RESPRenderable, Sendable, Hashable {
            public var separator: SchemaFieldsFieldTypeTagSeparator?
            public var casesensitive: Bool

            @inlinable
            public init(separator: SchemaFieldsFieldTypeTagSeparator? = nil, casesensitive: Bool = false) {
                self.separator = separator
                self.casesensitive = casesensitive
            }

            @inlinable
            public var respEntries: Int {
                "TAG".respEntries + separator.respEntries + RESPPureToken("CASESENSITIVE", casesensitive).respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TAG".encode(into: &commandEncoder)
                separator.encode(into: &commandEncoder)
                RESPPureToken("CASESENSITIVE", casesensitive).encode(into: &commandEncoder)
            }
        }
        public enum SchemaFieldsFieldTypeVectorAlgorithm: RESPRenderable, Sendable, Hashable {
            case hnsw
            case flat

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .hnsw: "HNSW".encode(into: &commandEncoder)
                case .flat: "FLAT".encode(into: &commandEncoder)
                }
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParams_Type: RESPRenderable, Sendable, Hashable {

            @inlinable
            public init() {
            }

            @inlinable
            public var respEntries: Int {
                "TYPE".respEntries + "FLOAT32".respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TYPE".encode(into: &commandEncoder)
                "FLOAT32".encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsDim: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "DIM".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DIM".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public enum SchemaFieldsFieldTypeVectorVectorParamsDistanceMetricMetric: RESPRenderable, Sendable, Hashable {
            case l2
            case ip
            case cosine

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .l2: "L2".encode(into: &commandEncoder)
                case .ip: "IP".encode(into: &commandEncoder)
                case .cosine: "COSINE".encode(into: &commandEncoder)
                }
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsDistanceMetric: RESPRenderable, Sendable, Hashable {
            public var metric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetricMetric

            @inlinable
            public init(metric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetricMetric) {
                self.metric = metric
            }

            @inlinable
            public var respEntries: Int {
                "DISTANCE_METRIC".respEntries + metric.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DISTANCE_METRIC".encode(into: &commandEncoder)
                metric.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsM: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "M".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "M".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsEfConstruction: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "EF_CONSTRUCTION".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "EF_CONSTRUCTION".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParamsBlockSize: RESPRenderable, Sendable, Hashable {
            public var value: Int

            @inlinable
            public init(value: Int) {
                self.value = value
            }

            @inlinable
            public var respEntries: Int {
                "BLOCK_SIZE".respEntries + value.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "BLOCK_SIZE".encode(into: &commandEncoder)
                value.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVectorVectorParams: RESPRenderable, Sendable, Hashable {
            public var type: SchemaFieldsFieldTypeVectorVectorParams_Type
            public var dim: SchemaFieldsFieldTypeVectorVectorParamsDim
            public var distanceMetric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetric
            public var m: SchemaFieldsFieldTypeVectorVectorParamsM?
            public var efConstruction: SchemaFieldsFieldTypeVectorVectorParamsEfConstruction?
            public var blockSize: SchemaFieldsFieldTypeVectorVectorParamsBlockSize?

            @inlinable
            public init(
                type: SchemaFieldsFieldTypeVectorVectorParams_Type,
                dim: SchemaFieldsFieldTypeVectorVectorParamsDim,
                distanceMetric: SchemaFieldsFieldTypeVectorVectorParamsDistanceMetric,
                m: SchemaFieldsFieldTypeVectorVectorParamsM? = nil,
                efConstruction: SchemaFieldsFieldTypeVectorVectorParamsEfConstruction? = nil,
                blockSize: SchemaFieldsFieldTypeVectorVectorParamsBlockSize? = nil
            ) {
                self.type = type
                self.dim = dim
                self.distanceMetric = distanceMetric
                self.m = m
                self.efConstruction = efConstruction
                self.blockSize = blockSize
            }

            @inlinable
            public var respEntries: Int {
                type.respEntries + dim.respEntries + distanceMetric.respEntries + m.respEntries + efConstruction.respEntries + blockSize.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                type.encode(into: &commandEncoder)
                dim.encode(into: &commandEncoder)
                distanceMetric.encode(into: &commandEncoder)
                m.encode(into: &commandEncoder)
                efConstruction.encode(into: &commandEncoder)
                blockSize.encode(into: &commandEncoder)
            }
        }
        public struct SchemaFieldsFieldTypeVector: RESPRenderable, Sendable, Hashable {
            public var algorithm: SchemaFieldsFieldTypeVectorAlgorithm
            public var attrCount: Int
            public var vectorParams: SchemaFieldsFieldTypeVectorVectorParams

            @inlinable
            public init(algorithm: SchemaFieldsFieldTypeVectorAlgorithm, attrCount: Int, vectorParams: SchemaFieldsFieldTypeVectorVectorParams) {
                self.algorithm = algorithm
                self.attrCount = attrCount
                self.vectorParams = vectorParams
            }

            @inlinable
            public var respEntries: Int {
                "VECTOR".respEntries + algorithm.respEntries + attrCount.respEntries + vectorParams.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "VECTOR".encode(into: &commandEncoder)
                algorithm.encode(into: &commandEncoder)
                attrCount.encode(into: &commandEncoder)
                vectorParams.encode(into: &commandEncoder)
            }
        }
        public enum SchemaFieldsFieldType: RESPRenderable, Sendable, Hashable {
            case numeric
            case text
            case tag(SchemaFieldsFieldTypeTag)
            case vector(SchemaFieldsFieldTypeVector)

            @inlinable
            public var respEntries: Int {
                switch self {
                case .numeric: "NUMERIC".respEntries
                case .text: "TEXT".respEntries
                case .tag(let tag): tag.respEntries
                case .vector(let vector): vector.respEntries
                }
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .numeric: "NUMERIC".encode(into: &commandEncoder)
                case .text: "TEXT".encode(into: &commandEncoder)
                case .tag(let tag): tag.encode(into: &commandEncoder)
                case .vector(let vector): vector.encode(into: &commandEncoder)
                }
            }
        }
        public struct SchemaFields: RESPRenderable, Sendable, Hashable {
            public var fieldIdentifier: FieldIdentifier
            public var alias: SchemaFieldsAlias?
            public var fieldType: SchemaFieldsFieldType

            @inlinable
            public init(fieldIdentifier: FieldIdentifier, alias: SchemaFieldsAlias? = nil, fieldType: SchemaFieldsFieldType) {
                self.fieldIdentifier = fieldIdentifier
                self.alias = alias
                self.fieldType = fieldType
            }

            @inlinable
            public var respEntries: Int {
                RESPRenderableBulkString(fieldIdentifier).respEntries + alias.respEntries + fieldType.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                RESPRenderableBulkString(fieldIdentifier).encode(into: &commandEncoder)
                alias.encode(into: &commandEncoder)
                fieldType.encode(into: &commandEncoder)
            }
        }
        public struct Schema: RESPRenderable, Sendable, Hashable {
            public var fields: [SchemaFields]

            @inlinable
            public init(fields: [SchemaFields]) {
                self.fields = fields
            }

            @inlinable
            public var respEntries: Int {
                "SCHEMA".respEntries + fields.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "SCHEMA".encode(into: &commandEncoder)
                fields.encode(into: &commandEncoder)
            }
        }
        @inlinable public static var name: String { "FT.CREATE" }

        public var indexName: IndexName
        public var on: On?
        public var prefix: Prefix?
        public var schema: Schema

        @inlinable public init(indexName: IndexName, on: On? = nil, prefix: Prefix? = nil, schema: Schema) {
            self.indexName = indexName
            self.on = on
            self.prefix = prefix
            self.schema = schema
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT.CREATE", RESPRenderableBulkString(indexName), on, prefix, schema)
        }
    }

    /// Drop the index created by FT.CREATE command. It is an error if the index doesn't exist
    @_documentation(visibility: internal)
    public struct DROPINDEX: ValkeyCommand {
        @inlinable public static var name: String { "FT.DROPINDEX" }

        public var key: ValkeyKey

        @inlinable public init(_ key: ValkeyKey) {
            self.key = key
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT.DROPINDEX", key)
        }
    }

    /// Detailed information about the specified index is returned
    @_documentation(visibility: internal)
    public struct INFO: ValkeyCommand {
        public enum Scope: RESPRenderable, Sendable, Hashable {
            case local
            case global

            @inlinable
            public var respEntries: Int { 1 }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                switch self {
                case .local: "LOCAL".encode(into: &commandEncoder)
                case .global: "GLOBAL".encode(into: &commandEncoder)
                }
            }
        }
        @inlinable public static var name: String { "FT.INFO" }

        public var key: ValkeyKey
        public var scope: Scope?

        @inlinable public init(_ key: ValkeyKey, scope: Scope? = nil) {
            self.key = key
            self.scope = scope
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(key) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT.INFO", key, scope)
        }
    }

    /// Performs a search of the specified index. The keys which match the query expression are returned
    @_documentation(visibility: internal)
    public struct SEARCH<Query: RESPStringRenderable>: ValkeyCommand {
        public struct Timeout: RESPRenderable, Sendable, Hashable {
            public var timeoutMs: Int

            @inlinable
            public init(timeoutMs: Int) {
                self.timeoutMs = timeoutMs
            }

            @inlinable
            public var respEntries: Int {
                "TIMEOUT".respEntries + timeoutMs.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "TIMEOUT".encode(into: &commandEncoder)
                timeoutMs.encode(into: &commandEncoder)
            }
        }
        public struct Params: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var pairs: [String]

            @inlinable
            public init(count: Int, pairs: [String]) {
                self.count = count
                self.pairs = pairs
            }

            @inlinable
            public var respEntries: Int {
                "PARAMS".respEntries + count.respEntries + pairs.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "PARAMS".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                pairs.encode(into: &commandEncoder)
            }
        }
        public struct ReturnFields: RESPRenderable, Sendable, Hashable {
            public var count: Int
            public var fields: [String]

            @inlinable
            public init(count: Int, fields: [String]) {
                self.count = count
                self.fields = fields
            }

            @inlinable
            public var respEntries: Int {
                "RETURN".respEntries + count.respEntries + fields.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "RETURN".encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
                fields.encode(into: &commandEncoder)
            }
        }
        public struct Limit: RESPRenderable, Sendable, Hashable {
            public var offset: Int
            public var count: Int

            @inlinable
            public init(offset: Int, count: Int) {
                self.offset = offset
                self.count = count
            }

            @inlinable
            public var respEntries: Int {
                "LIMIT".respEntries + offset.respEntries + count.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "LIMIT".encode(into: &commandEncoder)
                offset.encode(into: &commandEncoder)
                count.encode(into: &commandEncoder)
            }
        }
        public struct Dialect: RESPRenderable, Sendable, Hashable {
            public var dialect: Int

            @inlinable
            public init(dialect: Int) {
                self.dialect = dialect
            }

            @inlinable
            public var respEntries: Int {
                "DIALECT".respEntries + dialect.respEntries
            }

            @inlinable
            public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
                "DIALECT".encode(into: &commandEncoder)
                dialect.encode(into: &commandEncoder)
            }
        }
        @inlinable public static var name: String { "FT.SEARCH" }

        public var index: ValkeyKey
        public var query: Query
        public var nocontent: Bool
        public var timeout: Timeout?
        public var params: Params?
        public var returnFields: ReturnFields?
        public var limit: Limit?
        public var dialect: Dialect?
        public var localonly: Bool

        @inlinable public init(
            index: ValkeyKey,
            query: Query,
            nocontent: Bool = false,
            timeout: Timeout? = nil,
            params: Params? = nil,
            returnFields: ReturnFields? = nil,
            limit: Limit? = nil,
            dialect: Dialect? = nil,
            localonly: Bool = false
        ) {
            self.index = index
            self.query = query
            self.nocontent = nocontent
            self.timeout = timeout
            self.params = params
            self.returnFields = returnFields
            self.limit = limit
            self.dialect = dialect
            self.localonly = localonly
        }

        public var keysAffected: CollectionOfOne<ValkeyKey> { .init(index) }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray(
                "FT.SEARCH",
                index,
                RESPRenderableBulkString(query),
                RESPPureToken("NOCONTENT", nocontent),
                timeout,
                params,
                returnFields,
                limit,
                dialect,
                RESPPureToken("LOCALONLY", localonly)
            )
        }
    }

    /// Developer access, not for production use
    @_documentation(visibility: internal)
    public struct DEBUG: ValkeyCommand {
        @inlinable public static var name: String { "FT._DEBUG" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT._DEBUG")
        }
    }

    /// Lists the currently defined indexes
    @_documentation(visibility: internal)
    public struct LIST: ValkeyCommand {
        @inlinable public static var name: String { "FT._LIST" }

        @inlinable public init() {
        }

        @inlinable public func encode(into commandEncoder: inout ValkeyCommandEncoder) {
            commandEncoder.encodeArray("FT._LIST")
        }
    }

}

@available(valkeySwift 1.0, *)
extension ValkeyClientProtocol {
    /// Performs a search of the specified index. The keys which match the query expression are subjected to further processing as specified
    ///
    /// - Documentation: [FT.AGGREGATE](https://valkey.io/commands/ft.aggregate)
    /// - Complexity: O(log N)
    @inlinable
    @discardableResult
    public func ftAggregate<Query: RESPStringRenderable>(
        index: ValkeyKey,
        query: Query,
        verbatim: Bool = false,
        load: FT.AGGREGATE<Query>.Load? = nil,
        groupbys: [FT.AGGREGATE<Query>.Groupby] = [],
        reduces: [FT.AGGREGATE<Query>.Reduce] = [],
        sortby: FT.AGGREGATE<Query>.Sortby? = nil,
        applys: [FT.AGGREGATE<Query>.Apply] = [],
        limit: FT.AGGREGATE<Query>.Limit? = nil,
        filters: [FT.AGGREGATE<Query>.Filter] = [],
        withcursor: FT.AGGREGATE<Query>.Withcursor? = nil,
        timeout: FT.AGGREGATE<Query>.Timeout? = nil,
        params: FT.AGGREGATE<Query>.Params? = nil,
        scorer: FT.AGGREGATE<Query>.Scorer? = nil,
        addscores: Bool = false,
        dialect: FT.AGGREGATE<Query>.Dialect? = nil
    ) async throws(ValkeyClientError) -> RESPToken {
        try await execute(
            FT.AGGREGATE(
                index: index,
                query: query,
                verbatim: verbatim,
                load: load,
                groupbys: groupbys,
                reduces: reduces,
                sortby: sortby,
                applys: applys,
                limit: limit,
                filters: filters,
                withcursor: withcursor,
                timeout: timeout,
                params: params,
                scorer: scorer,
                addscores: addscores,
                dialect: dialect
            )
        )
    }

    /// Creates an empty search index and initiates the backfill process
    ///
    /// - Documentation: [FT.CREATE](https://valkey.io/commands/ft.create)
    /// - Complexity: Construction time O(N log N), where N is the number of indexed items
    @inlinable
    @discardableResult
    public func ftCreate<IndexName: RESPStringRenderable, FieldIdentifier: RESPStringRenderable>(
        indexName: IndexName,
        on: FT.CREATE<IndexName, FieldIdentifier>.On? = nil,
        prefix: FT.CREATE<IndexName, FieldIdentifier>.Prefix? = nil,
        schema: FT.CREATE<IndexName, FieldIdentifier>.Schema
    ) async throws(ValkeyClientError) -> RESPToken {
        try await execute(FT.CREATE(indexName: indexName, on: on, prefix: prefix, schema: schema))
    }

    /// Drop the index created by FT.CREATE command. It is an error if the index doesn't exist
    ///
    /// - Documentation: [FT.DROPINDEX](https://valkey.io/commands/ft.dropindex)
    /// - Complexity: O(N)
    @inlinable
    @discardableResult
    public func ftDropindex(_ key: ValkeyKey) async throws(ValkeyClientError) -> FT.DROPINDEX.Response {
        try await execute(FT.DROPINDEX(key))
    }

    /// Detailed information about the specified index is returned
    ///
    /// - Documentation: [FT.INFO](https://valkey.io/commands/ft.info)
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func ftInfo(_ key: ValkeyKey, scope: FT.INFO.Scope? = nil) async throws(ValkeyClientError) -> FT.INFO.Response {
        try await execute(FT.INFO(key, scope: scope))
    }

    /// Performs a search of the specified index. The keys which match the query expression are returned
    ///
    /// - Documentation: [FT.SEARCH](https://valkey.io/commands/ft.search)
    /// - Complexity: O(log N)
    @inlinable
    @discardableResult
    public func ftSearch<Query: RESPStringRenderable>(
        index: ValkeyKey,
        query: Query,
        nocontent: Bool = false,
        timeout: FT.SEARCH<Query>.Timeout? = nil,
        params: FT.SEARCH<Query>.Params? = nil,
        returnFields: FT.SEARCH<Query>.ReturnFields? = nil,
        limit: FT.SEARCH<Query>.Limit? = nil,
        dialect: FT.SEARCH<Query>.Dialect? = nil,
        localonly: Bool = false
    ) async throws(ValkeyClientError) -> RESPToken {
        try await execute(
            FT.SEARCH(
                index: index,
                query: query,
                nocontent: nocontent,
                timeout: timeout,
                params: params,
                returnFields: returnFields,
                limit: limit,
                dialect: dialect,
                localonly: localonly
            )
        )
    }

    /// Developer access, not for production use
    ///
    /// - Documentation: [FT._DEBUG](https://valkey.io/commands/ft._debug)
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func ftDebug() async throws(ValkeyClientError) -> FT.DEBUG.Response {
        try await execute(FT.DEBUG())
    }

    /// Lists the currently defined indexes
    ///
    /// - Documentation: [FT._LIST](https://valkey.io/commands/ft._list)
    /// - Complexity: O(1)
    @inlinable
    @discardableResult
    public func ftList() async throws(ValkeyClientError) -> FT.LIST.Response {
        try await execute(FT.LIST())
    }

}
